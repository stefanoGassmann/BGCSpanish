<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej's Guide to C Programming</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }

  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }

  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }

  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }

  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }


  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }

  pre.sourceCode {
      border: 1px solid #ccc;
      padding: 0.5em;
      border-radius: 0.2em;
  }

  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }

  td {
      vertical-align: top;
  }

  body {
      font-size: 12pt;
      max-width: 43em;
      font-family: sans-serif;
  }

  html {
      background: #f9f9f9;
  }

  figure > embed {
      max-width: 100%;
  }

  figure {
      text-align: center;
      margin-top: 2em;
      margin-bottom: 2em;
  }

  figcaption {
      font-size: 0.9em;
      font-style: italic;
      margin-top: 0.6em;
  }

  body {
      counter-reset: figure-counter-major;
      counter-reset: figure-counter-minor;
  }

  figure {
      counter-increment: figure-counter-minor;
  }

  figcaption::before {
      content: "Figure " counter(figure-counter-major) "." counter(figure-counter-minor) ": ";
  }

  /*
  In multipage, we need to reset the figure counter to the chapter
  number. Luckily, this is in the <h1 data-number> attribute. Unluckily,
  there is no way to get this in a general way.

  This doesn't work:

    h1[data-number] {
      counter-set: figure-counter-major attr(data-number);
    }

  Nor this:

    h1[data-number] {
      --figure-counter-major-value: attr(data-number);
      counter-set: figure-counter-major var(--figure-counter-major-value);
    }

  So, dumbly, we have a bunch of rules for all these sections, up to the
  maximum possible section.

  Here's a program to generate them:

    for (let i = 1; i < 100; i++)
        console.log(`h1[data-number="${i}"]{counter-set:figure-counter-major ${i};counter-reset:figure-counter-minor;}`);

  Note to self: never write a book with more than 99 frickin' chapters.
  */

  h1[data-number="1"]{counter-set:figure-counter-major 1;counter-reset:figure-counter-minor;}
  h1[data-number="2"]{counter-set:figure-counter-major 2;counter-reset:figure-counter-minor;}
  h1[data-number="3"]{counter-set:figure-counter-major 3;counter-reset:figure-counter-minor;}
  h1[data-number="4"]{counter-set:figure-counter-major 4;counter-reset:figure-counter-minor;}
  h1[data-number="5"]{counter-set:figure-counter-major 5;counter-reset:figure-counter-minor;}
  h1[data-number="6"]{counter-set:figure-counter-major 6;counter-reset:figure-counter-minor;}
  h1[data-number="7"]{counter-set:figure-counter-major 7;counter-reset:figure-counter-minor;}
  h1[data-number="8"]{counter-set:figure-counter-major 8;counter-reset:figure-counter-minor;}
  h1[data-number="9"]{counter-set:figure-counter-major 9;counter-reset:figure-counter-minor;}
  h1[data-number="10"]{counter-set:figure-counter-major 10;counter-reset:figure-counter-minor;}
  h1[data-number="11"]{counter-set:figure-counter-major 11;counter-reset:figure-counter-minor;}
  h1[data-number="12"]{counter-set:figure-counter-major 12;counter-reset:figure-counter-minor;}
  h1[data-number="13"]{counter-set:figure-counter-major 13;counter-reset:figure-counter-minor;}
  h1[data-number="14"]{counter-set:figure-counter-major 14;counter-reset:figure-counter-minor;}
  h1[data-number="15"]{counter-set:figure-counter-major 15;counter-reset:figure-counter-minor;}
  h1[data-number="16"]{counter-set:figure-counter-major 16;counter-reset:figure-counter-minor;}
  h1[data-number="17"]{counter-set:figure-counter-major 17;counter-reset:figure-counter-minor;}
  h1[data-number="18"]{counter-set:figure-counter-major 18;counter-reset:figure-counter-minor;}
  h1[data-number="19"]{counter-set:figure-counter-major 19;counter-reset:figure-counter-minor;}
  h1[data-number="20"]{counter-set:figure-counter-major 20;counter-reset:figure-counter-minor;}
  h1[data-number="21"]{counter-set:figure-counter-major 21;counter-reset:figure-counter-minor;}
  h1[data-number="22"]{counter-set:figure-counter-major 22;counter-reset:figure-counter-minor;}
  h1[data-number="23"]{counter-set:figure-counter-major 23;counter-reset:figure-counter-minor;}
  h1[data-number="24"]{counter-set:figure-counter-major 24;counter-reset:figure-counter-minor;}
  h1[data-number="25"]{counter-set:figure-counter-major 25;counter-reset:figure-counter-minor;}
  h1[data-number="26"]{counter-set:figure-counter-major 26;counter-reset:figure-counter-minor;}
  h1[data-number="27"]{counter-set:figure-counter-major 27;counter-reset:figure-counter-minor;}
  h1[data-number="28"]{counter-set:figure-counter-major 28;counter-reset:figure-counter-minor;}
  h1[data-number="29"]{counter-set:figure-counter-major 29;counter-reset:figure-counter-minor;}
  h1[data-number="30"]{counter-set:figure-counter-major 30;counter-reset:figure-counter-minor;}
  h1[data-number="31"]{counter-set:figure-counter-major 31;counter-reset:figure-counter-minor;}
  h1[data-number="32"]{counter-set:figure-counter-major 32;counter-reset:figure-counter-minor;}
  h1[data-number="33"]{counter-set:figure-counter-major 33;counter-reset:figure-counter-minor;}
  h1[data-number="34"]{counter-set:figure-counter-major 34;counter-reset:figure-counter-minor;}
  h1[data-number="35"]{counter-set:figure-counter-major 35;counter-reset:figure-counter-minor;}
  h1[data-number="36"]{counter-set:figure-counter-major 36;counter-reset:figure-counter-minor;}
  h1[data-number="37"]{counter-set:figure-counter-major 37;counter-reset:figure-counter-minor;}
  h1[data-number="38"]{counter-set:figure-counter-major 38;counter-reset:figure-counter-minor;}
  h1[data-number="39"]{counter-set:figure-counter-major 39;counter-reset:figure-counter-minor;}
  h1[data-number="40"]{counter-set:figure-counter-major 40;counter-reset:figure-counter-minor;}
  h1[data-number="41"]{counter-set:figure-counter-major 41;counter-reset:figure-counter-minor;}
  h1[data-number="42"]{counter-set:figure-counter-major 42;counter-reset:figure-counter-minor;}
  h1[data-number="43"]{counter-set:figure-counter-major 43;counter-reset:figure-counter-minor;}
  h1[data-number="44"]{counter-set:figure-counter-major 44;counter-reset:figure-counter-minor;}
  h1[data-number="45"]{counter-set:figure-counter-major 45;counter-reset:figure-counter-minor;}
  h1[data-number="46"]{counter-set:figure-counter-major 46;counter-reset:figure-counter-minor;}
  h1[data-number="47"]{counter-set:figure-counter-major 47;counter-reset:figure-counter-minor;}
  h1[data-number="48"]{counter-set:figure-counter-major 48;counter-reset:figure-counter-minor;}
  h1[data-number="49"]{counter-set:figure-counter-major 49;counter-reset:figure-counter-minor;}
  h1[data-number="50"]{counter-set:figure-counter-major 50;counter-reset:figure-counter-minor;}
  h1[data-number="51"]{counter-set:figure-counter-major 51;counter-reset:figure-counter-minor;}
  h1[data-number="52"]{counter-set:figure-counter-major 52;counter-reset:figure-counter-minor;}
  h1[data-number="53"]{counter-set:figure-counter-major 53;counter-reset:figure-counter-minor;}
  h1[data-number="54"]{counter-set:figure-counter-major 54;counter-reset:figure-counter-minor;}
  h1[data-number="55"]{counter-set:figure-counter-major 55;counter-reset:figure-counter-minor;}
  h1[data-number="56"]{counter-set:figure-counter-major 56;counter-reset:figure-counter-minor;}
  h1[data-number="57"]{counter-set:figure-counter-major 57;counter-reset:figure-counter-minor;}
  h1[data-number="58"]{counter-set:figure-counter-major 58;counter-reset:figure-counter-minor;}
  h1[data-number="59"]{counter-set:figure-counter-major 59;counter-reset:figure-counter-minor;}
  h1[data-number="60"]{counter-set:figure-counter-major 60;counter-reset:figure-counter-minor;}
  h1[data-number="61"]{counter-set:figure-counter-major 61;counter-reset:figure-counter-minor;}
  h1[data-number="62"]{counter-set:figure-counter-major 62;counter-reset:figure-counter-minor;}
  h1[data-number="63"]{counter-set:figure-counter-major 63;counter-reset:figure-counter-minor;}
  h1[data-number="64"]{counter-set:figure-counter-major 64;counter-reset:figure-counter-minor;}
  h1[data-number="65"]{counter-set:figure-counter-major 65;counter-reset:figure-counter-minor;}
  h1[data-number="66"]{counter-set:figure-counter-major 66;counter-reset:figure-counter-minor;}
  h1[data-number="67"]{counter-set:figure-counter-major 67;counter-reset:figure-counter-minor;}
  h1[data-number="68"]{counter-set:figure-counter-major 68;counter-reset:figure-counter-minor;}
  h1[data-number="69"]{counter-set:figure-counter-major 69;counter-reset:figure-counter-minor;}
  h1[data-number="70"]{counter-set:figure-counter-major 70;counter-reset:figure-counter-minor;}
  h1[data-number="71"]{counter-set:figure-counter-major 71;counter-reset:figure-counter-minor;}
  h1[data-number="72"]{counter-set:figure-counter-major 72;counter-reset:figure-counter-minor;}
  h1[data-number="73"]{counter-set:figure-counter-major 73;counter-reset:figure-counter-minor;}
  h1[data-number="74"]{counter-set:figure-counter-major 74;counter-reset:figure-counter-minor;}
  h1[data-number="75"]{counter-set:figure-counter-major 75;counter-reset:figure-counter-minor;}
  h1[data-number="76"]{counter-set:figure-counter-major 76;counter-reset:figure-counter-minor;}
  h1[data-number="77"]{counter-set:figure-counter-major 77;counter-reset:figure-counter-minor;}
  h1[data-number="78"]{counter-set:figure-counter-major 78;counter-reset:figure-counter-minor;}
  h1[data-number="79"]{counter-set:figure-counter-major 79;counter-reset:figure-counter-minor;}
  h1[data-number="80"]{counter-set:figure-counter-major 80;counter-reset:figure-counter-minor;}
  h1[data-number="81"]{counter-set:figure-counter-major 81;counter-reset:figure-counter-minor;}
  h1[data-number="82"]{counter-set:figure-counter-major 82;counter-reset:figure-counter-minor;}
  h1[data-number="83"]{counter-set:figure-counter-major 83;counter-reset:figure-counter-minor;}
  h1[data-number="84"]{counter-set:figure-counter-major 84;counter-reset:figure-counter-minor;}
  h1[data-number="85"]{counter-set:figure-counter-major 85;counter-reset:figure-counter-minor;}
  h1[data-number="86"]{counter-set:figure-counter-major 86;counter-reset:figure-counter-minor;}
  h1[data-number="87"]{counter-set:figure-counter-major 87;counter-reset:figure-counter-minor;}
  h1[data-number="88"]{counter-set:figure-counter-major 88;counter-reset:figure-counter-minor;}
  h1[data-number="89"]{counter-set:figure-counter-major 89;counter-reset:figure-counter-minor;}
  h1[data-number="90"]{counter-set:figure-counter-major 90;counter-reset:figure-counter-minor;}
  h1[data-number="91"]{counter-set:figure-counter-major 91;counter-reset:figure-counter-minor;}
  h1[data-number="92"]{counter-set:figure-counter-major 92;counter-reset:figure-counter-minor;}
  h1[data-number="93"]{counter-set:figure-counter-major 93;counter-reset:figure-counter-minor;}
  h1[data-number="94"]{counter-set:figure-counter-major 94;counter-reset:figure-counter-minor;}
  h1[data-number="95"]{counter-set:figure-counter-major 95;counter-reset:figure-counter-minor;}
  h1[data-number="96"]{counter-set:figure-counter-major 96;counter-reset:figure-counter-minor;}
  h1[data-number="97"]{counter-set:figure-counter-major 97;counter-reset:figure-counter-minor;}
  h1[data-number="98"]{counter-set:figure-counter-major 98;counter-reset:figure-counter-minor;}
  h1[data-number="99"]{counter-set:figure-counter-major 99;counter-reset:figure-counter-minor;}


  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->

  <style type="text/css">
  body {
      max-width: inherit;
  }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="/usr/share/javascript/mathjax/MathJax.js" type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Beej's Guide to C Programming</h1>
<p class="subtitle">Traducción Gassmann Stefano Alejandro</p>
<p class="author">Brian “Beej Jorgensen” Hall</p>
<p class="date">v0.9.18, Copyright © August 4, 2024</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#prefacio" id="toc-prefacio"><span class="toc-section-number">1</span> Prefacio</a>
<ul>
<li><a href="#importante" id="toc-importante"><span class="toc-section-number">1.1</span> Importante!</a></li>
<li><a href="#cómo-leer-este-libro" id="toc-cómo-leer-este-libro"><span class="toc-section-number">1.2</span> Cómo leer este libro</a></li>
<li><a href="#plataforma-y-compilador" id="toc-plataforma-y-compilador"><span class="toc-section-number">1.3</span> Plataforma y Compilador</a></li>
<li><a href="#página-web-oficial" id="toc-página-web-oficial"><span class="toc-section-number">1.4</span> Página Web Oficial</a></li>
<li><a href="#política-de-email" id="toc-política-de-email"><span class="toc-section-number">1.5</span> Política de Email</a></li>
<li><a href="#duplicación" id="toc-duplicación"><span class="toc-section-number">1.6</span> Duplicación</a></li>
<li><a href="#nota-para-traductores" id="toc-nota-para-traductores"><span class="toc-section-number">1.7</span> Nota para traductores</a></li>
<li><a href="#derechos-de-autor-y-distribución" id="toc-derechos-de-autor-y-distribución"><span class="toc-section-number">1.8</span> Derechos de autor y distribución</a></li>
<li><a href="#dedicatoria" id="toc-dedicatoria"><span class="toc-section-number">1.9</span> Dedicatoria</a></li>
</ul></li>
<li><a href="#hello-world" id="toc-hello-world"><span class="toc-section-number">2</span> Hello, World!</a>
<ul>
<li><a href="#qué-esperar-de-c" id="toc-qué-esperar-de-c"><span class="toc-section-number">2.1</span> Qué esperar de C</a></li>
<li><a href="#hello-world-1" id="toc-hello-world-1"><span class="toc-section-number">2.2</span> Hello, World!</a></li>
<li><a href="#detalles-de-la-compilación" id="toc-detalles-de-la-compilación"><span class="toc-section-number">2.3</span> Detalles de la Compilación</a></li>
<li><a href="#construyendo-con-gcc" id="toc-construyendo-con-gcc"><span class="toc-section-number">2.4</span> Construyendo con <code>gcc</code></a></li>
<li><a href="#construyendo-con-clang" id="toc-construyendo-con-clang"><span class="toc-section-number">2.5</span> Construyendo con <code>clang</code></a></li>
<li><a href="#construyendo-con-ides" id="toc-construyendo-con-ides"><span class="toc-section-number">2.6</span> Construyendo con IDEs</a></li>
<li><a href="#versiones-de-c" id="toc-versiones-de-c"><span class="toc-section-number">2.7</span> Versiones de C</a></li>
</ul></li>
<li><a href="#variables-y-declaraciones" id="toc-variables-y-declaraciones"><span class="toc-section-number">3</span> Variables y Declaraciones</a>
<ul>
<li><a href="#variables" id="toc-variables"><span class="toc-section-number">3.1</span> Variables</a>
<ul>
<li><a href="#nombres-de-las-variables" id="toc-nombres-de-las-variables"><span class="toc-section-number">3.1.1</span> Nombres de las variables</a></li>
<li><a href="#tipos-de-variables" id="toc-tipos-de-variables"><span class="toc-section-number">3.1.2</span> Tipos de variables</a></li>
<li><a href="#tipo-booleano" id="toc-tipo-booleano"><span class="toc-section-number">3.1.3</span> Tipo booleano</a></li>
</ul></li>
<li><a href="#operadores" id="toc-operadores"><span class="toc-section-number">3.2</span> Operadores y Expresiones</a>
<ul>
<li><a href="#operadores-aritméticos" id="toc-operadores-aritméticos"><span class="toc-section-number">3.2.1</span> Operadores aritméticos</a></li>
<li><a href="#operador-ternario" id="toc-operador-ternario"><span class="toc-section-number">3.2.2</span> Operador ternario</a></li>
<li><a href="#pre-y-post-incremento-y-decremento" id="toc-pre-y-post-incremento-y-decremento"><span class="toc-section-number">3.2.3</span> Pre-y-Post Incremento-y-Decremento</a></li>
<li><a href="#el-operador-coma" id="toc-el-operador-coma"><span class="toc-section-number">3.2.4</span> El operador coma</a></li>
<li><a href="#operadores-condicionales" id="toc-operadores-condicionales"><span class="toc-section-number">3.2.5</span> Operadores condicionales</a></li>
<li><a href="#operadores-booleanos" id="toc-operadores-booleanos"><span class="toc-section-number">3.2.6</span> Operadores Booleanos</a></li>
<li><a href="#sizeof-operator" id="toc-sizeof-operator"><span class="toc-section-number">3.2.7</span> El operador <code>sizeof</code></a></li>
</ul></li>
<li><a href="#control-de-flujo" id="toc-control-de-flujo"><span class="toc-section-number">3.3</span> Control de flujo</a>
<ul>
<li><a href="#ifstat" id="toc-ifstat"><span class="toc-section-number">3.3.1</span> El estado <code>if</code>-<code>else</code></a></li>
<li><a href="#whilestat" id="toc-whilestat"><span class="toc-section-number">3.3.2</span> La declaración <code>while</code></a></li>
<li><a href="#dowhilestat" id="toc-dowhilestat"><span class="toc-section-number">3.3.3</span> La sentencia <code>do-while</code></a></li>
<li><a href="#forstat" id="toc-forstat"><span class="toc-section-number">3.3.4</span> La sentencia `for</a></li>
<li><a href="#switch-statement" id="toc-switch-statement"><span class="toc-section-number">3.3.5</span> Declaración <code>switch</code></a></li>
</ul></li>
</ul></li>
<li><a href="#functions" id="toc-functions"><span class="toc-section-number">4</span> Funciones</a>
<ul>
<li><a href="#passvalue" id="toc-passvalue"><span class="toc-section-number">4.1</span> Transmisión por valor</a></li>
<li><a href="#prototypes" id="toc-prototypes"><span class="toc-section-number">4.2</span> Prototipos de funciones</a></li>
<li><a href="#listas-de-parámetros-vacías" id="toc-listas-de-parámetros-vacías"><span class="toc-section-number">4.3</span> Listas de parámetros vacías</a></li>
</ul></li>
<li><a href="#pointers" id="toc-pointers"><span class="toc-section-number">5</span> Punteros… ¡Poder con miedo!</a>
<ul>
<li><a href="#ptmem" id="toc-ptmem"><span class="toc-section-number">5.1</span> Memoria y variables</a></li>
<li><a href="#pttypes" id="toc-pttypes"><span class="toc-section-number">5.2</span> Tipos de puntero</a></li>
<li><a href="#deref" id="toc-deref"><span class="toc-section-number">5.3</span> Desreferenciación</a></li>
<li><a href="#ptpass" id="toc-ptpass"><span class="toc-section-number">5.4</span> Pasar punteros como argumentos</a></li>
<li><a href="#el-puntero-null" id="toc-el-puntero-null"><span class="toc-section-number">5.5</span> El puntero <code>NULL</code></a></li>
<li><a href="#nota-sobre-la-declaración-de-punteros" id="toc-nota-sobre-la-declaración-de-punteros"><span class="toc-section-number">5.6</span> Nota sobre la declaración de punteros</a></li>
<li><a href="#sizeof-y-punteros" id="toc-sizeof-y-punteros"><span class="toc-section-number">5.7</span> <code>sizeof</code> y punteros</a></li>
</ul></li>
<li><a href="#arrays" id="toc-arrays"><span class="toc-section-number">6</span> Arrays</a>
<ul>
<li><a href="#ejemplo-sencillo" id="toc-ejemplo-sencillo"><span class="toc-section-number">6.1</span> Ejemplo sencillo</a></li>
<li><a href="#obtener-la-longitud-de-una-matriz" id="toc-obtener-la-longitud-de-una-matriz"><span class="toc-section-number">6.2</span> Obtener la longitud de una matriz</a></li>
<li><a href="#inicializadores-de-matrices" id="toc-inicializadores-de-matrices"><span class="toc-section-number">6.3</span> Inicializadores de matrices</a></li>
<li><a href="#fuera-de-los-límites-out-of-bounds" id="toc-fuera-de-los-límites-out-of-bounds"><span class="toc-section-number">6.4</span> ¡Fuera de los límites! (Out of Bounds!)</a></li>
<li><a href="#matrices-multidimensionales" id="toc-matrices-multidimensionales"><span class="toc-section-number">6.5</span> Matrices multidimensionales</a></li>
<li><a href="#matrices-y-punteros" id="toc-matrices-y-punteros"><span class="toc-section-number">6.6</span> Matrices y punteros</a>
<ul>
<li><a href="#obtener-un-puntero-a-una-matriz" id="toc-obtener-un-puntero-a-una-matriz"><span class="toc-section-number">6.6.1</span> Obtener un puntero a una matriz</a></li>
<li><a href="#passing1darrays" id="toc-passing1darrays"><span class="toc-section-number">6.6.2</span> Paso de matrices unidimensionales a funciones</a></li>
<li><a href="#modificación-de-matrices-en-funciones" id="toc-modificación-de-matrices-en-funciones"><span class="toc-section-number">6.6.3</span> Modificación de matrices en funciones</a></li>
<li><a href="#paso-de-matrices-multidimensionales-a-funciones" id="toc-paso-de-matrices-multidimensionales-a-funciones"><span class="toc-section-number">6.6.4</span> Paso de matrices multidimensionales a funciones</a></li>
</ul></li>
</ul></li>
<li><a href="#strings-cadenas-de-caracteres" id="toc-strings-cadenas-de-caracteres"><span class="toc-section-number">7</span> Strings (“Cadenas” de caracteres)</a>
<ul>
<li><a href="#literales-de-cadena" id="toc-literales-de-cadena"><span class="toc-section-number">7.1</span> Literales de cadena</a></li>
<li><a href="#variables-de-cadena" id="toc-variables-de-cadena"><span class="toc-section-number">7.2</span> Variables de cadena</a></li>
<li><a href="#variables-de-cadena-como-matrices" id="toc-variables-de-cadena-como-matrices"><span class="toc-section-number">7.3</span> Variables de cadena como matrices</a></li>
<li><a href="#inicializadores-de-cadenas" id="toc-inicializadores-de-cadenas"><span class="toc-section-number">7.4</span> Inicializadores de cadenas</a></li>
<li><a href="#obtención-de-la-longitud-de-la-cadena" id="toc-obtención-de-la-longitud-de-la-cadena"><span class="toc-section-number">7.5</span> Obtención de la longitud de la cadena</a></li>
<li><a href="#terminación-de-la-cadena" id="toc-terminación-de-la-cadena"><span class="toc-section-number">7.6</span> Terminación de la cadena</a></li>
<li><a href="#copiar-una-cadena" id="toc-copiar-una-cadena"><span class="toc-section-number">7.7</span> Copiar una cadena</a></li>
</ul></li>
<li><a href="#structs" id="toc-structs"><span class="toc-section-number">8</span> Estructuras (Structs)</a>
<ul>
<li><a href="#declaración-de-una-estructura" id="toc-declaración-de-una-estructura"><span class="toc-section-number">8.1</span> Declaración de una estructura</a></li>
<li><a href="#struct-initializers" id="toc-struct-initializers"><span class="toc-section-number">8.2</span> Inicializadores de estructuras</a></li>
<li><a href="#paso-de-estructuras-a-funciones" id="toc-paso-de-estructuras-a-funciones"><span class="toc-section-number">8.3</span> Paso de estructuras a funciones</a></li>
<li><a href="#el-operador-arrow-flecha--" id="toc-el-operador-arrow-flecha--"><span class="toc-section-number">8.4</span> El operador Arrow / flecha (-&gt;)</a></li>
<li><a href="#copiar-y-devolver-structs" id="toc-copiar-y-devolver-structs"><span class="toc-section-number">8.5</span> Copiar y devolver <code>struct</code>s</a></li>
<li><a href="#comparación-de-structs" id="toc-comparación-de-structs"><span class="toc-section-number">8.6</span> Comparación de <code>struct</code>s</a></li>
</ul></li>
<li><a href="#archivo-de-entradasalida-inputoutput" id="toc-archivo-de-entradasalida-inputoutput"><span class="toc-section-number">9</span> Archivo de Entrada/Salida (Input/Output)</a>
<ul>
<li><a href="#el-tipo-de-dato-file." id="toc-el-tipo-de-dato-file."><span class="toc-section-number">9.1</span> El tipo de dato <code>FILE*</code>.</a></li>
<li><a href="#lectura-de-archivos-de-texto" id="toc-lectura-de-archivos-de-texto"><span class="toc-section-number">9.2</span> Lectura de archivos de texto</a></li>
<li><a href="#fin-de-fichero-eof" id="toc-fin-de-fichero-eof"><span class="toc-section-number">9.3</span> Fin de fichero: <code>EOF</code></a>
<ul>
<li><a href="#leer-línea-a-línea" id="toc-leer-línea-a-línea"><span class="toc-section-number">9.3.1</span> Leer línea a línea</a></li>
</ul></li>
<li><a href="#entrada-con-formato" id="toc-entrada-con-formato"><span class="toc-section-number">9.4</span> Entrada con formato</a></li>
<li><a href="#escribir-archivos-de-texto" id="toc-escribir-archivos-de-texto"><span class="toc-section-number">9.5</span> Escribir archivos de texto</a></li>
<li><a href="#es-de-archivos-binarios" id="toc-es-de-archivos-binarios"><span class="toc-section-number">9.6</span> E/S de archivos binarios</a>
<ul>
<li><a href="#struct-y-advertencias-sobre-números" id="toc-struct-y-advertencias-sobre-números"><span class="toc-section-number">9.6.1</span> <code>struct</code> y advertencias sobre números</a></li>
</ul></li>
</ul></li>
<li><a href="#typedef-creación-de-nuevos-tipos" id="toc-typedef-creación-de-nuevos-tipos"><span class="toc-section-number">10</span> <code>typedef</code>: Creación de nuevos tipos</a>
<ul>
<li><a href="#typedef-en-teoría" id="toc-typedef-en-teoría"><span class="toc-section-number">10.1</span> <code>typedef</code> en Teoría</a>
<ul>
<li><a href="#alcance" id="toc-alcance"><span class="toc-section-number">10.1.1</span> Alcance</a></li>
</ul></li>
<li><a href="#typedef-en-la-práctica" id="toc-typedef-en-la-práctica"><span class="toc-section-number">10.2</span> <code>typedef</code> en la práctica</a>
<ul>
<li><a href="#typedef-struct" id="toc-typedef-struct"><span class="toc-section-number">10.2.1</span> <code>typedef</code> y <code>struct</code>s</a></li>
<li><a href="#typedef-y-otros-tipos" id="toc-typedef-y-otros-tipos"><span class="toc-section-number">10.2.2</span> <code>typedef</code> y otros tipos</a></li>
<li><a href="#typedef-y-punteros" id="toc-typedef-y-punteros"><span class="toc-section-number">10.2.3</span> <code>typedef</code> y punteros</a></li>
<li><a href="#typedef-y-mayúsculas" id="toc-typedef-y-mayúsculas"><span class="toc-section-number">10.2.4</span> <code>typedef</code> y mayúsculas</a></li>
</ul></li>
<li><a href="#arrays-y-typedef" id="toc-arrays-y-typedef"><span class="toc-section-number">10.3</span> Arrays y <code>typedef</code></a></li>
</ul></li>
<li><a href="#pointers2" id="toc-pointers2"><span class="toc-section-number">11</span> Punteros II: Aritmética</a>
<ul>
<li><a href="#aritmética-de-punteros" id="toc-aritmética-de-punteros"><span class="toc-section-number">11.1</span> Aritmética de punteros</a>
<ul>
<li><a href="#incrementando-punteros" id="toc-incrementando-punteros"><span class="toc-section-number">11.1.1</span> Incrementando punteros</a></li>
<li><a href="#cambio-de-punteros" id="toc-cambio-de-punteros"><span class="toc-section-number">11.1.2</span> Cambio de punteros</a></li>
<li><a href="#restar-punteros" id="toc-restar-punteros"><span class="toc-section-number">11.1.3</span> Restar punteros</a></li>
</ul></li>
<li><a href="#arraypointerequiv" id="toc-arraypointerequiv"><span class="toc-section-number">11.2</span> Equivalencia entre matrices e identificadores</a>
<ul>
<li><a href="#equivalencia-entre-arrays-e-identificadores-en-las-llamadas-a-funciones" id="toc-equivalencia-entre-arrays-e-identificadores-en-las-llamadas-a-funciones"><span class="toc-section-number">11.2.1</span> Equivalencia entre arrays e identificadores en las llamadas a funciones</a></li>
</ul></li>
<li><a href="#punteros-void" id="toc-punteros-void"><span class="toc-section-number">11.3</span> Punteros <code>void</code></a></li>
</ul></li>
<li><a href="#asignación-manual-de-memoria" id="toc-asignación-manual-de-memoria"><span class="toc-section-number">12</span> Asignación manual de memoria</a>
<ul>
<li><a href="#asignación-y-desasignación-malloc-y-free." id="toc-asignación-y-desasignación-malloc-y-free."><span class="toc-section-number">12.1</span> Asignación y desasignación, <code>malloc()</code> y <code>free()</code>.</a></li>
<li><a href="#comprobación-de-errores" id="toc-comprobación-de-errores"><span class="toc-section-number">12.2</span> Comprobación de errores</a></li>
<li><a href="#asignación-de-espacio-para-una-matriz" id="toc-asignación-de-espacio-para-una-matriz"><span class="toc-section-number">12.3</span> Asignación de espacio para una matriz</a></li>
<li><a href="#una-alternativa-calloc." id="toc-una-alternativa-calloc."><span class="toc-section-number">12.4</span> Una alternativa: <code>calloc()</code>.</a></li>
<li><a href="#cambio-del-tamaño-asignado-con-realloc." id="toc-cambio-del-tamaño-asignado-con-realloc."><span class="toc-section-number">12.5</span> Cambio del tamaño asignado con <code>realloc()</code>.</a>
<ul>
<li><a href="#lectura-de-líneas-de-longitud-arbitraria" id="toc-lectura-de-líneas-de-longitud-arbitraria"><span class="toc-section-number">12.5.1</span> Lectura de líneas de longitud arbitraria</a></li>
<li><a href="#realloc-con-null." id="toc-realloc-con-null."><span class="toc-section-number">12.5.2</span> <code>realloc()</code> con <code>NULL</code>.</a></li>
</ul></li>
<li><a href="#asignaciones-alineadas" id="toc-asignaciones-alineadas"><span class="toc-section-number">12.6</span> Asignaciones alineadas</a></li>
</ul></li>
<li><a href="#scope" id="toc-scope"><span class="toc-section-number">13</span> Alcance</a>
<ul>
<li><a href="#alcance-del-bloque" id="toc-alcance-del-bloque"><span class="toc-section-number">13.1</span> Alcance del bloque</a>
<ul>
<li><a href="#dónde-definir-las-variables" id="toc-dónde-definir-las-variables"><span class="toc-section-number">13.1.1</span> Dónde definir las variables</a></li>
<li><a href="#ocultación-de-variables" id="toc-ocultación-de-variables"><span class="toc-section-number">13.1.2</span> Ocultación de variables</a></li>
</ul></li>
<li><a href="#alcance-de-fichero-archivo" id="toc-alcance-de-fichero-archivo"><span class="toc-section-number">13.2</span> Alcance de fichero / Archivo</a></li>
<li><a href="#ambito-del-bucle-for" id="toc-ambito-del-bucle-for"><span class="toc-section-number">13.3</span> Ambito del bucle <code>for</code></a></li>
<li><a href="#nota-sobre-el-alcance-de-las-funciones" id="toc-nota-sobre-el-alcance-de-las-funciones"><span class="toc-section-number">13.4</span> Nota sobre el alcance de las funciones</a></li>
</ul></li>
<li><a href="#tipos-ii-muchos-más-tipos" id="toc-tipos-ii-muchos-más-tipos"><span class="toc-section-number">14</span> Tipos II: ¡Muchos más tipos!</a>
<ul>
<li><a href="#enteros-con-y-sin-signo" id="toc-enteros-con-y-sin-signo"><span class="toc-section-number">14.1</span> Enteros con y sin signo</a></li>
<li><a href="#tipos-de-caracteres" id="toc-tipos-de-caracteres"><span class="toc-section-number">14.2</span> Tipos de caracteres</a></li>
<li><a href="#más-tipos-de-enteros-short-long-long-long" id="toc-más-tipos-de-enteros-short-long-long-long"><span class="toc-section-number">14.3</span> Más tipos de enteros: <code>short</code>, <code>long</code>, <code>long long</code></a></li>
<li><a href="#más-float-double-y-long-double." id="toc-más-float-double-y-long-double."><span class="toc-section-number">14.4</span> Más Float: <code>double</code> y <code>long double</code>.</a>
<ul>
<li><a href="#cuántas-cifras-decimales" id="toc-cuántas-cifras-decimales"><span class="toc-section-number">14.4.1</span> ¿Cuántas cifras decimales?</a></li>
<li><a href="#conversión-a-decimal-y-viceversa" id="toc-conversión-a-decimal-y-viceversa"><span class="toc-section-number">14.4.2</span> Conversión a decimal y viceversa</a></li>
</ul></li>
<li><a href="#tipos-numéricos-constantes" id="toc-tipos-numéricos-constantes"><span class="toc-section-number">14.5</span> Tipos numéricos constantes</a>
<ul>
<li><a href="#hexadecimal-y-octal" id="toc-hexadecimal-y-octal"><span class="toc-section-number">14.5.1</span> Hexadecimal y octal</a></li>
<li><a href="#constantes-enteras" id="toc-constantes-enteras"><span class="toc-section-number">14.5.2</span> Constantes enteras</a></li>
<li><a href="#constantes-en-coma-flotante" id="toc-constantes-en-coma-flotante"><span class="toc-section-number">14.5.3</span> Constantes en coma flotante</a></li>
</ul></li>
</ul></li>
<li><a href="#tipos-iii-conversiones" id="toc-tipos-iii-conversiones"><span class="toc-section-number">15</span> Tipos III: Conversiones</a>
<ul>
<li><a href="#conversiones-de-cadenas" id="toc-conversiones-de-cadenas"><span class="toc-section-number">15.1</span> Conversiones de cadenas</a>
<ul>
<li><a href="#valor-numérico-a-cadena" id="toc-valor-numérico-a-cadena"><span class="toc-section-number">15.1.1</span> Valor numérico a cadena</a></li>
<li><a href="#cadena-a-valor-numérico" id="toc-cadena-a-valor-numérico"><span class="toc-section-number">15.1.2</span> Cadena a valor numérico</a></li>
</ul></li>
<li><a href="#conversiones-char" id="toc-conversiones-char"><span class="toc-section-number">15.2</span> Conversiones <code>char</code></a></li>
<li><a href="#conversiones-numéricas" id="toc-conversiones-numéricas"><span class="toc-section-number">15.3</span> Conversiones numéricas</a>
<ul>
<li><a href="#booleano" id="toc-booleano"><span class="toc-section-number">15.3.1</span> Booleano</a></li>
<li><a href="#conversión-de-números-enteros-en-números-enteros" id="toc-conversión-de-números-enteros-en-números-enteros"><span class="toc-section-number">15.3.2</span> Conversión de números enteros en números enteros</a></li>
<li><a href="#conversiones-de-enteros-y-coma-flotante" id="toc-conversiones-de-enteros-y-coma-flotante"><span class="toc-section-number">15.3.3</span> Conversiones de enteros y coma flotante</a></li>
</ul></li>
<li><a href="#conversiones-implícitas" id="toc-conversiones-implícitas"><span class="toc-section-number">15.4</span> Conversiones implícitas</a>
<ul>
<li><a href="#integer-promotions" id="toc-integer-promotions"><span class="toc-section-number">15.4.1</span> Promociones de enteros</a></li>
<li><a href="#usual-arithmetic-conversions" id="toc-usual-arithmetic-conversions"><span class="toc-section-number">15.4.2</span> Las conversiones aritméticas habituales</a></li>
<li><a href="#void" id="toc-void"><span class="toc-section-number">15.4.3</span> <code>void*</code></a></li>
</ul></li>
<li><a href="#conversiones-explícitas" id="toc-conversiones-explícitas"><span class="toc-section-number">15.5</span> Conversiones explícitas</a>
<ul>
<li><a href="#casting" id="toc-casting"><span class="toc-section-number">15.5.1</span> Casting</a></li>
</ul></li>
</ul></li>
<li><a href="#tipos-iv-calificadores-y-especificadores" id="toc-tipos-iv-calificadores-y-especificadores"><span class="toc-section-number">16</span> Tipos IV: Calificadores y especificadores</a>
<ul>
<li><a href="#calificadores-de-tipo" id="toc-calificadores-de-tipo"><span class="toc-section-number">16.1</span> Calificadores de tipo</a>
<ul>
<li><a href="#const" id="toc-const"><span class="toc-section-number">16.1.1</span> <code>const</code></a></li>
<li><a href="#restrict" id="toc-restrict"><span class="toc-section-number">16.1.2</span> <code>restrict</code></a></li>
<li><a href="#volatile" id="toc-volatile"><span class="toc-section-number">16.1.3</span> <code>volatile</code></a></li>
<li><a href="#atomic" id="toc-atomic"><span class="toc-section-number">16.1.4</span> <code>_Atomic</code></a></li>
</ul></li>
<li><a href="#especificadores-de-clase-de-almacenamiento" id="toc-especificadores-de-clase-de-almacenamiento"><span class="toc-section-number">16.2</span> Especificadores de clase de almacenamiento</a>
<ul>
<li><a href="#auto" id="toc-auto"><span class="toc-section-number">16.2.1</span> <code>auto</code></a></li>
<li><a href="#static" id="toc-static"><span class="toc-section-number">16.2.2</span> <code>static</code></a></li>
<li><a href="#extern" id="toc-extern"><span class="toc-section-number">16.2.3</span> <code>extern</code></a></li>
<li><a href="#register" id="toc-register"><span class="toc-section-number">16.2.4</span> <code>register</code></a></li>
<li><a href="#thread_local" id="toc-thread_local"><span class="toc-section-number">16.2.5</span> <code>_Thread_local</code></a></li>
</ul></li>
</ul></li>
<li><a href="#proyectos-multiarchivos" id="toc-proyectos-multiarchivos"><span class="toc-section-number">17</span> Proyectos multiarchivos</a>
<ul>
<li><a href="#includes-func-protos" id="toc-includes-func-protos"><span class="toc-section-number">17.1</span> Incluye prototipos y funciones</a></li>
<li><a href="#tratamiento-de-la-repetición-include" id="toc-tratamiento-de-la-repetición-include"><span class="toc-section-number">17.2</span> Tratamiento de la repetición <code>#include</code></a></li>
<li><a href="#static-y-extern" id="toc-static-y-extern"><span class="toc-section-number">17.3</span> <code>static</code> y <code>extern</code></a></li>
<li><a href="#compilación-con-archivos-de-objetos" id="toc-compilación-con-archivos-de-objetos"><span class="toc-section-number">17.4</span> Compilación con archivos de objetos</a></li>
</ul></li>
<li><a href="#entorno-exterior" id="toc-entorno-exterior"><span class="toc-section-number">18</span> Entorno exterior</a>
<ul>
<li><a href="#argumentos-de-la-línea-de-comandos" id="toc-argumentos-de-la-línea-de-comandos"><span class="toc-section-number">18.1</span> Argumentos de la línea de comandos</a>
<ul>
<li><a href="#el-último-argv-es-null." id="toc-el-último-argv-es-null."><span class="toc-section-number">18.1.1</span> El último <code>argv</code> es <code>NULL</code>.</a></li>
<li><a href="#el-suplente-char-argv" id="toc-el-suplente-char-argv"><span class="toc-section-number">18.1.2</span> El suplente: <code>char **argv</code></a></li>
<li><a href="#datos-curiosos" id="toc-datos-curiosos"><span class="toc-section-number">18.1.3</span> Datos curiosos</a></li>
</ul></li>
<li><a href="#exit-status" id="toc-exit-status"><span class="toc-section-number">18.2</span> Estado de salida</a>
<ul>
<li><a href="#otros-valores-de-estado-de-salida" id="toc-otros-valores-de-estado-de-salida"><span class="toc-section-number">18.2.1</span> Otros valores de estado de salida</a></li>
</ul></li>
<li><a href="#env-var" id="toc-env-var"><span class="toc-section-number">18.3</span> Variables de entorno</a>
<ul>
<li><a href="#configuración-de-variables-de-entorno" id="toc-configuración-de-variables-de-entorno"><span class="toc-section-number">18.3.1</span> Configuración de variables de entorno</a></li>
<li><a href="#variables-de-entorno-alternativas-a-unix" id="toc-variables-de-entorno-alternativas-a-unix"><span class="toc-section-number">18.3.2</span> Variables de entorno alternativas a Unix</a></li>
</ul></li>
</ul></li>
<li><a href="#el-preprocesador-c" id="toc-el-preprocesador-c"><span class="toc-section-number">19</span> El preprocesador C</a>
<ul>
<li><a href="#include" id="toc-include"><span class="toc-section-number">19.1</span> <code>#include</code></a></li>
<li><a href="#macros-sencillas" id="toc-macros-sencillas"><span class="toc-section-number">19.2</span> Macros sencillas</a></li>
<li><a href="#compilación-condicional" id="toc-compilación-condicional"><span class="toc-section-number">19.3</span> Compilación condicional</a>
<ul>
<li><a href="#si-está-definido-ifdef-y-endif." id="toc-si-está-definido-ifdef-y-endif."><span class="toc-section-number">19.3.1</span> Si está definido, <code>#ifdef</code> y <code>#endif</code>.</a></li>
<li><a href="#si-no-está-definido-ifndef." id="toc-si-no-está-definido-ifndef."><span class="toc-section-number">19.3.2</span> Si no está definido, <code>#ifndef</code>.</a></li>
<li><a href="#else" id="toc-else"><span class="toc-section-number">19.3.3</span> <code>#else</code></a></li>
<li><a href="#else-if-elifdef-elifndef" id="toc-else-if-elifdef-elifndef"><span class="toc-section-number">19.3.4</span> Else-If: <code>#elifdef</code>, <code>#elifndef</code></a></li>
<li><a href="#condicional-general-if-elif" id="toc-condicional-general-if-elif"><span class="toc-section-number">19.3.5</span> Condicional general: <code>#if</code>, <code>#elif</code></a></li>
<li><a href="#perder-una-macro-undef" id="toc-perder-una-macro-undef"><span class="toc-section-number">19.3.6</span> Perder una macro: <code>#undef</code></a></li>
</ul></li>
<li><a href="#macros-integradas" id="toc-macros-integradas"><span class="toc-section-number">19.4</span> Macros integradas</a>
<ul>
<li><a href="#macros-obligatorias" id="toc-macros-obligatorias"><span class="toc-section-number">19.4.1</span> Macros obligatorias</a></li>
<li><a href="#macros-opcionales" id="toc-macros-opcionales"><span class="toc-section-number">19.4.2</span> Macros opcionales</a></li>
</ul></li>
<li><a href="#macros-con-argumentos" id="toc-macros-con-argumentos"><span class="toc-section-number">19.5</span> Macros con argumentos</a>
<ul>
<li><a href="#macros-con-un-argumento" id="toc-macros-con-un-argumento"><span class="toc-section-number">19.5.1</span> Macros con un argumento</a></li>
<li><a href="#macros-con-más-de-un-argumento" id="toc-macros-con-más-de-un-argumento"><span class="toc-section-number">19.5.2</span> Macros con más de un argumento</a></li>
<li><a href="#macros-con-argumentos-variables" id="toc-macros-con-argumentos-variables"><span class="toc-section-number">19.5.3</span> Macros con argumentos variables</a></li>
<li><a href="#stringificación" id="toc-stringificación"><span class="toc-section-number">19.5.4</span> Stringificación</a></li>
<li><a href="#concatenación" id="toc-concatenación"><span class="toc-section-number">19.5.5</span> Concatenación</a></li>
</ul></li>
<li><a href="#macros-multilínea" id="toc-macros-multilínea"><span class="toc-section-number">19.6</span> Macros multilínea</a></li>
<li><a href="#my-assert" id="toc-my-assert"><span class="toc-section-number">19.7</span> Ejemplo: Una macro Assert</a></li>
<li><a href="#directiva-error" id="toc-directiva-error"><span class="toc-section-number">19.8</span> Directiva <code>#error</code></a></li>
<li><a href="#directiva-embed" id="toc-directiva-embed"><span class="toc-section-number">19.9</span> Directiva <code>#embed</code></a>
<ul>
<li><a href="#parámetro-embed" id="toc-parámetro-embed"><span class="toc-section-number">19.9.1</span> Parámetro <code>#embed</code></a></li>
<li><a href="#parámetro-limit" id="toc-parámetro-limit"><span class="toc-section-number">19.9.2</span> Parámetro <code>limit()</code></a></li>
<li><a href="#parámetro-if_empty" id="toc-parámetro-if_empty"><span class="toc-section-number">19.9.3</span> Parámetro <code>if_empty</code></a></li>
<li><a href="#parámetros-prefix-y-suffix." id="toc-parámetros-prefix-y-suffix."><span class="toc-section-number">19.9.4</span> Parámetros <code>prefix()</code> y <code>suffix()</code>.</a></li>
<li><a href="#el-identificador-__has_embed." id="toc-el-identificador-__has_embed."><span class="toc-section-number">19.9.5</span> El identificador <code>__has_embed()</code>.</a></li>
<li><a href="#otros-parámetros" id="toc-otros-parámetros"><span class="toc-section-number">19.9.6</span> Otros parámetros</a></li>
<li><a href="#incrustación-de-valores-multibyte" id="toc-incrustación-de-valores-multibyte"><span class="toc-section-number">19.9.7</span> Incrustación de valores multibyte</a></li>
</ul></li>
<li><a href="#la-directiva-pragma" id="toc-la-directiva-pragma"><span class="toc-section-number">19.10</span> La directiva <code id="pragma">#pragma</code></a>
<ul>
<li><a href="#pragmas-no-estándar" id="toc-pragmas-no-estándar"><span class="toc-section-number">19.10.1</span> Pragmas no estándar</a></li>
<li><a href="#pragmas-estándar" id="toc-pragmas-estándar"><span class="toc-section-number">19.10.2</span> Pragmas estándar</a></li>
<li><a href="#operador-_pragma" id="toc-operador-_pragma"><span class="toc-section-number">19.10.3</span> Operador <code>_Pragma</code></a></li>
</ul></li>
<li><a href="#la-directiva-line" id="toc-la-directiva-line"><span class="toc-section-number">19.11</span> La directiva <code>#line</code></a></li>
<li><a href="#la-directiva-nula" id="toc-la-directiva-nula"><span class="toc-section-number">19.12</span> La Directiva Nula (<code>#</code>)</a></li>
</ul></li>
<li><a href="#structs-ii-más-diversión-con-structs" id="toc-structs-ii-más-diversión-con-structs"><span class="toc-section-number">20</span> <code>struct</code>s II: Más diversión con <code>struct</code>s</a>
<ul>
<li><a href="#inicializadores-de-structs-anidadas-y-matrices" id="toc-inicializadores-de-structs-anidadas-y-matrices"><span class="toc-section-number">20.1</span> Inicializadores de <code>struct</code>s anidadas y matrices</a></li>
<li><a href="#structs-anonimas" id="toc-structs-anonimas"><span class="toc-section-number">20.2</span> <code>struct</code>s anonimas</a></li>
<li><a href="#structs-estructuras-autorreferenciales" id="toc-structs-estructuras-autorreferenciales"><span class="toc-section-number">20.3</span> <code>struct</code>s (Estructuras autorreferenciales)</a></li>
<li><a href="#miembros-flexibles-de-la-matriz" id="toc-miembros-flexibles-de-la-matriz"><span class="toc-section-number">20.4</span> Miembros flexibles de la matriz</a></li>
<li><a href="#struct-padding-bytes" id="toc-struct-padding-bytes"><span class="toc-section-number">20.5</span> Bytes de relleno</a></li>
<li><a href="#offsetof" id="toc-offsetof"><span class="toc-section-number">20.6</span> <code>offsetof</code></a></li>
<li><a href="#fake-oop" id="toc-fake-oop"><span class="toc-section-number">20.7</span> Falsa OOP</a></li>
<li><a href="#campos-de-bits" id="toc-campos-de-bits"><span class="toc-section-number">20.8</span> Campos de bits</a>
<ul>
<li><a href="#campos-de-bits-no-adyacentes" id="toc-campos-de-bits-no-adyacentes"><span class="toc-section-number">20.8.1</span> Campos de bits no adyacentes</a></li>
<li><a href="#ints-con-signo-o-sin-signo" id="toc-ints-con-signo-o-sin-signo"><span class="toc-section-number">20.8.2</span> <code>int</code>s con signo o sin signo</a></li>
<li><a href="#campos-de-bits-sin-nombre" id="toc-campos-de-bits-sin-nombre"><span class="toc-section-number">20.8.3</span> Campos de bits sin nombre</a></li>
<li><a href="#campos-de-bits-sin-nombre-de-ancho-cero" id="toc-campos-de-bits-sin-nombre-de-ancho-cero"><span class="toc-section-number">20.8.4</span> Campos de bits sin nombre de ancho cero</a></li>
</ul></li>
<li><a href="#uniones-unions" id="toc-uniones-unions"><span class="toc-section-number">20.9</span> Uniones (Unions)</a>
<ul>
<li><a href="#union-type-punning" id="toc-union-type-punning"><span class="toc-section-number">20.9.1</span> Unions y Tipo Punning</a></li>
<li><a href="#punteros-a-unions" id="toc-punteros-a-unions"><span class="toc-section-number">20.9.2</span> Punteros a <code>union</code>s</a></li>
<li><a href="#secuencias-iniciales-comunes-en-las-uniones" id="toc-secuencias-iniciales-comunes-en-las-uniones"><span class="toc-section-number">20.9.3</span> Secuencias iniciales comunes en las uniones</a></li>
</ul></li>
<li><a href="#uniones-y-estructuras-sin-nombre" id="toc-uniones-y-estructuras-sin-nombre"><span class="toc-section-number">20.10</span> Uniones y estructuras sin nombre</a></li>
<li><a href="#pasar-y-devolver-structs-y-unions" id="toc-pasar-y-devolver-structs-y-unions"><span class="toc-section-number">20.11</span> Pasar y devolver <code>struct</code>s y <code>union</code>s</a></li>
</ul></li>
<li><a href="#caracteres-y-strings-ii" id="toc-caracteres-y-strings-ii"><span class="toc-section-number">21</span> Caracteres y Strings II</a>
<ul>
<li><a href="#secuencias-de-escape" id="toc-secuencias-de-escape"><span class="toc-section-number">21.1</span> Secuencias de escape</a>
<ul>
<li><a href="#escapes-de-uso-frecuente" id="toc-escapes-de-uso-frecuente"><span class="toc-section-number">21.1.1</span> Escapes de uso frecuente</a></li>
<li><a href="#escapes-poco-utilizados" id="toc-escapes-poco-utilizados"><span class="toc-section-number">21.1.2</span> Escapes poco utilizados</a></li>
<li><a href="#escapes-numéricos" id="toc-escapes-numéricos"><span class="toc-section-number">21.1.3</span> Escapes numéricos</a></li>
</ul></li>
</ul></li>
<li><a href="#tipos-enumerados-enum" id="toc-tipos-enumerados-enum"><span class="toc-section-number">22</span> Tipos Enumerados: <code>enum</code></a>
<ul>
<li><a href="#comportamiento-de-enum" id="toc-comportamiento-de-enum"><span class="toc-section-number">22.1</span> Comportamiento de <code>enum</code></a>
<ul>
<li><a href="#numeración" id="toc-numeración"><span class="toc-section-number">22.1.1</span> Numeración</a></li>
<li><a href="#comas-finales" id="toc-comas-finales"><span class="toc-section-number">22.1.2</span> Comas finales</a></li>
<li><a href="#alcance-1" id="toc-alcance-1"><span class="toc-section-number">22.1.3</span> Alcance</a></li>
<li><a href="#estilo" id="toc-estilo"><span class="toc-section-number">22.1.4</span> Estilo</a></li>
</ul></li>
<li><a href="#su-enum-es-un-tipo" id="toc-su-enum-es-un-tipo"><span class="toc-section-number">22.2</span> Su <code>enum</code> es un Tipo</a></li>
</ul></li>
<li><a href="#punteros-iii-punteros-a-punteros-y-más" id="toc-punteros-iii-punteros-a-punteros-y-más"><span class="toc-section-number">23</span> Punteros III: Punteros a punteros y más</a>
<ul>
<li><a href="#punteros-a-punteros" id="toc-punteros-a-punteros"><span class="toc-section-number">23.1</span> Punteros a punteros</a>
<ul>
<li><a href="#puntero-punteros-y-const." id="toc-puntero-punteros-y-const."><span class="toc-section-number">23.1.1</span> Puntero Punteros y <code>const</code>.</a></li>
</ul></li>
<li><a href="#multibyte-values" id="toc-multibyte-values"><span class="toc-section-number">23.2</span> Valores multibyte</a></li>
<li><a href="#el-puntero-null-y-el-cero" id="toc-el-puntero-null-y-el-cero"><span class="toc-section-number">23.3</span> El puntero <code>NULL</code> y el cero</a></li>
<li><a href="#punteros-como-enteros" id="toc-punteros-como-enteros"><span class="toc-section-number">23.4</span> Punteros como enteros</a></li>
<li><a href="#asignación-de-punteros-a-otros-punteros" id="toc-asignación-de-punteros-a-otros-punteros"><span class="toc-section-number">23.5</span> Asignación de punteros a otros punteros</a></li>
<li><a href="#ptr_differences" id="toc-ptr_differences"><span class="toc-section-number">23.6</span> Diferencias entre punteros</a></li>
<li><a href="#punteros-a-funciones" id="toc-punteros-a-funciones"><span class="toc-section-number">23.7</span> Punteros a funciones</a></li>
</ul></li>
<li><a href="#operaciones-bit-a-bit" id="toc-operaciones-bit-a-bit"><span class="toc-section-number">24</span> Operaciones bit a bit</a>
<ul>
<li><a href="#and-or-xor-y-not-por-bits" id="toc-and-or-xor-y-not-por-bits"><span class="toc-section-number">24.1</span> AND, OR, XOR y NOT por bits</a></li>
<li><a href="#desplazamiento-bitwise" id="toc-desplazamiento-bitwise"><span class="toc-section-number">24.2</span> Desplazamiento (Bitwise)</a></li>
</ul></li>
<li><a href="#funciones-variádicas" id="toc-funciones-variádicas"><span class="toc-section-number">25</span> Funciones variádicas</a>
<ul>
<li><a href="#elipses-en-firmas-de-funciones" id="toc-elipses-en-firmas-de-funciones"><span class="toc-section-number">25.1</span> Elipses en firmas de funciones</a></li>
<li><a href="#obtener-los-argumentos-adicionales" id="toc-obtener-los-argumentos-adicionales"><span class="toc-section-number">25.2</span> Obtener los argumentos adicionales</a></li>
<li><a href="#funcionalidad-de-va_list" id="toc-funcionalidad-de-va_list"><span class="toc-section-number">25.3</span> Funcionalidad de <code>va_list</code></a></li>
<li><a href="#funciones-de-biblioteca-que-utilizan-va_lists" id="toc-funciones-de-biblioteca-que-utilizan-va_lists"><span class="toc-section-number">25.4</span> Funciones de biblioteca que utilizan <code>va_list</code>s</a></li>
</ul></li>
<li><a href="#configuración-regional-e-internacionalización" id="toc-configuración-regional-e-internacionalización"><span class="toc-section-number">26</span> Configuración regional e internacionalización</a>
<ul>
<li><a href="#configuración-rápida-de-la-localización" id="toc-configuración-rápida-de-la-localización"><span class="toc-section-number">26.1</span> Configuración rápida de la localización</a></li>
<li><a href="#obtener-la-configuración-regional-monetaria" id="toc-obtener-la-configuración-regional-monetaria"><span class="toc-section-number">26.2</span> Obtener la configuración regional monetaria</a>
<ul>
<li><a href="#monetary-digit-grouping" id="toc-monetary-digit-grouping"><span class="toc-section-number">26.2.1</span> Agrupación de dígitos monetarios</a></li>
<li><a href="#separadores-y-posición-del-cartel" id="toc-separadores-y-posición-del-cartel"><span class="toc-section-number">26.2.2</span> Separadores y posición del cartel</a></li>
<li><a href="#ejemplos-de-valores" id="toc-ejemplos-de-valores"><span class="toc-section-number">26.2.3</span> Ejemplos de valores</a></li>
</ul></li>
<li><a href="#especificidades-de-localización" id="toc-especificidades-de-localización"><span class="toc-section-number">26.3</span> Especificidades de localización</a></li>
</ul></li>
<li><a href="#unicode-caracteres-anchos-y-todo-eso" id="toc-unicode-caracteres-anchos-y-todo-eso"><span class="toc-section-number">27</span> Unicode, caracteres anchos y todo eso</a>
<ul>
<li><a href="#qué-es-unicode" id="toc-qué-es-unicode"><span class="toc-section-number">27.1</span> ¿Qué es Unicode?</a></li>
<li><a href="#puntos-de-código" id="toc-puntos-de-código"><span class="toc-section-number">27.2</span> Puntos de código</a></li>
<li><a href="#codificación" id="toc-codificación"><span class="toc-section-number">27.3</span> Codificación</a></li>
<li><a href="#src-exec-charset" id="toc-src-exec-charset"><span class="toc-section-number">27.4</span> Juegos de caracteres de origen y ejecución</a></li>
<li><a href="#unicode-in-c" id="toc-unicode-in-c"><span class="toc-section-number">27.5</span> Unicode en C</a></li>
<li><a href="#utf8-quick" id="toc-utf8-quick"><span class="toc-section-number">27.6</span> Una nota rápida sobre UTF-8 antes de adentrarnos en la maleza</a></li>
<li><a href="#diferentes-tipos-de-personajes" id="toc-diferentes-tipos-de-personajes"><span class="toc-section-number">27.7</span> Diferentes tipos de personajes</a>
<ul>
<li><a href="#caracteres-multibyte" id="toc-caracteres-multibyte"><span class="toc-section-number">27.7.1</span> Caracteres multibyte</a></li>
<li><a href="#wide-characters" id="toc-wide-characters"><span class="toc-section-number">27.7.2</span> Caracteres anchos</a></li>
</ul></li>
<li><a href="#uso-de-caracteres-anchos-y-wchar_t" id="toc-uso-de-caracteres-anchos-y-wchar_t"><span class="toc-section-number">27.8</span> Uso de caracteres anchos y <code>wchar_t</code></a>
<ul>
<li><a href="#conversiones-de-multibyte-a-wchar_t" id="toc-conversiones-de-multibyte-a-wchar_t"><span class="toc-section-number">27.8.1</span> Conversiones de Multibyte a <code>wchar_t</code></a></li>
</ul></li>
<li><a href="#funcionalidad-de-los-caracteres-anchos" id="toc-funcionalidad-de-los-caracteres-anchos"><span class="toc-section-number">27.9</span> Funcionalidad de los caracteres anchos</a>
<ul>
<li><a href="#io-stream-orientation" id="toc-io-stream-orientation"><span class="toc-section-number">27.9.1</span> Orientación del flujo de E/S</a></li>
<li><a href="#funciones-de-es" id="toc-funciones-de-es"><span class="toc-section-number">27.9.2</span> Funciones de E/S</a></li>
<li><a href="#funciones-de-conversión-de-tipos" id="toc-funciones-de-conversión-de-tipos"><span class="toc-section-number">27.9.3</span> Funciones de conversión de tipos</a></li>
<li><a href="#funciones-de-copia-de-cadenas-y-memoria" id="toc-funciones-de-copia-de-cadenas-y-memoria"><span class="toc-section-number">27.9.4</span> Funciones de copia de cadenas y memoria</a></li>
<li><a href="#funciones-de-comparación-de-cadenas-y-memoria" id="toc-funciones-de-comparación-de-cadenas-y-memoria"><span class="toc-section-number">27.9.5</span> Funciones de comparación de cadenas y memoria</a></li>
<li><a href="#funciones-de-búsqueda-de-cadenas" id="toc-funciones-de-búsqueda-de-cadenas"><span class="toc-section-number">27.9.6</span> Funciones de búsqueda de cadenas</a></li>
<li><a href="#longitudfunciones-varias" id="toc-longitudfunciones-varias"><span class="toc-section-number">27.9.7</span> Longitud/Funciones varias</a></li>
<li><a href="#funciones-de-clasificación-de-caracteres" id="toc-funciones-de-clasificación-de-caracteres"><span class="toc-section-number">27.9.8</span> Funciones de clasificación de caracteres</a></li>
</ul></li>
<li><a href="#estado-de-análisis-funciones-reiniciables" id="toc-estado-de-análisis-funciones-reiniciables"><span class="toc-section-number">27.10</span> Estado de análisis, funciones reiniciables</a></li>
<li><a href="#codificaciones-unicode-y-c" id="toc-codificaciones-unicode-y-c"><span class="toc-section-number">27.11</span> Codificaciones Unicode y C</a>
<ul>
<li><a href="#utf-8" id="toc-utf-8"><span class="toc-section-number">27.11.1</span> UTF-8</a></li>
<li><a href="#utf-16-utf-32-char16_t-y-char32_t" id="toc-utf-16-utf-32-char16_t-y-char32_t"><span class="toc-section-number">27.11.2</span> UTF-16, UTF-32, <code>char16_t</code>, y <code>char32_t</code></a></li>
<li><a href="#conversiones-multibyte" id="toc-conversiones-multibyte"><span class="toc-section-number">27.11.3</span> Conversiones multibyte</a></li>
<li><a href="#utf-3rd-party" id="toc-utf-3rd-party"><span class="toc-section-number">27.11.4</span> Bibliotecas de terceros</a></li>
</ul></li>
</ul></li>
<li><a href="#salir-de-un-programa" id="toc-salir-de-un-programa"><span class="toc-section-number">28</span> Salir de un programa</a>
<ul>
<li><a href="#salidas-normales" id="toc-salidas-normales"><span class="toc-section-number">28.1</span> Salidas normales</a>
<ul>
<li><a href="#retorno-de-main" id="toc-retorno-de-main"><span class="toc-section-number">28.1.1</span> Retorno de <code>main()</code></a></li>
<li><a href="#exit" id="toc-exit"><span class="toc-section-number">28.1.2</span> <code>exit()</code></a></li>
<li><a href="#configuración-de-los-controladores-de-salida-con-atexit" id="toc-configuración-de-los-controladores-de-salida-con-atexit"><span class="toc-section-number">28.1.3</span> Configuración de los controladores de salida con <code>atexit()</code></a></li>
</ul></li>
<li><a href="#salidas-más-rápidas-con-quick_exit." id="toc-salidas-más-rápidas-con-quick_exit."><span class="toc-section-number">28.2</span> Salidas más rápidas con <code>quick_exit()</code>.</a></li>
<li><a href="#destrúyelo-desde-la-órbita-_exit" id="toc-destrúyelo-desde-la-órbita-_exit"><span class="toc-section-number">28.3</span> Destrúyelo desde la órbita: <code>_Exit()</code></a></li>
<li><a href="#saliendo-a-veces-assert" id="toc-saliendo-a-veces-assert"><span class="toc-section-number">28.4</span> Saliendo a veces: <code>assert()</code></a></li>
<li><a href="#salida-anormal-abort" id="toc-salida-anormal-abort"><span class="toc-section-number">28.5</span> Salida anormal: <code>abort()</code></a></li>
</ul></li>
<li><a href="#manejo-de-señales" id="toc-manejo-de-señales"><span class="toc-section-number">29</span> Manejo de señales</a>
<ul>
<li><a href="#qué-son-las-señales" id="toc-qué-son-las-señales"><span class="toc-section-number">29.1</span> ¿Qué son las señales?</a></li>
<li><a href="#manejo-de-señales-con-signal." id="toc-manejo-de-señales-con-signal."><span class="toc-section-number">29.2</span> Manejo de señales con <code>signal()</code>.</a></li>
<li><a href="#escribiendo-manejadores-de-señales" id="toc-escribiendo-manejadores-de-señales"><span class="toc-section-number">29.3</span> Escribiendo Manejadores de Señales</a></li>
<li><a href="#qué-podemos-hacer-realmente" id="toc-qué-podemos-hacer-realmente"><span class="toc-section-number">29.4</span> ¿Qué podemos hacer realmente?</a></li>
<li><a href="#los-amigos-no-dejan-a-los-amigos-señal" id="toc-los-amigos-no-dejan-a-los-amigos-señal"><span class="toc-section-number">29.5</span> Los amigos no dejan a los amigos <code>señal()</code></a></li>
</ul></li>
<li><a href="#matrices-de-longitud-variable-vla" id="toc-matrices-de-longitud-variable-vla"><span class="toc-section-number">30</span> Matrices de longitud variable (VLA)</a>
<ul>
<li><a href="#lo-básico" id="toc-lo-básico"><span class="toc-section-number">30.1</span> Lo Básico</a></li>
<li><a href="#sizeof-y-vlas" id="toc-sizeof-y-vlas"><span class="toc-section-number">30.2</span> <code>sizeof</code> y VLAs</a></li>
<li><a href="#vla-multidimensionales" id="toc-vla-multidimensionales"><span class="toc-section-number">30.3</span> VLA multidimensionales</a></li>
<li><a href="#pasar-vlas-unidimensionales-a-funciones" id="toc-pasar-vlas-unidimensionales-a-funciones"><span class="toc-section-number">30.4</span> Pasar VLAs unidimensionales a funciones</a></li>
<li><a href="#pasar-vlas-multidimensionales-a-funciones" id="toc-pasar-vlas-multidimensionales-a-funciones"><span class="toc-section-number">30.5</span> Pasar VLAs multidimensionales a funciones</a>
<ul>
<li><a href="#vla-multidimensionales-parciales" id="toc-vla-multidimensionales-parciales"><span class="toc-section-number">30.5.1</span> VLA multidimensionales parciales</a></li>
</ul></li>
<li><a href="#compatibilidad-con-matrices-regulares" id="toc-compatibilidad-con-matrices-regulares"><span class="toc-section-number">30.6</span> Compatibilidad con matrices regulares</a></li>
<li><a href="#typedef-y-vlas" id="toc-typedef-y-vlas"><span class="toc-section-number">30.7</span> <code>typedef</code> Y VLAs</a></li>
<li><a href="#salto-de-trampas" id="toc-salto-de-trampas"><span class="toc-section-number">30.8</span> Salto de Trampas</a></li>
<li><a href="#vla-general-issues" id="toc-vla-general-issues"><span class="toc-section-number">30.9</span> Cuestiones generales</a></li>
</ul></li>
<li><a href="#goto" id="toc-goto"><span class="toc-section-number">31</span> <code>goto</code></a>
<ul>
<li><a href="#un-ejemplo-sencillo" id="toc-un-ejemplo-sencillo"><span class="toc-section-number">31.1</span> Un ejemplo sencillo</a></li>
<li><a href="#etiqueta-continue" id="toc-etiqueta-continue"><span class="toc-section-number">31.2</span> Etiqueta <code>continue</code></a></li>
<li><a href="#libertad-bajo-fianza" id="toc-libertad-bajo-fianza"><span class="toc-section-number">31.3</span> Libertad bajo fianza</a></li>
<li><a href="#etiqueta-break" id="toc-etiqueta-break"><span class="toc-section-number">31.4</span> Etiqueta <code>break</code></a></li>
<li><a href="#limpieza-multinivel" id="toc-limpieza-multinivel"><span class="toc-section-number">31.5</span> Limpieza multinivel</a></li>
<li><a href="#optimización-de-las-llamadas-de-cola" id="toc-optimización-de-las-llamadas-de-cola"><span class="toc-section-number">31.6</span> Optimización de las llamadas de cola</a></li>
<li><a href="#reinicio-de-llamadas-al-sistema-interrumpidas" id="toc-reinicio-de-llamadas-al-sistema-interrumpidas"><span class="toc-section-number">31.7</span> Reinicio de llamadas al sistema interrumpidas</a></li>
<li><a href="#goto-y-el-hilo-conductor-preferente-thread-preemption" id="toc-goto-y-el-hilo-conductor-preferente-thread-preemption"><span class="toc-section-number">31.8</span> <code>goto</code> y el Hilo conductor preferente (Thread Preemption)</a></li>
<li><a href="#goto-y-el-ámbito-de-las-variables" id="toc-goto-y-el-ámbito-de-las-variables"><span class="toc-section-number">31.9</span> <code>goto</code> y el ámbito de las variables</a></li>
<li><a href="#goto-y-matrices-de-longitud-variable-variable-length-arrays" id="toc-goto-y-matrices-de-longitud-variable-variable-length-arrays"><span class="toc-section-number">31.10</span> <code>goto</code> y matrices de longitud variable (Variable-Length Arrays)</a></li>
</ul></li>
<li><a href="#tipos-parte-v-literales-compuestos-y-selecciones-genéricas" id="toc-tipos-parte-v-literales-compuestos-y-selecciones-genéricas"><span class="toc-section-number">32</span> Tipos Parte V: Literales compuestos y selecciones genéricas</a>
<ul>
<li><a href="#literales-compuestos" id="toc-literales-compuestos"><span class="toc-section-number">32.1</span> Literales compuestos</a>
<ul>
<li><a href="#pasando-objetos-sin-nombre-a-funciones" id="toc-pasando-objetos-sin-nombre-a-funciones"><span class="toc-section-number">32.1.1</span> Pasando Objetos sin Nombre a Funciones</a></li>
<li><a href="#structs-sin-nombre" id="toc-structs-sin-nombre"><span class="toc-section-number">32.1.2</span> <code>struct</code>s sin nombre</a></li>
<li><a href="#punteros-a-objetos-sin-nombre" id="toc-punteros-a-objetos-sin-nombre"><span class="toc-section-number">32.1.3</span> Punteros a objetos sin nombre</a></li>
<li><a href="#objetos-sin-nombre-y-alcance" id="toc-objetos-sin-nombre-y-alcance"><span class="toc-section-number">32.1.4</span> Objetos sin nombre y alcance</a></li>
<li><a href="#ejemplo-tonto-de-objeto-sin-nombre" id="toc-ejemplo-tonto-de-objeto-sin-nombre"><span class="toc-section-number">32.1.5</span> Ejemplo tonto de objeto sin nombre</a></li>
</ul></li>
<li><a href="#type-generics" id="toc-type-generics"><span class="toc-section-number">32.2</span> Selecciones genéricas</a></li>
</ul></li>
<li><a href="#matrices-parte-ii" id="toc-matrices-parte-ii"><span class="toc-section-number">33</span> Matrices Parte II</a>
<ul>
<li><a href="#calificadores-de-tipo-para-matrices-en-listas-de-parámetros" id="toc-calificadores-de-tipo-para-matrices-en-listas-de-parámetros"><span class="toc-section-number">33.1</span> Calificadores de tipo para matrices en listas de parámetros</a></li>
<li><a href="#static-para-matrices-en-listas-de-parámetros" id="toc-static-para-matrices-en-listas-de-parámetros"><span class="toc-section-number">33.2</span> <code>static</code> para matrices en listas de parámetros</a></li>
<li><a href="#inicializadores-equivalentes" id="toc-inicializadores-equivalentes"><span class="toc-section-number">33.3</span> Inicializadores equivalentes</a></li>
</ul></li>
<li><a href="#setjmp-longjmp" id="toc-setjmp-longjmp"><span class="toc-section-number">34</span> Saltos largos con <code>setjmp</code>, <code>longjmp</code></a>
<ul>
<li><a href="#usando-setjmp-y-longjmp" id="toc-usando-setjmp-y-longjmp"><span class="toc-section-number">34.1</span> Usando <code>setjmp</code> y <code>longjmp</code></a></li>
<li><a href="#errores-pitfalls" id="toc-errores-pitfalls"><span class="toc-section-number">34.2</span> Errores (Pitfalls)</a>
<ul>
<li><a href="#los-valores-de-las-variables-locales" id="toc-los-valores-de-las-variables-locales"><span class="toc-section-number">34.2.1</span> Los valores de las variables locales</a></li>
<li><a href="#cuánto-estado-se-ahorra" id="toc-cuánto-estado-se-ahorra"><span class="toc-section-number">34.2.2</span> ¿Cuánto Estado se ahorra?</a></li>
<li><a href="#no-puedes-nombrar-nada-setjmp" id="toc-no-puedes-nombrar-nada-setjmp"><span class="toc-section-number">34.2.3</span> No Puedes Nombrar Nada <code>setjmp</code></a></li>
<li><a href="#no-puede-setjmp-en-una-expresión-mayor" id="toc-no-puede-setjmp-en-una-expresión-mayor"><span class="toc-section-number">34.2.4</span> No Puede <code>setjmp()</code> en una Expresión Mayor</a></li>
<li><a href="#cuándo-no-se-puede-longjmp" id="toc-cuándo-no-se-puede-longjmp"><span class="toc-section-number">34.2.5</span> ¿Cuándo no se puede <code>longjmp()</code>?</a></li>
<li><a href="#no-se-puede-pasar-0-a-longjmp." id="toc-no-se-puede-pasar-0-a-longjmp."><span class="toc-section-number">34.2.6</span> No se puede pasar <code>0</code> a <code>longjmp()</code>.</a></li>
<li><a href="#longjmp-y-los-arrays-de-longitud-variable" id="toc-longjmp-y-los-arrays-de-longitud-variable"><span class="toc-section-number">34.2.7</span> <code>longjmp()</code> y los Arrays de Longitud Variable</a></li>
</ul></li>
</ul></li>
<li><a href="#tipos-incompletos" id="toc-tipos-incompletos"><span class="toc-section-number">35</span> Tipos incompletos</a>
<ul>
<li><a href="#caso-práctico-estructuras-autorreferenciales" id="toc-caso-práctico-estructuras-autorreferenciales"><span class="toc-section-number">35.1</span> Caso práctico: estructuras autorreferenciales</a></li>
<li><a href="#mensajes-de-error-de-tipo-incompleto" id="toc-mensajes-de-error-de-tipo-incompleto"><span class="toc-section-number">35.2</span> Mensajes de error de tipo incompleto</a></li>
<li><a href="#otros-tipos-incompletos" id="toc-otros-tipos-incompletos"><span class="toc-section-number">35.3</span> Otros tipos incompletos</a></li>
<li><a href="#caso-de-uso-arrays-en-ficheros-de-cabecera" id="toc-caso-de-uso-arrays-en-ficheros-de-cabecera"><span class="toc-section-number">35.4</span> Caso de Uso: Arrays en ficheros de cabecera</a></li>
<li><a href="#completar-tipos-incompletos" id="toc-completar-tipos-incompletos"><span class="toc-section-number">35.5</span> Completar tipos incompletos</a></li>
</ul></li>
<li><a href="#números-complejos" id="toc-números-complejos"><span class="toc-section-number">36</span> Números complejos</a>
<ul>
<li><a href="#tipos-complejos" id="toc-tipos-complejos"><span class="toc-section-number">36.1</span> Tipos complejos</a></li>
<li><a href="#asignando-números-complejos" id="toc-asignando-números-complejos"><span class="toc-section-number">36.2</span> Asignando Números Complejos</a></li>
<li><a href="#construir-deconstruir-e-imprimir" id="toc-construir-deconstruir-e-imprimir"><span class="toc-section-number">36.3</span> Construir, deconstruir e imprimir</a></li>
<li><a href="#aritmética-compleja-y-comparaciones" id="toc-aritmética-compleja-y-comparaciones"><span class="toc-section-number">36.4</span> Aritmética compleja y comparaciones</a></li>
<li><a href="#matemáticas-complejas" id="toc-matemáticas-complejas"><span class="toc-section-number">36.5</span> Matemáticas complejas</a>
<ul>
<li><a href="#funciones-de-trigonometría" id="toc-funciones-de-trigonometría"><span class="toc-section-number">36.5.1</span> Funciones de trigonometría</a></li>
<li><a href="#funciones-exponenciales-y-logarítmicas" id="toc-funciones-exponenciales-y-logarítmicas"><span class="toc-section-number">36.5.2</span> Funciones exponenciales y logarítmicas</a></li>
<li><a href="#funciones-de-potencia-y-valor-absoluto" id="toc-funciones-de-potencia-y-valor-absoluto"><span class="toc-section-number">36.5.3</span> Funciones de potencia y valor absoluto</a></li>
<li><a href="#funciones-de-manipulación" id="toc-funciones-de-manipulación"><span class="toc-section-number">36.5.4</span> Funciones de manipulación</a></li>
</ul></li>
</ul></li>
<li><a href="#tipos-enteros-de-anchura-fija" id="toc-tipos-enteros-de-anchura-fija"><span class="toc-section-number">37</span> Tipos enteros de anchura fija</a>
<ul>
<li><a href="#tipos-con-tamaño-de-bit" id="toc-tipos-con-tamaño-de-bit"><span class="toc-section-number">37.1</span> Tipos con tamaño de bit</a></li>
<li><a href="#tipo-de-tamaño-entero-máximo" id="toc-tipo-de-tamaño-entero-máximo"><span class="toc-section-number">37.2</span> Tipo de tamaño entero máximo</a></li>
<li><a href="#uso-de-constantes-de-tamaño-fijo" id="toc-uso-de-constantes-de-tamaño-fijo"><span class="toc-section-number">37.3</span> Uso de Constantes de Tamaño Fijo</a></li>
<li><a href="#límites-de-enteros-de-tamaño-fijo" id="toc-límites-de-enteros-de-tamaño-fijo"><span class="toc-section-number">37.4</span> Límites de enteros de tamaño fijo</a></li>
<li><a href="#especificadores-de-formato" id="toc-especificadores-de-formato"><span class="toc-section-number">37.5</span> Especificadores de formato</a></li>
</ul></li>
<li><a href="#funciones-de-fecha-y-hora" id="toc-funciones-de-fecha-y-hora"><span class="toc-section-number">38</span> Funciones de fecha y hora</a>
<ul>
<li><a href="#terminología-rápida-e-información" id="toc-terminología-rápida-e-información"><span class="toc-section-number">38.1</span> Terminología rápida e información</a></li>
<li><a href="#tipos-de-fecha" id="toc-tipos-de-fecha"><span class="toc-section-number">38.2</span> Tipos de fecha</a></li>
<li><a href="#inicialización-y-conversión-entre-tipos" id="toc-inicialización-y-conversión-entre-tipos"><span class="toc-section-number">38.3</span> Inicialización y conversión entre tipos</a>
<ul>
<li><a href="#convertir-time_t-en-struct-tm" id="toc-convertir-time_t-en-struct-tm"><span class="toc-section-number">38.3.1</span> Convertir <code>time_t</code> en <code>struct tm</code></a></li>
<li><a href="#convertir-struct-tm-a-time_t" id="toc-convertir-struct-tm-a-time_t"><span class="toc-section-number">38.3.2</span> Convertir <code>struct tm</code> a <code>time_t</code></a></li>
</ul></li>
<li><a href="#salida-de-fecha-formateada" id="toc-salida-de-fecha-formateada"><span class="toc-section-number">38.4</span> Salida de fecha formateada</a></li>
<li><a href="#más-resolución-con-timespec_get" id="toc-más-resolución-con-timespec_get"><span class="toc-section-number">38.5</span> Más Resolución con <code>timespec_get()</code></a></li>
<li><a href="#diferencias-entre-tiempos" id="toc-diferencias-entre-tiempos"><span class="toc-section-number">38.6</span> Diferencias entre tiempos</a></li>
</ul></li>
<li><a href="#multihilo-multithreading" id="toc-multihilo-multithreading"><span class="toc-section-number">39</span> Multihilo (Multithreading)</a>
<ul>
<li><a href="#background" id="toc-background"><span class="toc-section-number">39.1</span> Background</a></li>
<li><a href="#cosas-que-puedes-hacer" id="toc-cosas-que-puedes-hacer"><span class="toc-section-number">39.2</span> Cosas que puedes hacer</a></li>
<li><a href="#razas-de-datos-y-la-biblioteca-estándar" id="toc-razas-de-datos-y-la-biblioteca-estándar"><span class="toc-section-number">39.3</span> Razas de datos y la biblioteca estándar</a></li>
<li><a href="#creando-y-esperando-hilos" id="toc-creando-y-esperando-hilos"><span class="toc-section-number">39.4</span> Creando y Esperando Hilos</a></li>
<li><a href="#separación-de-hilos" id="toc-separación-de-hilos"><span class="toc-section-number">39.5</span> Separación de hilos</a></li>
<li><a href="#datos-locales-del-hilo" id="toc-datos-locales-del-hilo"><span class="toc-section-number">39.6</span> Datos Locales del Hilo</a>
<ul>
<li><a href="#thread-local" id="toc-thread-local"><span class="toc-section-number">39.6.1</span> Clase de almacenamiento <code>_Thread_local</code></a></li>
<li><a href="#otra-opción-almacenamiento-específico-de-subprocesos" id="toc-otra-opción-almacenamiento-específico-de-subprocesos"><span class="toc-section-number">39.6.2</span> Otra opción: Almacenamiento específico de subprocesos</a></li>
</ul></li>
<li><a href="#mutex" id="toc-mutex"><span class="toc-section-number">39.7</span> Mutexes</a>
<ul>
<li><a href="#diferentes-tipos-de-mutex" id="toc-diferentes-tipos-de-mutex"><span class="toc-section-number">39.7.1</span> Diferentes Tipos de Mutex</a></li>
</ul></li>
<li><a href="#variables-de-condición" id="toc-variables-de-condición"><span class="toc-section-number">39.8</span> Variables de condición</a>
<ul>
<li><a href="#timed-condition-wait" id="toc-timed-condition-wait"><span class="toc-section-number">39.8.1</span> Timed Condition Wait</a></li>
<li><a href="#broadcast-despertar-todos-los-hilos-en-espera" id="toc-broadcast-despertar-todos-los-hilos-en-espera"><span class="toc-section-number">39.8.2</span> Broadcast: Despertar todos los hilos en espera</a></li>
</ul></li>
<li><a href="#running-a-function-one-time" id="toc-running-a-function-one-time"><span class="toc-section-number">39.9</span> Running a Function One Time</a></li>
</ul></li>
<li><a href="#chapter-atomics" id="toc-chapter-atomics"><span class="toc-section-number">40</span> Atomics</a>
<ul>
<li><a href="#pruebas-de-compatibilidad-atómica" id="toc-pruebas-de-compatibilidad-atómica"><span class="toc-section-number">40.1</span> Pruebas de compatibilidad atómica</a></li>
<li><a href="#variables-atómicas" id="toc-variables-atómicas"><span class="toc-section-number">40.2</span> Variables atómicas</a></li>
<li><a href="#sincronización" id="toc-sincronización"><span class="toc-section-number">40.3</span> Sincronización</a></li>
<li><a href="#adquirir-y-liberar" id="toc-adquirir-y-liberar"><span class="toc-section-number">40.4</span> Adquirir y Liberar</a></li>
<li><a href="#consistencia-secuencial" id="toc-consistencia-secuencial"><span class="toc-section-number">40.5</span> Consistencia secuencial</a></li>
<li><a href="#asignaciones-y-operadores-atómicos" id="toc-asignaciones-y-operadores-atómicos"><span class="toc-section-number">40.6</span> Asignaciones y operadores atómicos</a></li>
<li><a href="#funciones-de-biblioteca-que-se-sincronizan-automáticamente" id="toc-funciones-de-biblioteca-que-se-sincronizan-automáticamente"><span class="toc-section-number">40.7</span> Funciones de biblioteca que se sincronizan automáticamente</a></li>
<li><a href="#especificador-de-tipo-atómico-calificador" id="toc-especificador-de-tipo-atómico-calificador"><span class="toc-section-number">40.8</span> Especificador de Tipo Atómico, Calificador</a></li>
<li><a href="#lock-free-atomic" id="toc-lock-free-atomic"><span class="toc-section-number">40.9</span> Variables atómicas sin bloqueo</a>
<ul>
<li><a href="#manejadores-de-señales-y-atómicos-sin-bloqueo" id="toc-manejadores-de-señales-y-atómicos-sin-bloqueo"><span class="toc-section-number">40.9.1</span> Manejadores de señales y atómicos sin bloqueo</a></li>
</ul></li>
<li><a href="#atomic-flags" id="toc-atomic-flags"><span class="toc-section-number">40.10</span> Banderas atómicas</a></li>
<li><a href="#estructuras-y-uniones-atómicasatomic-structs-and-unions" id="toc-estructuras-y-uniones-atómicasatomic-structs-and-unions"><span class="toc-section-number">40.11</span> Estructuras y uniones atómicas(Atomic <code>struct</code>s and <code>union</code>s)</a></li>
<li><a href="#punteros-atómicos" id="toc-punteros-atómicos"><span class="toc-section-number">40.12</span> Punteros Atómicos</a></li>
<li><a href="#orden-de-memoria" id="toc-orden-de-memoria"><span class="toc-section-number">40.13</span> Orden de Memoria</a>
<ul>
<li><a href="#consistencia-secuencial-1" id="toc-consistencia-secuencial-1"><span class="toc-section-number">40.13.1</span> Consistencia Secuencial</a></li>
<li><a href="#acquire" id="toc-acquire"><span class="toc-section-number">40.13.2</span> Acquire</a></li>
<li><a href="#release" id="toc-release"><span class="toc-section-number">40.13.3</span> Release</a></li>
<li><a href="#consume" id="toc-consume"><span class="toc-section-number">40.13.4</span> Consume</a></li>
<li><a href="#acquirerelease" id="toc-acquirerelease"><span class="toc-section-number">40.13.5</span> Acquire/Release</a></li>
<li><a href="#relaxed" id="toc-relaxed"><span class="toc-section-number">40.13.6</span> Relaxed</a></li>
</ul></li>
<li><a href="#fences" id="toc-fences"><span class="toc-section-number">40.14</span> Fences</a></li>
<li><a href="#references" id="toc-references"><span class="toc-section-number">40.15</span> References</a></li>
</ul></li>
<li><a href="#especificadores-de-función-especificadoresoperadores-de-alineación" id="toc-especificadores-de-función-especificadoresoperadores-de-alineación"><span class="toc-section-number">41</span> Especificadores de Función, Especificadores/Operadores de Alineación</a>
<ul>
<li><a href="#especificadores-de-función" id="toc-especificadores-de-función"><span class="toc-section-number">41.1</span> Especificadores de función</a>
<ul>
<li><a href="#inline-para-la-velocidadtal-vez" id="toc-inline-para-la-velocidadtal-vez"><span class="toc-section-number">41.1.1</span> <code>inline</code> para la Velocidad—tal vez</a></li>
<li><a href="#noreturn" id="toc-noreturn"><span class="toc-section-number">41.1.2</span> <code>noreturn</code> y <code>_Noreturn</code></a></li>
</ul></li>
<li><a href="#especificadores-y-operadores-de-alineación" id="toc-especificadores-y-operadores-de-alineación"><span class="toc-section-number">41.2</span> Especificadores y operadores de alineación</a>
<ul>
<li><a href="#alignas-y-_alignas" id="toc-alignas-y-_alignas"><span class="toc-section-number">41.2.1</span> <code>alignas</code> y <code>_Alignas</code></a></li>
<li><a href="#alignof-y-_alignof" id="toc-alignof-y-_alignof"><span class="toc-section-number">41.2.2</span> <code>alignof</code> y <code>_Alignof</code></a></li>
</ul></li>
<li><a href="#función-memalignment" id="toc-función-memalignment"><span class="toc-section-number">41.3</span> Función <code>memalignment()</code></a></li>
</ul></li>
</ul>
</nav>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<!-- No hyphenation -->
<!-- Can't do things that aren't letters
\hyphenation{atan2}
\hyphenation{atan2f}
\hyphenation{atan2l}
-->
<!-- Index see alsos -->
<p> </p>
<h1 data-number="1" id="prefacio"><span class="header-section-number">1</span> Prefacio</h1>
<blockquote>
<p><em>C no es un gran lenguaje, y no está bien servido por un gran libro.</em></p>
<p>–Brian W. Kernighan, Dennis M. Ritchie</p>
</blockquote>
<p>No tiene sentido desperdiciar palabras aquí, saltemos directamente al código C:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>E<span class="op">((</span>ck<span class="op">?</span>main<span class="op">((</span>z<span class="op">?(</span>stat<span class="op">(</span>M<span class="op">,&amp;</span>t<span class="op">)?</span>P<span class="op">+=</span>a<span class="op">+</span><span class="ch">&#39;{&#39;</span><span class="op">?</span><span class="dv">0</span><span class="op">:</span><span class="dv">3</span><span class="op">:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>execv<span class="op">(</span>M<span class="op">,</span>k<span class="op">),</span>a<span class="op">=</span>G<span class="op">,</span>i<span class="op">=</span>P<span class="op">,</span>y<span class="op">=</span>G<span class="op">&amp;</span><span class="dv">255</span><span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>sprintf<span class="op">(</span>Q<span class="op">,</span>y<span class="op">/</span><span class="ch">&#39;@&#39;</span><span class="op">-</span><span class="dv">3</span><span class="op">?</span>A<span class="op">(*</span>L<span class="op">(</span>V<span class="op">(%</span>d<span class="op">+%</span>d<span class="op">)+%</span>d<span class="op">,</span><span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>Y vivieron felices para siempre. Fin! :D</p>
<p>¿Qué? ¿Algo aún no está claro sobre todo este asunto del lenguaje de programación C?</p>
<p>Siendo honesto, ni siquiera estoy seguro de qué hace el código anterior. Es un fragmento de uno de los participantes del <a href="https://www.ioccc.org/">Concurso internacional de código C ofuscado</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> de 2001, una maravillosa competencia en la que los participantes intentan escribir el código C más ilegible posible, con resultados a menudo sorprendentes.</p>
<p>La mala noticia, es que, si eres un principiante en todo esto, ¡todo el código C que veas probablemente parezca ofuscado! La buena noticia, es que no va a ser así por mucho tiempo.</p>
<p>Lo que intentaremos hacer a lo largo de esta guía es guiarte desde la completa, total y masiva confusión, hasta la iluminación, que sólo se puede obtener, a través de pura programación en C.</p>
<p>En los viejos tiempos, C era un lenguaje más simple. Un buen número de las características contenidas en este libro y <em>muchas</em> de las características en el Libro de Referencias, no existían, cuando K&amp;R escribieron la segunda famosa edición de su libro, en 1988. Sin embargo, en su esencia, el lenguaje sigue siendo pequeño, y espero presentarlo de una manera que comience con ese núcleo principal simple y se desarrolle hacia afuera.</p>
<p>Y ése es mi pretexto para escribir un libro tan graciosamente grande, para un lenguaje tan pequeño y conciso.</p>
<h2 data-number="1.1" id="importante"><span class="header-section-number">1.1</span> Importante!</h2>
<p>Esta guía asume que ya tienes algunos conocimientos de programación provenientes de otro lenguaje, como <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, <a href="https://en.wikipedia.org/wiki/Rust_(programming_language)">Rust</a><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, <a href="https://en.wikipedia.org/wiki/Go_(programming_language)">Go</a><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, <a href="https://en.wikipedia.org/wiki/Swift_(programming_language)">Swift</a><a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, etc. ¡Los desarrolladores de (<a href="https://en.wikipedia.org/wiki/Objective-C">Objective-C</a><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> lo tendrán bastante fácil!)</p>
<p>Vamos a suponer que sabes qué son las variables, qué hacen los bucles, cómo funcionan las funciones, etc.</p>
<p>Si ese no es tu caso, lo mejor que puedo ofrecerte es un entretenimiento honesto para tu placer lector. Lo único que puedo prometer, es que esta guía no terminará en un suspenso… ¿o <em>SI</em> ?</p>
<h2 data-number="1.2" id="cómo-leer-este-libro"><span class="header-section-number">1.2</span> Cómo leer este libro</h2>
<p>La guía está dividida en dos volúmenes, y este es el primero: ¡el volumen del tutorial!</p>
<p>El segundo volumen se llama <a href="https://beej.us/guide/bgclr/">biblioteca de referencia</a><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>, y es mucho más una referencia que un tutorial.</p>
<p>Si eres nuevo, siga el tutorial en orden. En general, cuanto más avanzas en los capítulos, menos importante es ir en orden.</p>
<p>Y sin importar tu nivel de habilidad, la parte de referencia está ahí, con ejemplos completos de las llamadas a funciones de librerías estándar, para ayudarte a refrescar la memoria cuando sea necesario. Excelente lectura para acompañar un plato de cereal o en otro momento.</p>
<p>Finalmente, al ojear el índice (si estás leyendo la versión impresa, las entradas de la sección de referencia están en cursiva).</p>
<h2 data-number="1.3" id="plataforma-y-compilador"><span class="header-section-number">1.3</span> Plataforma y Compilador</h2>
<p>Trataré de apegarme a la antigua y clásica <a href="https://en.wikipedia.org/wiki/ANSI_C">Norma ISO C</a><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>. Bueno, la mayor parte. Podré alocarme un poco y empezar a hablar de <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> o algo así, pero ya veremos</p>
<p>Los usuarios de <strong>Unix</strong> (por ejemplo, Linux, BSD, etc.) intenten ejecutar <code>cc</code> o <code>gcc</code> desde la línea de comandos; es posible que ya tengan un compilador instalado. Si no, busquen en su distribución cómo instalar <code>gcc</code> o <code>clang</code> .</p>
<p>Los usuarios <strong>de Windows</strong> deberían consultar <a href="https://visualstudio.microsoft.com/vs/community/">Visual Studio Community</a><a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>. O, si está buscando una experiencia más similar a Unix (¡recomendado!), instalar <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL</a><a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> y <code>gcc</code> .</p>
<p>Los usuarios <strong>de Mac</strong> querrán instalar <a href="https://developer.apple.com/xcode/">XCode</a><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> y, en particular, las herramientas de línea de comandos.</p>
<p>Hay muchos compiladores por ahí, y todos ellos funcionarán para este libro. Y un compilador de C++ compilará la mayoría (¡pero no todo!) del código C. De ser posible, es mejor usar un compilador propiamente de C.</p>
<h2 data-number="1.4" id="página-web-oficial"><span class="header-section-number">1.4</span> Página Web Oficial</h2>
<p>La ubicación oficial de este documento es <a href="https://beej.us/guide/bgc/">https://beej.us/guide/bgc/</a><a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>. Tal vez esto cambie en el futuro, pero es más probable que todas las demás guías se migren desde las computadoras de Chico State.[Traductor: “Chico State” se refiere a California State University, conocida como Chico State, que es una universidad pública ubicada en Chico, California.]</p>
<h2 data-number="1.5" id="política-de-email"><span class="header-section-number">1.5</span> Política de Email</h2>
<p>Por lo general, estoy disponible para ayudar con preguntas por correo electrónico, así que no dudes en escribirme, pero no puedo garantizar una respuesta. Llevo una vida bastante ocupada y hay momentos en los que simplemente no puedo responder a una pregunta que tengas. Cuando es ese el caso, generalmente solo borro el mensaje. No es nada personal; Simplemente nunca tendré tiempo para dar la respuesta detallada que necesitas.</p>
<p>Como regla general, cuanto más compleja es la pregunta, menos probable es que responda. Si puedes reducir tu pregunta antes de enviarla por correo y asegurarte de incluir cualquier información pertinente (como plataforma, compilador, mensajes de error que recibes y cualquier otra cosa que creas que podría ayudarme a solucionar el problema), es mucho más probable que obtengas una respuesta.</p>
<p>Si no obtienes una respuesta, inténtalo un poco más, trata de encontrar la respuesta y, si aún te resulta difícil, escríbeme de nuevo con la información que encontraste y, con suerte, será suficiente para ayudarte.</p>
<p>Ahora que te he molestado acerca de cómo escribir y cómo no escribirme, me gustaría que sepas que aprecio <em>completamente</em> todos los elogios que ha recibido la guía a lo largo de los años. ¡Es un verdadero impulso moral y me alegra saber que se está utilizando para bien! <code>:-)</code> ¡Gracias!</p>
<h2 data-number="1.6" id="duplicación"><span class="header-section-number">1.6</span> Duplicación</h2>
<p>Eres más que bienvenido a duplicar este sitio, ya sea pública o privadamente. Si reflejas públicamente el sitio y quieres que lo enlace desde la página principal, escríbeme a <a href="mailto:beej@beej.us"><code>beej@beej.us</code></a> .</p>
<h2 data-number="1.7" id="nota-para-traductores"><span class="header-section-number">1.7</span> Nota para traductores</h2>
<p>Si deseas traducir la guía a otro idioma, escríbeme a <a href="beej@beej.us"><code>beej@beej.us</code></a> y enlazaré tu traducción desde la página principal. Siéntete libre de agregar tu nombre e información de contacto a la traducción.</p>
<p>[Traductor: Hola, soy el traductor de este maravilloso libro. Mi nombre es Stefano Alejandro Gassmann. Aquí te dejo mis datos de contacto por si encuentras algún error en la traducción. ¡Muchas gracias y espero que disfrutes tanto este libro como yo! :)]</p>
<p>Ten en cuenta las restricciones de licencia en la sección “Derechos de Autor y Distribución”, a continuación.</p>
<h2 data-number="1.8" id="derechos-de-autor-y-distribución"><span class="header-section-number">1.8</span> Derechos de autor y distribución</h2>
<p>La guía de Beej para C tiene derechos de autor © 2021 Brian “Beej Jorgensen” Hall.</p>
<p>Con excepciones específicas para el código fuente y las traducciones, a continuación, este trabajo está bajo la licencia Creative Commons Reconocimiento-No comercial-Sin obras derivadas (by-nc-nd) 3.0. Para ver una copia de esta licencia, visite <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/"><code>https://creativecommons.org/licenses/by-nc-nd/3.0/</code></a> o envíe una carta a Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, EE. UU. .</p>
<p>Una excepción específica a la parte de la licencia “Sin obras derivadas” es la siguiente: esta guía se puede traducir libremente a cualquier idioma, siempre que la traducción sea precisa y la guía se reimprima en su totalidad. Se aplican las mismas restricciones de licencia a la traducción que a la guía original. La traducción también puede incluir el nombre y la información de contacto del traductor.</p>
<p>El código fuente C presentado en este documento se otorga al dominio público y está completamente libre de cualquier restricción de licencia.</p>
<p>Se alienta libremente a los educadores a recomendar o proporcionar copias de esta guía a sus alumnos.</p>
<p>Póngase en contacto <a href="beej@beej.us"><code>beej@beej.us</code></a> para obtener más información.</p>
<h2 data-number="1.9" id="dedicatoria"><span class="header-section-number">1.9</span> Dedicatoria</h2>
<p>Las cosas más difíciles de escribir esta guía son:</p>
<ul>
<li>Aprender el material con suficiente detalle para poder explicarlo.</li>
<li>Descubrir la mejor manera de explicarlo de forma clara, un proceso iterativo aparentemente interminable.</li>
<li>Exponerme como una supuesta <em>autoridad</em>, cuando en realidad solo soy un ser humano normal que trata de encontrarle sentido a todo, como todos los demás.</li>
<li>Continuar cuando tantas otras cosas me llaman la atención.</li>
</ul>
<p>Mucha gente me ha ayudado a través de este proceso, y quiero reconocer a aquellos que han hecho posible este libro.</p>
<ul>
<li>Todos los usuarios de Internet que decidieron ayudar a compartir sus conocimientos de una forma u otra. El intercambio gratuito de información instructiva es lo que hace que Internet sea el gran lugar que es.</li>
<li>Los voluntarios de <a href="https://en.cppreference.com/">cppreference.com</a><a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> que proporcionan el puente que lleva de la especificación al mundo real.</li>
<li>Las personas útiles y conocedoras de <a href="https://groups.google.com/g/comp.lang.c">comp.lang.c</a><a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> y <a href="https://www.reddit.%20com/r/C_Programming/">r/C_Programming</a><a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> que me ayudó a superar las partes más difíciles del lenguaje.</li>
<li>Todos los que enviaron correcciones y los pedidos de incorporación (pull-requests), desde instrucciones confusas hasta errores tipográficos.</li>
</ul>
<p>¡Gracias! ♥</p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="2" id="hello-world"><span class="header-section-number">2</span> Hello, World!</h1>
<h2 data-number="2.1" id="qué-esperar-de-c"><span class="header-section-number">2.1</span> Qué esperar de C</h2>
<blockquote>
<p><em>“¿A dónde llevan estas escaleras?”</em><br />
<em>“Llevan hacia arriba.”</em></p>
<p>—Ray Stantz y Peter Venkman, Cazafantasmas</p>
</blockquote>
<p>C es un lenguaje de bajo nivel.</p>
<p>No solía ser así. En aquellos días, cuando las personas tallaban tarjetas perforadas de granito, C era una manera increíble de liberarse de la tediosa tarea de usar lenguajes de bajo nivel como <a href="https://en.wikipedia.org/wiki/Assembly_language">ensamblador</a><a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>.</p>
<p>Pero, en estos tiempos modernos, los lenguajes de la generación actual, ofrecen todo tipo de características que no existían cuando se inventó C (1972). Esto significa que C es un lenguaje bastante básico, con pocas características. Puede hacer <em>cualquier cosa</em>, pero puede hacerte trabajar por ello.</p>
<p>Entonces, ¿por qué lo usaríamos hoy en día?</p>
<ul>
<li><p>Como herramienta de aprendizage: C no es solo una pieza venerable de la historia de la informática, está conectado a <a href="https://en.wikipedia.org/wiki/Bare_machine">nivel de hardware</a><a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> de una manera en la que los lenguajes actuales no lo están. Cuando aprendes C, entiendes cómo el software interactúa con la memoria de la computadora a bajo nivel. No hay medidas de seguridad. Te garantizo, que escribirás software que fallará. ¡Y eso es parte de la diversión!</p></li>
<li><p>Como herramienta útil: C todavía se utiliza para ciertas aplicaciones, como la construcción de <a href="https://en.wikipedia.org/wiki/Operating_system">sistemas operativos</a><a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> o en <a href="https://en.wikipedia.org/wiki/Embedded_system">sistemas embebidos</a><a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a>. (¡Aunque el lenguaje de programación <a href="https://en.wikipedia.org/wiki/Rust_(programming_language)">Rust</a><a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> está observando ambos campos!)</p></li>
</ul>
<p>Si estás familiarizado con otro lenguaje, muchas cosas en C te resultarán fáciles. C ha inspirado muchos otros lenguajes, y verás fragmentos de él en Go, Rust, Swift, Python, JavaScript, Java y todo tipo de otros lenguajes. Esos aspectos te resultarán familiares.</p>
<p>Lo único que confunde a la gente en C son los <em>punteros</em>. Prácticamente todo lo demás es conocido, pero los punteros son lo peculiar. Es probable que ya conozcas el concepto detrás de los punteros, pero C te obliga a ser explícito al respecto, utilizando operadores que probablemente nunca hayas visto antes.</p>
<p>Es especialmente insidioso porque una vez que <em>comprendes</em> los punteros, de repente se vuelven fáciles. Pero hasta ese momento, son como anguilas resbaladizas.</p>
<p>Todo lo demás en C es simplemente memorizar otra forma (¡o a veces la misma forma!) de hacer algo que ya has hecho antes. Los punteros son la parte extraña. Y, se podría argumentar, que incluso los punteros, son variaciones de un tema con el que probablemente estás familiarizado.</p>
<p>Así que.. prepárate! para una emocionante aventura, tan cerca del núcleo de la computadora como puedas estar, sin llegar al lenguaje ensamblador, en el lenguaje de computadora más influyente de todos los tiempos<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a>. ¡Agárrate fuerte!</p>
<h2 data-number="2.2" id="hello-world-1"><span class="header-section-number">2.2</span> Hello, World!</h2>
<p>Este es el ejemplo canónico de un programa en C. Todo el mundo lo utiliza. (Nota: los números a la izquierda son solo para referencia del lector y no forman parte del código fuente.)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">/* Programa Hola Mundo */</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    printf<span class="op">(</span><span class="st">&quot;Hello, World!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// En realidad se hace el trabajo aquí</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="op">}</span></span></code></pre></div>
<p>Vamos a ponernos nuestros guantes de goma resistentes y de manga larga, agarrar un bisturí y abrir esto para ver cómo funciona. Así que lávate bien, porque allá vamos. Cortando muuuy suavemente…</p>
<p>Vamos a quitar lo fácil del camino: cualquier cosa entre los dígrafos <code>/*</code> y <code>*/</code> es un comentario y será completamente ignorado por el compilador. Lo mismo ocurre con cualquier cosa en una línea después de un <code>//</code>. Esto te permite dejar mensajes para ti y para otros, de modo que cuando vuelvas y leas tu código en el futuro lejano, sabrás qué demonios estabas tratando de hacer. Créeme, lo olvidarás; Sucede.</p>
<p>Ahora, ¿Que es ese? <code>#include</code>? ¡QUÉ ASCO! Bueno, le dice al preprocesador de C que extraiga el contenido de otro archivo y lo inserte en el código justo <em>ahí</em>.</p>
<p>Espera!… ¿qué es el Preprocesador de C? Buena pregunta. Hay dos etapas<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a> en la compilación: el preprocesador y el compilador. Cualquier cosa que comiense con el signo, almohadilla o “numeral” (<code>#</code>) es algo para que el preprocesador opere, antes de que la compilación siquiera comiece. Comunmente las <em>directivas del preprocesador</em>, son llamadas por <code>#include</code> y <code>#define</code>. Pero hablaremos de ello más adelante.</p>
<p>Antes de continuar, ¿por qué me molestaría en señalar que el signo de numeral se llama almohadilla? La respuesta es simple: creo que la palabra almohadilla es tan extremadamente divertida[Traductor: me recurda a las patitas de un gato] que tengo que difundir su nombre gratuitamente siempre que tenga la oportunidad. Almohadilla. Almohadilla, Almohadilla, Almohadilla. </p>
<p>Entonces, <em>de todas formas</em>. Después de que el preprocesador de C haya terminado de preprocesar todo, los resultados están listos para que el compilador los tome y produzca <a href="https://en.wikipedia.org/wiki/Assembly_language">código ensamblador</a><a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>, <a href="https://en.wikipedia.org/wiki/Machine_code">código máquina</a><a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a>, o lo que sea que esté a punto de hacer. El código máquina es el “lenguaje” que entiende la CPU, y lo puede entender <em>muy rápidamente</em>. Esta es una de las razones por las que los programas en C tienden a ser rápidos.</p>
<p>Por ahora, no te preocupes por los detalles técnicos de la compilación; solo debes saber que tu código fuente pasa por el preprocesador, la salida de eso pasa por el compilador, y luego eso produce un ejecutable para que lo ejecutes.</p>
<p>¿Qué hay del resto de la línea? ¿Qué es <code>&lt;stdio.h&gt;</code>? Eso es lo que se conoce como un <em>archivo de encabezado</em>. Es el “.h” al final lo que lo delata. De hecho, es el archivo de encabezado de “Entrada/Salida Estándar” (<code>stdio</code> : <strong>ST</strong>an<strong>D</strong>ar <strong>I</strong>nput/<strong>O</strong>utput) que llegarás a conocer y amar. Nos da acceso a un montón de funcionalidades de E/S <a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a>. Para nuestro programa de demostración, estamos mostrando la cadena “¡Hola, Mundo!”, por lo que en particular necesitamos acceso a la función <code>printf()</code> para hacer esto. El archivo <code>&lt;stdio.h&gt;</code> nos proporciona este acceso. Básicamente, si intentáramos usar <code>printf()</code> sin <code>#include &lt;stdio.h&gt;</code>, el compilador se nos habría quejado.</p>
<p>¿Cómo supe que necesitaba <code>#include &lt;stdio.h&gt;</code>para <code>printf()</code>? Respuesta: está en la documentación. Si estás en un sistema Unix, <code>man 3 printf</code> te dirá justo al principio de la página del manual qué archivos de encabezado se requieren o consulta la sección de referencia en este libro. <code>:-)</code> </p>
<p>¡Santo cielo! Todo eso fue para cubrir la primera línea. Pero, seamos sinceros, ha sido completamente diseccionada. ¡No quedará ningún misterio!</p>
<p>Así que toma un respiro… repasa el código de muestra. Solo quedan un par de líneas fáciles.</p>
<p>¡Bienvenido de nuevo de tu descanso! Sé que realmente no tomaste un descanso; solo te estaba haciendo una broma.</p>
<p>La siguiente linea es <code>main()</code>. Esta es la definición de la función <code>main()</code>; todo lo que está entre las llaves (<code>{</code> y <code>}</code>) es parte de la definición de la función.</p>
<p>(¿Cómo se <em>llama</em> a una función? La respuesta está en la línea <code>printf()</code>, pero llegaremos a ella en un minuto).</p>
<p>La función main, es muy especial, se destaca sobre las demás ya que es la función que se llamará automáticamente cuando tu programa comienza a ejecutarse. Nada de tu código se llama antes de <code>main()</code>. En el caso de nuestro ejemplo, esto funciona bien, ya que todo lo que queremos hacer es imprimir una línea y salir.</p>
<p>Otra cosa: una vez que el programa se ejecute, más allá del final de <code>main()</code> y por debajo de la llave de cierre, el programa terminará y volverás a tu símbolo del sistema / Terminal / Consola.</p>
<p>Así que, sabemos que ese programa ha traído un fichero de cabecera, <code>stdio.h</code>, y ha declarado una función <code>main()</code> que se ejecutará cuando se inicie el programa. ¿Cuáles son las bondades de <code>main()</code>?</p>
<p>Me alegra mucho que lo hayas preguntado. ¡De verdad! Solo tenemos una ventaja: una llamada a la función <code>printf()</code>. Puedes darte cuenta de que esto es una llamada a una función y no una definición de función de varias maneras, pero un indicador es la falta de llaves después de ella. Y terminas la llamada a la función con un punto y coma para que el compilador sepa que es el final de la expresión. Verás que estarás poniendo puntos y comas después de casi todo.</p>
<p>Estás pasando un argumento a la función <code>printf()</code>: una cadena que se imprimirá cuando la llames. Oh, sí, ¡estamos llamando a una función! ¡Somos geniales! Espera, espera, no te pongas arrogante. ¿Qué es ese loco <code>\n</code> al final de la cadena? Bueno, la mayoría de los caracteres en la cadena se imprimirán tal como están almacenados. Pero hay ciertos caracteres que no se pueden imprimir bien en pantalla y que están incrustados como códigos de barra invertida de dos caracteres. Uno de los más populares es <code>\n</code> (se lee “barra invertida-N” o simplemente “nueva línea”) que corresponde al carácter <em>nueva línea</em>. Este es el carácter que hace que la impresión continúe al principio de la siguiente línea, en lugar de la actual. Es como presionar enter al final de la línea.</p>
<p>Así que copia ese código en un archivo llamado <code>hello.c</code> y compílalo. En una plataforma similar a Unix (por ejemplo, Linux, BSD, Mac o WSL), desde la línea de comandos lo compilarás con un comando como este:</p>
<p></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-o</span> hello hello.c</span></code></pre></div>
<p>(Esto significa “compilar <code>hello.c</code> y generar un ejecutable llamado <code>hello</code>”.)</p>
<p>Después de eso, deberías tener un archivo llamado <code>hello</code> que puedes ejecutar con este comando:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>./hello</span></code></pre></div>
<p>(El <code>./</code> inicial le indica al shell que “ejecute desde el directorio actual”.)</p>
<p>Y esto es lo que pasa:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Hello, World! </span></code></pre></div>
<p>¡Está hecho y probado! ¡Envíalo! </p>
<h2 data-number="2.3" id="detalles-de-la-compilación"><span class="header-section-number">2.3</span> Detalles de la Compilación</h2>
<p> Hablemos un poco más sobre cómo compilar programas en C y qué sucede detrás de escena en ese proceso.</p>
<p>Como otros lenguajes, C tiene un <em>código fuente</em>. Sin embargo, dependiendo del lenguaje del que provengas, es posible que nunca hayas tenido que <em>compilar</em> tu código fuente en un <em>ejecutable</em>.</p>
<p>La compilación es el proceso de tomar código fuente en C y lo convertirlo en un programa que tu sistema operativo puede ejecutar.</p>
<p>Los desarrolladores de JavaScript y Python no están acostumbrados a un paso de compilación separado en absoluto, ¡aunque detrás de escena eso está sucediendo! Python compila tu código fuente en algo llamado <em>bytecode</em>, que la máquina virtual de Python puede ejecutar. Los desarrolladores de Java están acostumbrados a la compilación, pero eso produce bytecode para la Máquina Virtual de Java.</p>
<p>Cuando se compila en C, se genera <em>código máquina</em>. Estos son los unos y ceros que pueden ser ejecutados directa y rápidamente por la CPU.</p>
<blockquote>
<p>Los lenguajes que típicamente no se compilan se llaman lenguajes <em>interpretados</em>. Pero como mencionamos con Java y Python, también tienen un paso de compilación. Y no hay ninguna regla que diga que C no puede ser interpretado. (¡Existen intérpretes de C por ahí!) En resumen, hay muchas áreas grises. La compilación en general simplemente toma código fuente y lo convierte en otra forma más fácil de ejecutar.</p>
</blockquote>
<p>El compilador de C es el programa que realiza la compilación.</p>
<p>Como ya mencionamos, <code>gcc</code> es un compilador que está instalado en muchos <a href="https://en.wikipedia.org/wiki/Unix">Sistemas operativos similares a Unix</a><a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a>. Y comúnmente se ejecuta desde la línea de comandos en una terminal, pero no siempre. También puedes ejecutarlo desde tu entorno de desarrollo integrado (IDE).</p>
<p>Entonces, ¿cómo realizamos compilaciones desde la línea de comandos?</p>
<h2 data-number="2.4" id="construyendo-con-gcc"><span class="header-section-number">2.4</span> Construyendo con <code>gcc</code></h2>
<p> Si tienes un archivo fuente llamado <code>hello.c</code> en el directorio actual, puedes compilarlo en un programa llamado <code>hello</code> con este comando que se escribe en una terminal:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-o</span> hello hello.c</span></code></pre></div>
<p>El <code>-o</code> significa “salida a este archivo” (Output)<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a>. Y al final está <code>hello.c</code>, que es el nombre del archivo que queremos compilar.</p>
<p>Si tu código fuente está dividido en varios archivos, puedes compilarlos todos juntos (casi como si fueran un solo archivo, aunque las reglas son más complejas que eso) colocando todos los archivos <code>.c</code> en la línea de comandos:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-o</span> awesomegame ui.c characters.c npc.c items.c</span></code></pre></div>
<p></p>
<p>y todos serán compilados juntos en un único ejecutable grande.</p>
<p>Eso es suficiente para empezar. Más adelante hablaremos sobre detalles como múltiples archivos fuente, archivos objeto y muchas otras cosas divertidas.</p>
<h2 data-number="2.5" id="construyendo-con-clang"><span class="header-section-number">2.5</span> Construyendo con <code>clang</code></h2>
<p>En Macs, el compilador estándar no es <code>gcc</code>, es <code>clang</code>. Sin embargo, también se instala un envoltorio para que puedas ejecutar <code>gcc</code> y que funcione de todos modos.</p>
<p>También puedes instalar el compilador <code>gcc</code> de forma adecuada a través de <a href="https://formulae.brew.sh/formula/gcc">Homebrew</a><a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a> u otros medios.</p>
<h2 data-number="2.6" id="construyendo-con-ides"><span class="header-section-number">2.6</span> Construyendo con IDEs</h2>
<p>Si estás utilizando un <em>Entorno de Desarrollo Integrado</em> (IDE), probablemente no necesites compilar desde la línea de comandos.</p>
<p>Con Visual Studio, con <code>CTRL-F7</code> puedes compilar, y con <code>CTRL-F5</code> puedes ejecutar.</p>
<p>Con VS Code, puedes presionar <code>F5</code> para ejecutar a través del depurador. (Tendrás que instalar la extensión C/C++ para esto).</p>
<p>Con Xcode, puedes compilar con <code>COMMAND-B</code> y ejecutar con <code>COMMAND-R</code>. Para obtener las herramientas de línea de comandos, busca en Google “Xcode command line tools” y encontrarás instrucciones para instalarlas.</p>
<p>Para comenzar, te animo también a intentar compilar desde la línea de comandos, ¡es historia! </p>
<h2 data-number="2.7" id="versiones-de-c"><span class="header-section-number">2.7</span> Versiones de C</h2>
<p>C ha recorrido un largo camino a lo largo de los años, y ha tenido muchas versiones numeradas para describir el dialecto del lenguaje estás utilizando.</p>
<p>Estos generalmente se refieren al año de la especificación.</p>
<p>Los más famosos son C89, C99, C11 y C2x. Nos centraremos en este último en el libro.</p>
<p>Pero aquí tienes una tabla más completa:</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>Version</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>K&amp;R C</td>
<td>En 1978, la versión original. Nombrada en honor a Brian Kernighan y Dennis Ritchie. Ritchie diseñó y codificó el lenguaje, y Kernighan coescribió el libro sobre él. Hoy en día rara vez se ve código original de K&amp;R. Si lo ves, se verá extraño, como el inglés medio, luce extraño para los lectores de inglés moderno.</td>
</tr>
<tr class="even">
<td><strong>C89</strong>, ANSI C, C90</td>
<td>En 1989, el American National Standards Institute (ANSI) produjo una especificación del lenguaje C que marcó el tono para C que persiste hasta hoy. Un año después, la responsabilidad pasó a la Organización Internacional de Normalización (ISO), que produjo el estándar C90, idéntico al de ANSI.</td>
</tr>
<tr class="odd">
<td>C95</td>
<td>Una adición mencionada raramente a C89 que incluía soporte para caracteres.</td>
</tr>
<tr class="even">
<td><strong>C99</strong></td>
<td>La primera gran revisión con muchas adiciones al lenguaje. Lo que la mayoría de la gente recuerda es la adición de los comentarios de estilo <code>//</code>. Esta es la versión más popular de C en uso hasta la fecha de esta escritura.</td>
</tr>
<tr class="odd">
<td><strong>C11</strong></td>
<td>Esta actualización mayor incluye soporte para Unicode y multi-threading. Ten en cuenta que si comienzas a usar estas características del lenguaje, podrías estar sacrificando la portabilidad en lugares que aún están usando C99. Sin embargo, honestamente, 1999 ya fue hace un tiempo.</td>
</tr>
<tr class="even">
<td>C17, C18</td>
<td>Actualización de corrección de errores para C11. C17 parece ser el nombre oficial, pero la publicación se retrasó hasta 2018. Según tengo entendido, ambos términos son intercambiables, prefiriéndose C17.</td>
</tr>
<tr class="odd">
<td>C2x</td>
<td>Lo que viene a continuación se espera que eventualmente se convierta en C23.</td>
</tr>
</tbody>
</table>
<p>Puedes forzar a GCC a usar uno de estos estándares con el argumento de línea de comandos <code>-std=</code>. Si quieres que sea estricto con el estándar, añade <code>-pedantic</code></p>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-std</span><span class="op">=</span>c11 <span class="at">-pedantic</span> programa.c</span></code></pre></div>
<p>Para este libro, compilo programas para C2x con todas las advertencias activadas:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-Wall</span> <span class="at">-Wextra</span> <span class="at">-std</span><span class="op">=</span>c2x <span class="at">-pedantic</span> programa.c</span></code></pre></div>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="3" id="variables-y-declaraciones"><span class="header-section-number">3</span> Variables y Declaraciones</h1>
<blockquote>
<p><em>“¿Para hacer un mundo se necesitan de todo tipo de personas, ¿no es así, Padre?”</em><br />
<em>“Así es, hijo mío, así es.”</em></p>
<p>—El capitán pirata Thomas Bartholomew Red al Padre, Piratas</p>
</blockquote>
<p>Puede haber muchas cosas en un programa en C.</p>
<p>Sí.</p>
<p>Y por varias razones, será más fácil para todos nosotros si clasificamos algunos de los tipos de cosas que puedes encontrar en un programa, para que podamos ser claros sobre lo que estamos hablando.</p>
<h2 data-number="3.1" id="variables"><span class="header-section-number">3.1</span> Variables</h2>
<p> Se dice que “las variables contienen valores”. Pero otra manera de pensarlo es que una variable es un nombre legible por humanos que se refiere a algún dato en la memoria.</p>
<p>Vamos a tomarnos un momento para echar un vistazo a los punteros. No te preocupes por esto.</p>
<p>Puedes pensar en la memoria como un gran array de bytes<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a>. Los datos se almacenan en este “array”<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a>. Si un número es más grande que un solo byte, se almacena en múltiples bytes. Debido a que la memoria es como un array, cada byte de memoria puede ser referido por su índice. Este índice en la memoria también se llama una <em>dirección</em>, o una <em>ubicación</em>, o un <em> puntero</em>.</p>
<p>Cuando tienes una variable en C, el valor de esa variable está en la memoria en <em>algún lugar</em>, en alguna dirección. Por supuesto. Después de todo, ¿dónde más estaría? Pero es un dolor referirse a un valor por su dirección numérica, así que le damos un nombre en su lugar, y eso es lo que es una variable.</p>
<p>La razón por la que menciono todo esto es doble:</p>
<ol type="1">
<li>Va a hacer que sea más fácil entender las variables de puntero más adelante: ¡son variables que contienen la dirección de otras variables!</li>
<li>También va a hacer que sea más fácil entender los punteros más adelante.</li>
</ol>
<p>Así que una variable es un nombre para algunos datos que están almacenados en la memoria en alguna dirección.</p>
<h3 data-number="3.1.1" id="nombres-de-las-variables"><span class="header-section-number">3.1.1</span> Nombres de las variables</h3>
<p> Puedes usar cualquier carácter en el rango 0-9, A-Z, a-z, y guión bajo para los nombres de variables, con las siguientes reglas:</p>
<ul>
<li>No puedes empezar una variable con un dígito del 0-9.</li>
<li>No puedes empezar un nombre de variable con dos guiones bajos.</li>
<li>No puedes empezar un nombre de variable con un guión bajo seguido de una letra mayúscula de la A-Z.</li>
</ul>
<p>Para Unicode, simplemente pruébalo. Hay algunas reglas en la especificación en §D.2 que hablan sobre qué rangos de puntos de código Unicode están permitidos en qué partes de los identificadores, pero eso es demasiado para escribir aquí y probablemente sea algo en lo que nunca tendrás que pensar de todas formas.</p>
<h3 data-number="3.1.2" id="tipos-de-variables"><span class="header-section-number">3.1.2</span> Tipos de variables</h3>
<p> Dependiendo de los lenguajes que ya tengas en tu repertorio, puedes estar familiarizado o no con la idea de los tipos. Pero C es bastante estricto con ellos, así que deberíamos hacer un repaso.</p>
<p>Algunos ejemplos de tipos, de los más básicos:</p>
<p></p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 41%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: right;">Ejemplo</th>
<th style="text-align: left;">Tipo en C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Entero</td>
<td style="text-align: right;"><code>3490</code></td>
<td style="text-align: left;"><code>int</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Punto flotante</td>
<td style="text-align: right;"><code>3.14159</code></td>
<td style="text-align: left;"><code>float</code><a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Caracter (uno solo)</td>
<td style="text-align: right;"><code>'c'</code></td>
<td style="text-align: left;"><code>char</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Texto</td>
<td style="text-align: right;"><code>"Hola, mundo!"</code></td>
<td style="text-align: left;"><code>char *</code><a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a></td>
</tr>
</tbody>
</table>
<p>C hace un esfuerzo por convertir automáticamente entre la mayoría de los tipos numéricos cuando se lo pides, pero, aparte de eso, todas las conversiones son manuales, en particular entre cadenas y números.</p>
<p>Casi todos los tipos en C son variantes de estos tipos básicos.</p>
<p>Antes de poder usar una variable, debes <em>declarar</em> esa variable y decirle a C qué tipo de datos contiene. Una vez declarada, el tipo de variable no puede cambiarse más tarde durante la ejecución. Lo que estableces es lo que es, hasta que salga de alcance y sea reabsorbida en el universo.</p>
<p>Tomemos nuestro código anterior de “Hola, mundo” y agreguemos un par de variables a él:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="dt">int</span> i<span class="op">;</span>    <span class="co">// Almacena enteros con signo, por ejemplo, -3, -2, 0, 1, 10.</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="dt">float</span> f<span class="op">;</span>  <span class="co">// Almacena números de punto flotante con signo, por ejemplo, -3.1416.</span></span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>    printf<span class="op">(</span><span class="st">&quot;Hello, World!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// Ah, bendita familiaridad</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">}</span></span></code></pre></div>
<p>¡Listo! Hemos declarado un par de variables. Aún no las hemos usado y ambas están sin inicializar. Una contiene un número entero y la otra contiene un número de punto flotante (un número real, si tienes conocimientos de matemáticas).</p>
<p> Las variables no inicializadas tienen un valor indeterminado<a href="#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a>. Deben ser inicializadas o de lo contrario debes asumir que contienen algún número absurdo.</p>
<blockquote>
<p>Este es uno de los puntos donde C puede “atraparte”. En mi experiencia, la mayor parte del tiempo, el valor indeterminado es cero… ¡pero puede variar de ejecución en ejecución! Nunca asumas que el valor será cero, incluso si ves que lo es. <em>Siempre</em> inicializa explícitamente las variables a algún valor antes de usarlas<a href="#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a>.</p>
</blockquote>
<p>¿Qué es esto? ¿Quieres almacenar algunos números en esas variables? ¡Locura!</p>
<p>Vamos a hacer eso ahora mismo: </p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>    i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Asigna el valor 2 dentro de la variable i</span></span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a>    printf<span class="op">(</span><span class="st">&quot;Hello, World!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="op">}</span></span></code></pre></div>
<p>Perfecto. Hemos almacenado un valor. Vamos a imprimirlo.</p>
<p>Lo vamos a hacer pasando dos argumentos asombrosos a la función <code>printf()</code>. El primer argumento es una cadena que describe qué imprimir y cómo imprimirlo (llamado <em>cadena de formato</em> [<em>format string</em>]), y el segundo es el valor a imprimir, es decir, lo que sea que esté en la variable <code>i</code>.</p>
<p><code>printf()</code> busca a través de la cadena de formato en busca de diversas secuencias especiales que comienzan con un signo de porcentaje (<code>%</code>) y que le indican qué imprimir. Por ejemplo, si encuentra <code>%d</code>, busca el siguiente parámetro que se le pasó y lo imprime como un entero. Si encuentra <code>%s</code>, imprime el valor como un flotante. Si encuentra <code>%s</code>, imprime una cadena.</p>
<p>De esta manera, podemos imprimir el valor de varios tipos de la siguiente manera:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="dt">float</span> f <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span>  <span class="co">// char * (&quot;Puntero a caracter&quot;) es del tipo String</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>    </span>
<span id="cb12-9"><a href="#cb12-9"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">  i = </span><span class="sc">%d</span><span class="st"> y f = </span><span class="sc">%f</span><span class="st">!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">,</span> i<span class="op">,</span> f<span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="op">}</span></span></code></pre></div>
<p>Y la salida será:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Hello, world!  i = 2 y f = 3.14!</span></code></pre></div>
<p>De esta manera, <code>printf()</code> podría ser similar a varios tipos de cadenas de formato o cadenas parametrizadas en otros lenguajes con los que estás familiarizado. </p>
<h3 data-number="3.1.3" id="tipo-booleano"><span class="header-section-number">3.1.3</span> Tipo booleano</h3>
<p>¿C tiene tipos booleanos, verdadero o falso?</p>
<p><code>1</code>!</p>
<p>Históricamente, C no tenía un tipo booleano, y algunos podrían argumentar que todavía no lo tiene.</p>
<p>En C, <code>0</code> significa “falso”, y cualquier valor no-cero significa “verdadero”.</p>
<p>Entonces <code>1</code> es verdadero. Y <code>-37</code> es verdadero. Y <code>0</code> es falso.</p>
<p>Puedes simplemente declarar tipos booleanos como <code>int</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;x es verdadero!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Si incluyes <code>#include &lt;stdbool.h&gt;</code>, también obtienes acceso a algunos nombres simbólicos que podrían hacer que las cosas parezcan más familiares, específicamente un tipo <code>bool</code> y los valores <code>true</code> y <code>false</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="dt">bool</span> x <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6"></a></span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="cf">if</span> <span class="op">(</span>x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>        printf<span class="op">(</span><span class="st">&quot;x es verdadero!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="op">}</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="op">}</span></span></code></pre></div>
<p>Pero estos son idénticos a usar valores enteros para verdadero y falso. Son solo una fachada para que las cosas luzcan bien. </p>
<h2 data-number="3.2" id="operadores"><span class="header-section-number">3.2</span> Operadores y Expresiones</h2>
<p>Los operadores de C deberían resultarte familiares si has trabajado con otros lenguajes. Vamos a repasar algunos de ellos aquí.</p>
<p>(Hay muchos más detalles que estos, pero vamos a cubrir lo suficiente en esta sección para comenzar).</p>
<h3 data-number="3.2.1" id="operadores-aritméticos"><span class="header-section-number">3.2.1</span> Operadores aritméticos</h3>
<p>Espero que estos te resulten familiares: </p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">3</span><span class="op">;</span>  <span class="co">// Operadores de adición (+) y asignación (=), suma 3 a i</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">-</span> <span class="dv">8</span><span class="op">;</span>  <span class="co">// Resta, resta 8 a i</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">*</span> <span class="dv">9</span><span class="op">;</span>  <span class="co">// Multiplicación</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">/</span> <span class="dv">2</span><span class="op">;</span>  <span class="co">// División</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">%</span> <span class="dv">5</span><span class="op">;</span>  <span class="co">// Módulo (resto de la división)</span></span></code></pre></div>
<p>Hay variantes abreviadas para todo lo anterior. Cada una de esas líneas podría escribirse de manera más concisa como: </p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="dv">3</span><span class="op">;</span>  <span class="co">// Es igual que &quot;i = i + 3&quot;, Suma 3 a i</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">-=</span> <span class="dv">8</span><span class="op">;</span>  <span class="co">// Es igual que &quot;i = i - 8&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">*=</span> <span class="dv">9</span><span class="op">;</span>  <span class="co">// Es igual que &quot;i = i * 9&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span>  <span class="co">// Es igual que &quot;i = i / 2&quot;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>i <span class="op">%=</span> <span class="dv">5</span><span class="op">;</span>  <span class="co">// Es igual que &quot;i = i % 5&quot;</span></span></code></pre></div>
<p>No hay operador de exponenciación en C. Tendrás que usar una de las variantes de la función <code>pow()</code> de <code>math.h</code>.</p>
<p>¡Vamos a adentrarnos en algunas cosas más extrañas que es posible que no encuentres en tus otros lenguajes! </p>
<h3 data-number="3.2.2" id="operador-ternario"><span class="header-section-number">3.2.2</span> Operador ternario</h3>
<p>C también incluye el <em>operador ternario</em>. Se trata de una expresión cuyo valor depende del resultado de una condición incluida en ella.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Si x &gt; 10, suma 17 a y. De lo contrario suma 37 a y.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">+=</span> x <span class="op">&gt;</span> <span class="dv">10</span><span class="op">?</span> <span class="dv">17</span><span class="op">:</span> <span class="dv">37</span><span class="op">;</span></span></code></pre></div>
<p>¡Qué lío! Te acostumbrarás a medida que lo leas. Para ayudar un poco, reescribiré la expresión anterior usando declaraciones <code>if</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Esta expresión</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">+=</span> x <span class="op">&gt;</span> <span class="dv">10</span><span class="op">?</span> <span class="dv">17</span><span class="op">:</span> <span class="dv">37</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">// es equivalente a esta no-expresión:</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    y <span class="op">+=</span> <span class="dv">17</span><span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    y <span class="op">+=</span> <span class="dv">37</span><span class="op">;</span></span></code></pre></div>
<p>Compara esos dos hasta que veas cada uno de los componentes del operador ternario.</p>
<p>Otro ejemplo, el cual imprime si un número almacenado en <code>x</code> es par o impar sería:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;El número </span><span class="sc">%d</span><span class="st"> es </span><span class="sc">%s</span><span class="st">.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">?</span> <span class="st">&quot;Par :)&quot;</span><span class="op">:</span> <span class="st">&quot;Impar :(&quot;</span><span class="op">);</span></span></code></pre></div>
<p>El especificador de formato <code>%s</code> en <code>printf()</code> significa imprimir una cadena. Si la expresión <code>x % 2</code> se evalúa a <code>0</code>, el valor de toda la expresión ternaria se evalúa a la cadena <code>"Par"</code>. De lo contrario, se evalúa a la cadena <code>"Impar"</code>. ¡Bastante genial!</p>
<p>Es importante señalar, que el operador ternario no es de control de flujo, como lo es la declaración <code>if</code> . Es simplemente una expresión que se evalúa a un valor.</p>
<h3 data-number="3.2.3" id="pre-y-post-incremento-y-decremento"><span class="header-section-number">3.2.3</span> Pre-y-Post Incremento-y-Decremento</h3>
<p> Ahora, vamos a <em>jugar</em> con otra cosa que quizás no hayas visto.</p>
<p>Estos son los legendarios operadores de post-incremento y post-decremento:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>i<span class="op">++;</span>        <span class="co">// Suma uno a i (post-incremento)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>i<span class="op">--;</span>        <span class="co">// Resta uno a i (post-decremento)</span></span></code></pre></div>
<p>Muy comúnmente, estos se utilizan simplemente como versiones más cortas de:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span>        <span class="co">// Suma 1 a i</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span>        <span class="co">// Resta 1 a i</span></span></code></pre></div>
<p>pero los astutos bribones son un poco más sutilmente diferentes que eso.</p>
<p>Echemos un vistazo a esta variante, pre-incremento y pre-decremento:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="op">++</span>i<span class="op">;</span>        <span class="co">// Suma 1 a i (pre-incremento)</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="op">--</span>i<span class="op">;</span>        <span class="co">// Resta 1 a i (pre-decremento)</span></span></code></pre></div>
<p>Con el pre-incremento y pre-decremento, el valor de la variable se incrementa o decrementa <em>antes</em> de evaluar la expresión. Luego, la expresión se evalúa con el nuevo valor.</p>
<p>Con el post-incremento y post-decremento, primero se calcula el valor de la expresión con el valor actual, y <em>luego</em> se incrementa o decrementa el valor después de que se haya determinado el valor de la expresión.</p>
<p>De hecho, puedes incluirlos en expresiones, así:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> i<span class="op">++;</span>  <span class="co">// Calcula 5 + i, _luego_ incrementa i</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span>  <span class="co">// Imprime 11, 15</span></span></code></pre></div>
<p>Comparemos esto con el operador de pre-incremento:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="op">++</span>i<span class="op">;</span>  <span class="co">// Incrementa i, _luego_ calcula 5 + i</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span>  <span class="co">// Imprime 11, 16</span></span></code></pre></div>
<p>Esta técnica se usa frecuentemente con el acceso y la manipulación de arreglos y punteros. Te da una manera de usar el valor en una variable y también incrementar o decrementar ese valor antes o después de que se use.</p>
<p>Pero, con mucho, el lugar más común donde verás esto es en un bucle <code>for</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span></code></pre></div>
<p>Pero hablaremos más sobre eso más adelante. </p>
<h3 data-number="3.2.4" id="el-operador-coma"><span class="header-section-number">3.2.4</span> El operador coma</h3>
<p> Esta es una forma poco común de separar expresiones que se ejecutarán de izquierda a derecha:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>  <span class="co">// Primero asigna 10 a x, luego 20 a y</span></span></code></pre></div>
<p>Parece un poco tonto, ¿verdad? Porque podrías simplemente reemplazar la coma, con un punto y coma, ¿no es así?</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> y <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>  <span class="co">// Primero asigna 10 a x, luego 20 a y</span></span></code></pre></div>
<p>Pero eso es un poco diferente. El segundo caso son dos expresiones separadas, mientras que el primero es una sola expresión.</p>
<p>Con el operador coma, el valor de la expresión coma es el valor de la expresión más a la derecha:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;x is </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// Imprime 3, porque 3 es el que está más a la derecha    </span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// de la lista separada por comas</span></span></code></pre></div>
<p>Pero incluso eso es bastante forzado. Un lugar común donde se usa el operador coma es en los bucles <code>for</code> para hacer múltiples cosas en cada sección de la declaración:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">100</span><span class="op">;</span> i<span class="op">++,</span> j<span class="op">++)</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span></span></code></pre></div>
<p>Volveremos sobre eso más tarde. </p>
<h3 data-number="3.2.5" id="operadores-condicionales"><span class="header-section-number">3.2.5</span> Operadores condicionales</h3>
<p> Para valores booleanos, tenemos una serie de operadores estándar: </p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">==</span> B<span class="op">;</span>  <span class="co">// Verdadero si A es equivalente a B</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">!=</span> B<span class="op">;</span>  <span class="co">// Verdadero si A no es equivalente a B</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">&lt;</span> B<span class="op">;</span>   <span class="co">// Verdadero si A es menor que B</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">&gt;</span> B<span class="op">;</span>   <span class="co">// Verdadero si A es más grande que B</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>A <span class="op">&lt;=</span> B<span class="op">;</span>  <span class="co">// Verdadero si A es menor o igual que B</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>A <span class="op">&gt;=</span> B<span class="op">;</span>  <span class="co">// Verdadero si A es mayor o igual que B</span></span></code></pre></div>
<p>¡No mezcles la asignación <code>=</code> con la comparación <code>==</code>! Usa dos signos iguales para comparar y uno para asignar.</p>
<p>Podemos usar las expresiones de comparación con declaraciones <code>if</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>a <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Exito!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p></p>
<h3 data-number="3.2.6" id="operadores-booleanos"><span class="header-section-number">3.2.6</span> Operadores Booleanos</h3>
<p> Podemos encadenar o combinar expresiones condicionales con operadores booleanos para <em>y</em> (and), <em>o</em> (or), y <em>no</em> (not). </p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Operador</th>
<th style="text-align: center;">Significado booleano</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>&amp;&amp;</code></td>
<td style="text-align: center;">Y (and)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>||</code></td>
<td style="text-align: center;">O (or)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>!</code></td>
<td style="text-align: center;">Negación (not)</td>
</tr>
</tbody>
</table>
<p>Un ejemplo de “y” booleano (and):</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Haz algo si &#39;x&#39; es menor que 10 e &#39;y&#39; es mayor que 20:</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">10</span> <span class="op">&amp;&amp;</span> y <span class="op">&gt;</span> <span class="dv">20</span><span class="op">)</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;¡Haciendo algo!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Un ejemplo de “no” booleano (not):</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!(</span>x <span class="op">&lt;</span> <span class="dv">12</span><span class="op">))</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;x no es menor que 12&quot;</span>\n<span class="st">&quot;);</span></span></code></pre></div>
<p><code>!</code> tiene mayor precedencia que los otros operadores booleanos, por lo que debemos usar paréntesis en ese caso.</p>
<p>Por supuesto, eso es simplemente lo mismo que:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;=</span> <span class="dv">12</span><span class="op">)</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;x no es menor que 12</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Pero necesitaba el ejemplo! </p>
<h3 data-number="3.2.7" id="sizeof-operator"><span class="header-section-number">3.2.7</span> El operador <code>sizeof</code></h3>
<p></p>
<p>Este operador le indica el tamaño (en bytes) que una variable o tipo de datos en particular utiliza en la memoria.</p>
<p>Más particularmente, le indica el tamaño (en bytes) que <em>el tipo de una expresión particular</em> (que podría ser solo una variable) usa en la memoria.</p>
<p>Esto puede ser diferente en distintos sistemas, a excepción de <code>char</code> (que siempre son de 1 byte). </p>
<p>Y puede que esto no parezca muy útil ahora, pero haremos referencias a ello aquí y allá, por lo que vale la pena cubrirlo.</p>
<p>Dado que esto calcula la cantidad de bytes necesarios para almacenar un tipo, se podría pensar que devolvería un <code>int</code>. O… dado que el tamaño no puede ser negativo, tal vez un <code>unsigned</code>?</p>
<p></p>
<p>Pero resulta que C tiene un tipo especial para representar el valor de retorno de <code>sizeof</code>. Es <code>size_t</code>, pronunciado “<em>size tee</em>”<a href="#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a>. Todo lo que sabemos es que es un tipo de entero sin signo que puede contener el tamaño en bytes de cualquier cosa que le des a <code>sizeof</code>.</p>
<p><code>size_t</code> aparece en muchos lugares diferentes donde se pasan o devuelven conteos de cosas. Piénsalo como un valor que representa un conteo. </p>
<p>Puedes tomar el <code>sizeof</code> de una variable o expresión:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">999</span><span class="op">;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co">// %zu es el especificador de formato para el tipo size_t</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> a<span class="op">);</span>      <span class="co">// Imprime 4 en mi sistema</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">7</span><span class="op">));</span> <span class="co">// Imprime 4 en mi sistema</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> <span class="fl">3.14</span><span class="op">);</span>   <span class="co">// Imprime 8 en mi sistema</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Si necesitas imprimir valores negativos de size_t, usa %zd</span></span></code></pre></div>
<p>Recuerda: es el tamaño en bytes del <em>tipo</em> de la expresión, no el tamaño de la expresión en sí. Es por eso que el tamaño de <code>2+7</code> es el mismo que el tamaño de <code>a</code>—ambos son de tipo <code>int</code>. Revisaremos este número <code>4</code> en el próximo bloque de código…</p>
<p>…Donde veremos que puedes obtener el <code>sizeof</code> de un tipo (nota que los paréntesis son requeridos alrededor del nombre de un tipo, a diferencia de una expresión):</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span>   <span class="co">// Imprime 4 en mi sistema</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">));</span>  <span class="co">// Imprime 1 en todos los sistemas</span></span></code></pre></div>
<p>Es importante tener en cuenta que <code>sizeof</code> es una operación en <em>tiempo de compilación</em> <a href="#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a>. El resultado de la expresión se determina completamente en tiempo de compilación, no en tiempo de ejecución.</p>
<p>Más adelante haremos uso de esto.</p>
<p></p>
<h2 data-number="3.3" id="control-de-flujo"><span class="header-section-number">3.3</span> Control de flujo</h2>
<p> Los booleanos son buenos, pero por supuesto, no llegaríamos a ninguna parte si no pudiéramos controlar el flujo del programa. Echemos un vistazo a varios constructos: <code>if</code>, <code>for</code>,<code>while</code>, y <code>do-while</code>.</p>
<p>Primero, una nota general anticipada sobre declaraciones y bloques de declaraciones, cortesía de tu amigable desarrollador de C local:</p>
<p>Después de algo como una declaración <code>if</code> o <code>while</code>, puedes colocar ya sea una sola declaración que se ejecutará, o un bloque de declaraciones que se ejecutarán en secuencia.</p>
<p> Comencemos con una sola declaración:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="dv">10</span><span class="op">)</span> printf<span class="op">(</span><span class="st">&quot;x es 10</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Esto también a veces se escribe en una línea separada. (Los espacios en blanco son en gran medida irrelevantes en C—no es como en Python.)</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;x es 10</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Pero ¿qué pasa si quieres que ocurran varias cosas debido a la condición? Puedes usar llaves para marcar un <em>bloque</em> o <em>declaración compuesta</em>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;x es 10</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Y también esto ocurre cuando x es 10</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Es un estilo muy común <em>siempre</em> usar llaves incluso si no son necesarias:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;x es 10</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Algunos desarrolladores sienten que el código es más fácil de leer y evita errores como este, donde visualmente parece que las cosas están dentro del bloque <code>if</code>, pero en realidad no lo están.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">// EJEMPLO DE ERROR GRAVE</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Esto sucede si x es 10</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Esto sucede SIEMPRE</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="co">// ¡Sorpresa! ¡Incondicional!</span></span></code></pre></div>
<p><code>while</code>, <code>for</code> y los demás constructos de bucles funcionan de la misma manera que los ejemplos anteriores. Si deseas hacer múltiples cosas en un bucle o después de un <code>if</code>, envuélvelas en llaves.</p>
<p>En otras palabras, el <code>if</code> ejecutará lo que esté después de él. Y eso puede ser una sola declaración o un bloque de declaraciones.</p>
<p></p>
<h3 data-number="3.3.1" id="ifstat"><span class="header-section-number">3.3.1</span> El estado <code>if</code>-<code>else</code></h3>
<p> Ya hemos estado usando <code>if</code> en varios ejemplos, ya que es probable que lo hayas visto en algún lenguaje antes, pero aquí tienes otro:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Sí, i es mayor que 10.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Y esto también se imprimirá si i es mayor que 10.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">)</span> printf<span class="op">(</span><span class="st">&quot;i es menor o igual que 10.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>En el código de ejemplo, el mensaje se imprimirá si <code>i</code> es mayor que 10, de lo contrario, la ejecución continúa en la siguiente línea. Observa las llaves después de la instrucción <code>if</code>; si la condición es verdadera, se ejecutará la primera instrucción o expresión justo después del if, o bien, se ejecutará el conjunto de código dentro de las llaves después del if. Este tipo de comportamiento de <em>bloque de código</em> es común en todas las instrucciones.</p>
<p>Por supuesto, dado que C es divertido de esta manera, también puedes hacer algo si la condición es <code>else</code> con una cláusula <code>else</code> en tu <code>if</code>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">99</span><span class="op">;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es 10!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i definitivamente no es 10.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Que, francamente, me irrita un poco.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Y puedes incluso encadenar estos para probar una variedad de condiciones, como esto:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">99</span><span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es 10!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">20</span><span class="op">)</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es 20!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">99</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es 99! Mi favorito</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;No puedo decirte lo feliz que estoy.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;En serio.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es algún número loco que nunca he escuchado antes.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Si vas por ese camino, asegúrate de revisar la declaración <a href="#switch-statement"><code>switch</code></a> para una solución potencialmente mejor. La única limitación es que <code>switch</code> solo funciona con comparaciones de igualdad con números constantes. La cascada <code>if</code>-<code>else</code> anterior podría verificar desigualdades, rangos, variables o cualquier otra cosa que puedas crear en una expresión condicional. </p>
<h3 data-number="3.3.2" id="whilestat"><span class="header-section-number">3.3.2</span> La declaración <code>while</code></h3>
<p> La declaración <code>while</code> es simplemente un bucle promedio y corriente. Realiza una acción mientras una expresión de condición sea verdadera.</p>
<p>¡Hagamos uno!</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Imprime la siguiente salida:</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co">// i es ahora 0!</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">// i es ahora 1!</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co">// [ más de lo mismo entre 2 y 7 ]</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">// i es ahora 8!</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co">// i es ahora 9!</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es ahora </span><span class="sc">%d</span><span class="st">!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;¡Todo hecho!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Así se obtiene un bucle básico. C también tiene un bucle <code>for</code> que habría sido más limpio para ese ejemplo.</p>
<p>Un uso no poco común de <code>while</code> es para bucles infinitos donde se repite mientras es verdadero:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;1 es siempre cierto, así que esto se repite para siempre.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h3 data-number="3.3.3" id="dowhilestat"><span class="header-section-number">3.3.3</span> La sentencia <code>do-while</code></h3>
<p> Ahora que ya tenemos la sentencia <code>while</code> bajo control, echemos un vistazo a su prima, <code>do-while</code>.</p>
<p>Básicamente son lo mismo, excepto que si la condición del bucle es falsa en el primer paso, <code>do-while</code> se ejecutará una vez, pero <code>while</code> no se ejecutará en absoluto. En otras palabras, la prueba para ver si se debe ejecutar o no el bloque ocurre al <em>final</em> del bloque con <code>do-while</code>. Ocurre al <em>principio</em> del bloque con <code>while</code>.</p>
<p>Veámoslo con un ejemplo:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Utilizar una sentencia while:</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Esto no se ejecuta, porque i no es menor que 10:</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;while: i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Utilizar una sentencia do-while:</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Se ejecuta una vez, porque la condición del bucle no se comprueba hasta</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a><span class="co">// después de que se ejecute el cuerpo del bucle:</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;do-while: i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;¡Todo hecho!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Observa que en ambos casos, la condición del bucle es falsa inmediatamente. Así que en el <code>while</code>, el bucle falla, y el siguiente bloque de código nunca se ejecuta. Con el <code>do-while</code>, sin embargo, la condición se comprueba <em>después</em> de que se ejecute el bloque de código, por lo que siempre se ejecuta al menos una vez. En este caso, imprime el mensaje, incrementa <code>i</code>, falla la condición y continúa con la salida “¡Todo hecho!</p>
<p>La moraleja de la historia es la siguiente: si quieres que el bucle se ejecute al menos una vez, sin importar la condición del bucle, usa <code>do-while</code>.</p>
<p>Todos estos ejemplos podrían haberse hecho mejor con un bucle <code>for</code>. Hagamos algo menos determinista: ¡repetir hasta que salga un cierto número aleatorio!</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp">   </span><span class="co">// Para printf</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span><span class="pp">  </span><span class="co">// Para rand</span></span>
<span id="cb49-3"><a href="#cb49-3"></a></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="op">{</span></span>
<span id="cb49-6"><a href="#cb49-6"></a>    <span class="dt">int</span> r<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7"></a></span>
<span id="cb49-8"><a href="#cb49-8"></a>    <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb49-9"><a href="#cb49-9"></a>        r <span class="op">=</span> rand<span class="op">()</span> <span class="op">%</span> <span class="dv">100</span><span class="op">;</span> <span class="co">// Obtener un número aleatorio entre 0 y 99</span></span>
<span id="cb49-10"><a href="#cb49-10"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> r<span class="op">);</span></span>
<span id="cb49-11"><a href="#cb49-11"></a>    <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>r <span class="op">!=</span> <span class="dv">37</span><span class="op">);</span>    <span class="co">// Repetir hasta que aparezca 37</span></span>
<span id="cb49-12"><a href="#cb49-12"></a><span class="op">}</span></span></code></pre></div>
<p>Nota al margen: ¿lo has hecho más de una vez? Si lo hiciste, ¿te diste cuenta de que volvió a aparecer la misma secuencia de números? Y otra vez. ¿Y otra vez? Esto se debe a que <code>rand()</code> es un generador de números pseudoaleatorios que debe ser <em>sembrado</em> con un número diferente para generar una secuencia diferente. Busque el <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-srand"><code>srand()</code></a><a href="#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a> para más detalles. </p>
<h3 data-number="3.3.4" id="forstat"><span class="header-section-number">3.3.4</span> La sentencia `for</h3>
<p></p>
<p>¡Bienvenido a uno de los bucles más populares del mundo! ¡El bucle <code>for</code>!</p>
<p>Este es un gran bucle si sabes de antemano el número de veces que quieres hacer el bucle.</p>
<p>Podrías hacer lo mismo usando sólo un bucle <code>while</code>, pero el bucle <code>for</code> puede ayudar a mantener el código más limpio.</p>
<p>Aquí hay dos trozos de código equivalente—note cómo el bucle <code>for</code> es sólo una representación más compacta:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Imprime los números entre 0 y 9, ambos inclusive...</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Usando una sentencia while:</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="co">//Haz exactamente lo mismo con un bucle for:</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Así es, hacen exactamente lo mismo. Pero puedes ver cómo la sentencia <code>for</code> es un poco compacta y agradable a la vista. (Los usuarios de JavaScript apreciarán plenamente sus orígenes en C en este punto).</p>
<p>Está dividida en tres partes, separadas por punto y coma. La primera es la inicialización, la segunda es la condición del bucle, y la tercera es lo que debe ocurrir al final del bloque si la condición del bucle es verdadera. Estas tres partes son opcionales.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>inicializar cosas<span class="op">;</span> bucle si esto es cierto<span class="op">;</span> hacer esto después de cada bucle<span class="op">)</span></span></code></pre></div>
<p>Tenga en cuenta que el bucle no se ejecutará ni una sola vez si la condición del bucle comienza siendo falsa.</p>
<blockquote>
<p><strong>Curiosidad del bucle `for</strong></p>
<p>Puedes usar el operador coma para hacer múltiples cosas en cada cláusula del bucle <code>for</code>.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> <span class="dv">999</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++,</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Un <code>for</code> vacío se ejecutará eternamente:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(;;)</span> <span class="op">{</span>  <span class="co">// &quot;for-ever&quot; (para-siempre)</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Imprimiré esto una y otra y otra vez</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">);</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Por toda la eternidad hasta la muerte por calor del universo.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;O hasta que pulses CTRL-C.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h3 data-number="3.3.5" id="switch-statement"><span class="header-section-number">3.3.5</span> Declaración <code>switch</code></h3>
<p> Dependiendo del lenguaje del que vengas, puede que estés o no familiarizado con <code>switch</code>, o incluso puede que la versión de C sea más restrictiva de lo que estás acostumbrado. Esta es una sentencia que te permite tomar una variedad de acciones dependiendo del valor de una expresión entera.</p>
<p>Básicamente, evalúa una expresión a un valor entero, salta al <code>case</code> que corresponde a ese valor. La ejecución se reanuda desde ese punto. Si se encuentra una sentencia <code>break</code>, la ejecución salta fuera del <code>switch</code>.</p>
<p>He aquí un ejemplo en el que, para un número determinado de cabras, imprimimos una intuición de cuántas cabras son.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb54-2"><a href="#cb54-2"></a></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="op">{</span></span>
<span id="cb54-5"><a href="#cb54-5"></a>    <span class="dt">int</span> goat_count <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// goat_count = contador de cabras</span></span>
<span id="cb54-6"><a href="#cb54-6"></a></span>
<span id="cb54-7"><a href="#cb54-7"></a>    <span class="cf">switch</span> <span class="op">(</span>goat_count<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-8"><a href="#cb54-8"></a>        <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb54-9"><a href="#cb54-9"></a>            printf<span class="op">(</span><span class="st">&quot;No tienes cabras :(</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb54-10"><a href="#cb54-10"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb54-11"><a href="#cb54-11"></a></span>
<span id="cb54-12"><a href="#cb54-12"></a>        <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb54-13"><a href="#cb54-13"></a>            printf<span class="op">(</span><span class="st">&quot;Solo tienes una cabra</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb54-14"><a href="#cb54-14"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb54-15"><a href="#cb54-15"></a></span>
<span id="cb54-16"><a href="#cb54-16"></a>        <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb54-17"><a href="#cb54-17"></a>            printf<span class="op">(</span><span class="st">&quot;Tienes un par de cabras</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb54-18"><a href="#cb54-18"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb54-19"><a href="#cb54-19"></a></span>
<span id="cb54-20"><a href="#cb54-20"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb54-21"><a href="#cb54-21"></a>            printf<span class="op">(</span><span class="st">&quot;¡Tienes una gran cantidad de cabras!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb54-22"><a href="#cb54-22"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb54-23"><a href="#cb54-23"></a>    <span class="op">}</span></span>
<span id="cb54-24"><a href="#cb54-24"></a><span class="op">}</span></span></code></pre></div>
<p>En ese ejemplo, el <code>switch</code> saltará al <code>case 2</code> y ejecutará desde allí. Cuando (si) llega a un <code>break</code>, salta fuera del <code>switch</code>. </p>
<p>Además, puede que veas la etiqueta <code>default</code> en la parte inferior. Esto es lo que ocurre cuando ningún caso coincide.</p>
<p>Cada <code>case</code>, incluyendo <code>default</code>, es opcional. Y pueden ocurrir en cualquier orden, pero es realmente típico que <code>default</code>, si lo hay, aparezca último. </p>
<p>Así que todo actúa como una cascada <code>if</code>-<code>else</code>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>goat_count <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;No tienes cabras</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>goat_count <span class="op">==</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Tienes solo una cabra.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>goat_count <span class="op">==</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Tienes un par de cabras.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Tienes una gran cantidad de cabras!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Con algunas diferencias clave:</p>
<ul>
<li>A menudo, <code>switch</code> es más rápido para saltar al código correcto (aunque la especificación no lo garantiza).</li>
<li><code>if</code>-<code>else</code> puede hacer cosas como condicionales relacionales como <code>&lt;</code> y <code>&gt;=</code> y punto flotante y otros tipos, mientras que <code>switch</code> no puede.</li>
</ul>
<p>Hay una cosa más sobre switch que a veces se ve y que es bastante interesante: <em>falla de salida</em> (<em>fall through</em>).</p>
<p> ¿Recuerdas que <code>break</code> nos hace saltar fuera del switch?</p>
<p> Bueno, ¿qué pasa si <em>no se utiliza</em> <code>break</code>?</p>
<p>¡Resulta que seguimos con el siguiente <code>case</code>! ¡Demo!</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Falla el salto! Sigue ejecutando!</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;2</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Si <code>x == 1</code>, el <code>switch</code> irá primero al <code>caso 1</code>, imprimirá el <code>1</code>, pero luego simplemente continúa con la siguiente línea de código… ¡que imprime <code>2</code>!</p>
<p>Y entonces, por fin, llegamos a un <code>break</code> así que saltamos del <code>switch</code>.</p>
<p>si <code>x == 2</code>, entonces simplemente entramos dentro del <code>case 2</code>, imprimimos <code>2</code>, y <code>break</code> como es normal.</p>
<p>Al no tener un <code>break</code> se <em>falla la salida</em>.</p>
<p>Consejo de experto: <em>Siempre</em> ponga un comentario en el código en el que tiene intención de fallar la salida, como he hecho yo más arriba. Evitará que otros programadores se pregunten si realmente querías hacer eso. </p>
<p>De hecho, este es uno de los lugares comunes para introducir errores en los programas en C: olvidar poner un <code>break</code> en tu <code>case</code>. Tienes que hacerlo si no quieres simplemente pasar al siguiente caso<a href="#fn41" class="footnote-ref" id="fnref41" role="doc-noteref"><sup>41</sup></a>. </p>
<p>Antes dije que <code>switch</code> funciona con tipos enteros– mantenlo así. No utilices tipos de coma flotante o cadenas. Una laguna legal aquí es que puedes usar tipos de caracteres porque estos son secretamente números enteros. Por lo tanto, esto es perfectamente aceptable:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c <span class="op">=</span> <span class="ch">&#39;b&#39;</span><span class="op">;</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="ch">&#39;a&#39;</span><span class="op">:</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;La letra es &#39;a&#39;!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="ch">&#39;b&#39;</span><span class="op">:</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;La letra es &#39;b&#39;!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="ch">&#39;c&#39;</span><span class="op">:</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;La letra es &#39;c&#39;!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Finalmente, puedes usar <code>enum</code> en <code>switch</code> ya que también son tipos enteros. Pero más sobre esto en el capítulo <code>enum</code>.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="4" id="functions"><span class="header-section-number">4</span> Funciones</h1>
<blockquote>
<p>“Señor, no en un ambiente como éste. Por eso también he sido programado para más de treinta funciones secundarias que…”_&gt;</p>
<p>—C3PO, antes de ser interrumpido bruscamente, informando de un número ya poco impresionante de funciones adicionales, <em>Star Wars</em> script </p>
</blockquote>
<p>Muy parecido a otros lenguajes a los que estás acostumbrado, C tiene el concepto de <em>funciones</em>.</p>
<p>Las funciones pueden aceptar una variedad de <em>argumentos</em> y devolver un valor. Sin embargo, hay algo importante: los tipos de argumentos y valores de retorno están predeclarados,—¡porque así lo prefiere C!</p>
<p>Veamos una función. Esta es una función que toma un <code>int</code> como argumento, y devuelve un <code>int</code>.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb58-2"><a href="#cb58-2"></a></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="dt">int</span> plus_one<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span>  <span class="co">// La &quot;Definición&quot;</span></span>
<span id="cb58-4"><a href="#cb58-4"></a><span class="op">{</span></span>
<span id="cb58-5"><a href="#cb58-5"></a>    <span class="cf">return</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="op">}</span></span>
<span id="cb58-7"><a href="#cb58-7"></a> </span></code></pre></div>
<p>El <code>int</code> antes del <code>plus_one</code> indica el tipo de retorno.</p>
<p>El <code>int n</code> indica que esta función toma un argumento <code>int</code>, almacenado en el <em>parámetro</em> <code>n</code>. Un parámetro es un tipo especial de variable local en la que se copian los argumentos.</p>
<p>Voy a insistir en que los argumentos se copian en los parámetros. Muchas cosas en C son más fáciles de entender si sabes que el parámetro es una <em>copia</em> del argumento, no el argumento en sí. Más sobre esto en un minuto.</p>
<p>Continuando el programa hasta <code>main()</code>, podemos ver la llamada a la función, donde asignamos el valor de retorno a la variable local <code>j</code>:</p>
<div class="sourceCode" id="cb59" data-startFrom="8"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 7;"><span id="cb59-8"><a href="#cb59-8"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb59-9"><a href="#cb59-9"></a><span class="op">{</span></span>
<span id="cb59-10"><a href="#cb59-10"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> j<span class="op">;</span></span>
<span id="cb59-11"><a href="#cb59-11"></a>    </span>
<span id="cb59-12"><a href="#cb59-12"></a>    j <span class="op">=</span> plus_one<span class="op">(</span>i<span class="op">);</span>  <span class="co">// La &quot;llamada&quot;</span></span>
<span id="cb59-13"><a href="#cb59-13"></a></span>
<span id="cb59-14"><a href="#cb59-14"></a>    printf<span class="op">(</span><span class="st">&quot;i + 1 es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb59-15"><a href="#cb59-15"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Antes de que se me olvide, fíjate en que he definido la función antes de usarla. Si no lo hubiera hecho, el compilador aún no la conocería al compilar <code>main()</code> y habría dado un error de llamada a función desconocida. Hay una forma más adecuada de hacer el código anterior con <em>prototipos de función</em>, pero hablaremos de eso más adelante.</p>
</blockquote>
<p>Observa también que <code>main()</code> ¡es una función!</p>
<p>Devuelve un <code>int</code>.</p>
<p>¿Pero qué es eso de <code>void</code>? Es una palabra clave para indicar que la función no acepta argumentos.</p>
<p>También puede devolver <code>void</code> para indicar que no devuelve ningún valor:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb60-2"><a href="#cb60-2"></a></span>
<span id="cb60-3"><a href="#cb60-3"></a><span class="co">// Esta función no toma argumentos y no devuelve ningún valor:</span></span>
<span id="cb60-4"><a href="#cb60-4"></a></span>
<span id="cb60-5"><a href="#cb60-5"></a><span class="dt">void</span> hello<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb60-6"><a href="#cb60-6"></a><span class="op">{</span></span>
<span id="cb60-7"><a href="#cb60-7"></a>    printf<span class="op">(</span><span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb60-8"><a href="#cb60-8"></a><span class="op">}</span></span>
<span id="cb60-9"><a href="#cb60-9"></a></span>
<span id="cb60-10"><a href="#cb60-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb60-11"><a href="#cb60-11"></a><span class="op">{</span></span>
<span id="cb60-12"><a href="#cb60-12"></a>    hello<span class="op">();</span>  <span class="co">// Imprime &quot;Hello, world!&quot;</span></span>
<span id="cb60-13"><a href="#cb60-13"></a><span class="op">}</span></span></code></pre></div>
<h2 data-number="4.1" id="passvalue"><span class="header-section-number">4.1</span> Transmisión por valor</h2>
<p>He mencionado antes que cuando pasas un argumento a una función, se hace una copia de ese argumento y se almacena en el parámetro correspondiente.</p>
<p>Si el argumento es una variable, se hace una copia del valor de esa variable y se almacena en el parámetro.</p>
<p>De forma más general, se evalúa toda la expresión del argumento y se determina su valor. Ese valor se copia en el parámetro.</p>
<p>En cualquier caso, el valor del parámetro es algo propio. Es independiente de los valores o variables que hayas utilizado como argumentos al llamar a la función.</p>
<p>Veamos un ejemplo. Estúdielo y vea si puede determinar la salida antes de ejecutarlo:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2"></a></span>
<span id="cb61-3"><a href="#cb61-3"></a><span class="dt">void</span> increment<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span></span>
<span id="cb61-4"><a href="#cb61-4"></a><span class="op">{</span></span>
<span id="cb61-5"><a href="#cb61-5"></a>    a<span class="op">++;</span></span>
<span id="cb61-6"><a href="#cb61-6"></a><span class="op">}</span></span>
<span id="cb61-7"><a href="#cb61-7"></a></span>
<span id="cb61-8"><a href="#cb61-8"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb61-9"><a href="#cb61-9"></a><span class="op">{</span></span>
<span id="cb61-10"><a href="#cb61-10"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb61-11"><a href="#cb61-11"></a></span>
<span id="cb61-12"><a href="#cb61-12"></a>    increment<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb61-13"><a href="#cb61-13"></a></span>
<span id="cb61-14"><a href="#cb61-14"></a>    printf<span class="op">(</span><span class="st">&quot;i == </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>  <span class="co">// ¿Qué imprime esto?</span></span>
<span id="cb61-15"><a href="#cb61-15"></a><span class="op">}</span></span></code></pre></div>
<p>A primera vista, parece que <code>i</code> es <code>10</code>, y lo pasamos a la función <code>increment()</code>. Allí el valor se incrementa, así que cuando lo imprimimos, debe ser <code>11</code>, ¿no?</p>
<blockquote>
<p>“Acostúmbrate a la decepción.”</p>
<p>—El temible pirata Roberts, La princesa prometida</p>
</blockquote>
<p>Pero no es <code>11</code>… ¡imprime <code>10</code>! ¿Cómo?</p>
<p>Se trata de que las expresiones que pasas a las funciones se <em>copian</em> en sus parámetros correspondientes. El parámetro es una copia, no el original</p>
<p>Así que <code>i</code> es <code>10</code> en <code>main()</code>. Y se lo pasamos a <code>increment()</code>. El parámetro correspondiente se llama <code>a</code> en esa función.</p>
<p>Y la copia ocurre, como si fuera una asignación. Más o menos, <code>a = i</code>. Así que en ese punto, <code>a</code> es <code>10</code>. Y en <code>main()</code>, <code>i</code> es también <code>10</code>.</p>
<p>Entonces incrementamos <code>a</code> a <code>11</code>. ¡Pero no estamos tocando <code>i</code> en absoluto! Sigue siendo <code>10</code>.</p>
<p>Finalmente, la función está completa. Todas sus variables locales se descartan (¡adiós, <code>a</code>!) y volvemos a <code>main()</code>, donde <code>i</code> sigue siendo <code>10</code>.</p>
<p>Y lo imprimimos, obteniendo <code>10</code>, y hemos terminado.</p>
<p>Por eso en el ejemplo anterior con la función <code>plus_one()</code>, <code>devolvíamos</code> el valor modificado localmente para poder verlo de nuevo en <code>main()</code>.</p>
<p>Parece un poco restrictivo, ¿no? Como si sólo pudieras recuperar un dato de una función, es lo que estás pensando. Hay, sin embargo, otra forma de recuperar datos; la gente de C lo llama <em>pasar por referencia</em> y esa es una historia que contaremos en otra ocasión.</p>
<p>Pero ningún nombre rimbombante te distraerá del hecho de que <em>TODO</em> lo que pasas a una función <em>SIN EXCEPCIÓN</em> se copia en su parámetro correspondiente, y la función opera sobre esa copia local, <em>NO IMPORTA QUÉ</em>. Recuérdalo, incluso cuando estemos hablando del llamado paso por referencia. </p>
<h2 data-number="4.2" id="prototypes"><span class="header-section-number">4.2</span> Prototipos de funciones</h2>
<p>Así que si recuerdas en la edad de hielo hace unas secciones, mencioné que tenías que definir la función antes de usarla, de lo contrario el compilador no lo sabría de antemano, y bombardearía con un error.</p>
<p>Esto no es estrictamente cierto. Puedes notificar al compilador por adelantado que vas a utilizar una función de un tipo determinado que tiene una lista de parámetros determinada. De esta forma, la función puede definirse en cualquier lugar (incluso en un fichero diferente), siempre que el <em>prototipo de función</em> haya sido declarado antes de llamar a esa función.</p>
<p>Afortunadamente, el prototipo de función es realmente sencillo. Es simplemente una copia de la primera línea de la definición de la función con un punto y coma al final. Por ejemplo, este código llama a una función que se define más tarde, porque primero se ha declarado un prototipo:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb62-2"><a href="#cb62-2"></a></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="dt">int</span> foo<span class="op">(</span><span class="dt">void</span><span class="op">);</span>  <span class="co">// Esto es el prototipo!</span></span>
<span id="cb62-4"><a href="#cb62-4"></a></span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb62-6"><a href="#cb62-6"></a><span class="op">{</span></span>
<span id="cb62-7"><a href="#cb62-7"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb62-8"><a href="#cb62-8"></a>    </span>
<span id="cb62-9"><a href="#cb62-9"></a>    <span class="co">// Podemos llamar aquí a foo() antes de su definición porque el</span></span>
<span id="cb62-10"><a href="#cb62-10"></a>    <span class="co">// prototipo ya ha sido declarado, ¡arriba!</span></span>
<span id="cb62-11"><a href="#cb62-11"></a></span>
<span id="cb62-12"><a href="#cb62-12"></a>    i <span class="op">=</span> foo<span class="op">();</span></span>
<span id="cb62-13"><a href="#cb62-13"></a>    </span>
<span id="cb62-14"><a href="#cb62-14"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>  <span class="co">// 3490</span></span>
<span id="cb62-15"><a href="#cb62-15"></a><span class="op">}</span></span>
<span id="cb62-16"><a href="#cb62-16"></a></span>
<span id="cb62-17"><a href="#cb62-17"></a><span class="dt">int</span> foo<span class="op">(</span><span class="dt">void</span><span class="op">)</span>  <span class="co">// ¡Esta es la definición, igual que el prototipo!</span></span>
<span id="cb62-18"><a href="#cb62-18"></a><span class="op">{</span></span>
<span id="cb62-19"><a href="#cb62-19"></a>    <span class="cf">return</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb62-20"><a href="#cb62-20"></a><span class="op">}</span></span></code></pre></div>
<p>Si no declaras tu función antes de usarla (ya sea con un prototipo o con su definición), estás realizando algo llamado <em>declaración implícita</em>.Esto estaba permitido en el primer estándar C (C89), y ese estándar tiene reglas al respecto, pero ya no está permitido hoy en día. Y no hay ninguna razón legítima para confiar en ello en código nuevo.</p>
<p>Puede que notes algo en el código de ejemplo que hemos estado utilizando… Es decir, ¡hemos estado usando la vieja función <code>printf()</code> sin definirla ni declarar un prototipo! ¿Cómo nos libramos de esta ilegalidad? En realidad, no lo hacemos. Hay un prototipo; está en ese fichero de cabecera <code>stdio.h</code> que incluimos con <code>#include</code>, ¿recuerdas? ¡Así que seguimos siendo legales, oficial! </p>
<h2 data-number="4.3" id="listas-de-parámetros-vacías"><span class="header-section-number">4.3</span> Listas de parámetros vacías</h2>
<p>Es posible que los veas de vez en cuando en código antiguo, pero nunca deberías usar uno en código nuevo. Usa siempre <code>void</code> para indicar que una función no toma parámetros. Nunca hay<a href="#fn42" class="footnote-ref" id="fnref42" role="doc-noteref"><sup>42</sup></a> una razón para omitir esto en código moderno.</p>
<p>Si eres bueno recordando poner <code>void</code> para listas de parámetros vacías en funciones y prototipos, puedes saltarte el resto de esta sección.</p>
<p>Hay dos contextos para esto:</p>
<ul>
<li>Omitir todos los parámetros donde se define la función</li>
<li>Omitir todos los parámetros en un prototipo</li>
</ul>
<p>Veamos primero una posible definición de función:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">()</span>  <span class="co">// Realmente debería tener un `void` ahí</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Aunque la especificación dice que el comportamiento en este caso es <em>como si</em> hubieras indicado <code>void</code> (C11§6.7.6.3¶14), el tipo <code>void</code> está ahí por una razón. Utilícelo.</p>
<p>Pero en el caso de un prototipo de función, hay una diferencia <em>significativa</em> entre usar <code>void</code> y no:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">();</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">void</span><span class="op">);</span>  <span class="co">// ¡No es lo mismo!</span></span></code></pre></div>
<p>Dejar <code>void</code> fuera del prototipo indica al compilador que no hay información adicional sobre los parámetros de la función. De hecho, desactiva toda la comprobación de tipos.</p>
<p>Con un prototipo <strong>definitivamente</strong> use <code>void</code> cuando tenga una lista de parámetros vacía.</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="5" id="pointers"><span class="header-section-number">5</span> Punteros… ¡Poder con miedo!</h1>
<blockquote>
<p><em>“¿Cómo llegas al Carnegie Hall?”</em><br />
<em>“Practica!”</em></p>
<p>—Chiste del siglo XX de origen desconocido</p>
</blockquote>
<p>Los punteros son una de las cosas más temidas del lenguaje C. De hecho, son lo único que hace que este lenguaje sea todo un reto. ¿Por qué?</p>
<p>Porque, sinceramente, pueden provocar descargas eléctricas que salgan por el teclado y te <em>suelden</em> los brazos de forma permanente, ¡maldiciéndote a una vida al teclado en este idioma de los años 70!</p>
<p>¿De verdad? Bueno, en realidad no. Sólo estoy tratando de prepararte para el éxito.</p>
<p>Dependiendo del lenguaje del que provengas, puede que ya entiendas el concepto de <em>referencias</em>, donde una variable hace referencia a un objeto de algún tipo.</p>
<p>Esto es muy parecido, salvo que tenemos que ser más explícitos con C sobre cuándo estamos hablando de la referencia o de la cosa a la que se refiere.</p>
<h2 data-number="5.1" id="ptmem"><span class="header-section-number">5.1</span> Memoria y variables</h2>
<p>La memoria del ordenador contiene datos de todo tipo, ¿verdad? Contendrá <code>float</code>s, <code>int</code>s, o lo que tengas. Para facilitar el manejo de la memoria, cada byte de memoria se identifica con un número entero. Estos enteros aumentan secuencialmente a medida que avanzas en la memoria<a href="#fn43" class="footnote-ref" id="fnref43" role="doc-noteref"><sup>43</sup></a>. Puedes pensar en ello como un montón de cajas numeradas, donde cada caja contiene un byte<a href="#fn44" class="footnote-ref" id="fnref44" role="doc-noteref"><sup>44</sup></a> de datos. O como un gran array donde cada elemento contiene un byte, si vienes de un lenguaje con arrays. El número que representa cada casilla se llama <em>dirección</em>.</p>
<p>Ahora bien, no todos los tipos de datos utilizan sólo un byte. Por ejemplo, un <code>int</code> suele tener cuatro bytes, al igual que un <code>float</code>, pero en realidad depende del sistema. Puedes utilizar el operador <code>sizeof</code> para determinar cuántos bytes de memoria utiliza un determinado tipo.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">// %zu es el especificador de formato para el tipo size_t</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Un int utiliza </span><span class="sc">%zu</span><span class="st"> bytes de memoria</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="co">// A mí me imprime &quot;4&quot;, pero puede variar según el sistema.</span></span></code></pre></div>
<blockquote>
<p><strong>Datos curiosos sobre la memoria</strong>: Cuando tienes un tipo de datos (como el típico <code>int</code>) que utiliza más de un byte de memoria, los bytes que componen los datos son siempre adyacentes en memoria. A veces están en el orden que esperas, y a veces no<a href="#fn45" class="footnote-ref" id="fnref45" role="doc-noteref"><sup>45</sup></a>. Aunque C no garantiza ningún orden de memoria en particular (depende de la plataforma), en general es posible escribir código de forma independiente de la plataforma sin tener que tener en cuenta estos molestos ordenamientos de bytes.</p>
</blockquote>
<p>Así que, de todos modos, si podemos ponernos manos a la obra y poner un redoble de tambores y algo de música premonitoria para la definición de puntero, <em>un puntero es una variable que contiene una dirección</em>. Imagina la partitura clásica de 2001: Una Odisea del Espacio en este punto. Ba bum ba bum ba bum ¡BAAAAH!</p>
<p>Vale, quizás un poco exagerado, ¿no? No hay mucho misterio sobre los punteros. Son la dirección de los datos. Al igual que una variable <code>int</code> puede contener el valor <code>12</code>, una variable puntero puede contener la dirección de los datos.</p>
<p>Esto significa que todas estas cosas son lo mismo, es decir, un número que representa un punto en la memoria:</p>
<ul>
<li>Índice en memoria (si piensas en la memoria como una gran matriz)</li>
<li>Dirección</li>
<li>Ubicación</li>
</ul>
<p>Voy a usarlos indistintamente. Y sí, acabo de incluir <em>localización</em> porque nunca hay suficientes palabras que signifiquen lo mismo.</p>
<p>Y una variable puntero contiene ese número de dirección. Al igual que una variable <code>float</code> puede contener <code>3.14159</code>.</p>
<p>Imagina que tienes un montón de notas Post-it® numeradas en secuencia con su dirección. (La primera está en el índice numerado <code>0</code>, la siguiente en el índice <code>1</code>, y así sucesivamente).</p>
<p>Además del número que representa su posición, también puedes escribir otro número de tu elección en cada uno. Puede ser el número de perros que tienes. O el número de lunas alrededor de Marte…</p>
<p>…O, <em>podría ser el índice de otra nota Post-it</em></p>
<p>Si has escrito el número de perros que tienes, eso es sólo una variable normal. Pero si has escrito ahí el índice de otro Post-it, <em>eso es un puntero</em>. ¡Apunta a la otra nota!</p>
<p>Otra analogía podría ser con las direcciones de las casas. Puedes tener una casa con ciertas cualidades, patio, tejado metálico, solar, etc. O puedes tener la dirección de esa casa. La dirección no es lo mismo que la casa en sí. Una es una casa completa, y la otra son sólo unas líneas de texto. Pero la dirección de la casa es un <em>puntero</em> a esa casa. No es la casa en sí, pero te dice dónde encontrarla.</p>
<p>Y podemos hacer lo mismo en el ordenador con los datos. Puedes tener una variable de datos que contenga algún valor. Y ese valor está en la memoria en alguna dirección. Y puedes tener una variable <em>puntero</em> diferente, que contenga la dirección de esa variable de datos.</p>
<p>No es la variable de datos en sí, pero, como con la dirección de una casa, nos dice dónde encontrarla.</p>
<p>Cuando tenemos eso, decimos que tenemos un “puntero a” esos datos. Y podemos seguir el puntero para acceder a los datos en sí.</p>
<p>(Aunque todavía no parece especialmente útil, todo esto se vuelve indispensable cuando se utiliza con llamadas a funciones. Ten paciencia conmigo hasta que lleguemos allí).</p>
<p>Así que si tenemos un <code>int</code>, digamos, y queremos un puntero a él, lo que queremos es alguna forma de obtener la dirección de ese <code>int</code>, ¿verdad? Después de todo, el puntero sólo contiene la <em>dirección de</em> los datos. ¿Qué operador crees que usaríamos para encontrar la <em>dirección</em> del <code>int</code>?</p>
<p>Pues bien, por una sorpresa que debe resultarle chocante a usted, amable lector, utilizamos el operador <code>dirección</code> (que resulta ser un ampersand: “<code>&amp;</code>”) para encontrar la dirección de los datos. Ampersand.</p>
<p>Así que para un ejemplo rápido, introduciremos un nuevo <em>especificador de formato</em> para <code>printf()</code> para que puedas imprimir un puntero. Ya sabes cómo <code>%d</code> imprime un entero decimal, ¿verdad? Pues bien, <code>%p</code> imprime un puntero. Ahora, este puntero va a parecer un número basura (y podría imprimirse en hexadecimal<a href="#fn46" class="footnote-ref" id="fnref46" role="doc-noteref"><sup>46</sup></a> en lugar de decimal), pero es simplemente el índice en memoria en el que se almacenan los datos. (O el índice en memoria en el que se almacena el primer byte de datos, si los datos son multibyte). En prácticamente todas las circunstancias, incluyendo ésta, el valor real del número impreso no es importante para usted, y lo muestro aquí sólo para la demostración del operador <code>de dirección</code>.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb66-2"><a href="#cb66-2"></a></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb66-6"><a href="#cb66-6"></a></span>
<span id="cb66-7"><a href="#cb66-7"></a>    printf<span class="op">(</span><span class="st">&quot;El valor de i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb66-8"><a href="#cb66-8"></a>    printf<span class="op">(</span><span class="st">&quot;Y su dirección es </span><span class="sc">%p\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)&amp;</span>i<span class="op">);</span></span></code></pre></div>
<blockquote>
<p><strong>El código anterior contiene un <em>cast</em></strong> donde coaccionamos el tipo de la expresión <code>&amp;i</code> para que sea del tipo <code>void*</code>. Esto es para evitar que el compilador arroje una advertencia aquí. Esto es todo lo que no hemos cubierto todavía, así que por ahora ignora el <code>(void*)</code> en el código de arriba y finge que no está ahí.</p>
</blockquote>
<p>En mi computadora, se imprime esto:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>El valor de i es 10</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>Y su dirección es 0x7ffddf7072a4</span></code></pre></div>
<p></p>
<p>Si tienes curiosidad, ese número hexadecimal es 140.727.326.896.068 en decimal (base 10 como la que usaba la abuela). Ese es el índice en memoria donde se almacenan los datos de la variable <code>i</code>. Es la dirección de <code>i</code>. Es la ubicación de <code>i</code>. Es un puntero a <code>i</code>.</p>
<blockquote>
<p><strong>Espera-¿Tienes 140 terabytes de RAM?</strong> ¡Sí! ¿No? Pero me causa gracia, por supuesto que no (ca. 2024). Los ordenadores modernos usan una tecnología milagrosa llamada <a href="https://en.wikipedia.org/wiki/Virtual_memory">memoria virtual</a><a href="#fn47" class="footnote-ref" id="fnref47" role="doc-noteref"><sup>47</sup></a> que hace que los procesos piensen que tienen todo el espacio de memoria de tu ordenador para ellos solos, independientemente de cuánta RAM física lo respalde. Así que aunque la dirección era ese enorme número, está siendo mapeada a alguna dirección de memoria física más baja por el sistema de memoria virtual de mi CPU. Este ordenador en particular tiene 16 GB de RAM (de nuevo, ca. 2024, pero uso Linux, así que es suficiente). ¿Terabytes de RAM? Soy profesor, no un multimillonario punto-com. Nada de esto es algo de lo que que preocuparse, excepto la parte en la que no soy fenomenalmente rico.</p>
</blockquote>
<p>Es un puntero porque te permite saber dónde está <code>i</code> en la memoria. Al igual que una dirección escrita en un trozo de papel te dice dónde puedes encontrar una casa en particular, este número nos indica en qué parte de la memoria podemos encontrar el valor de <code>i</code>. Apunta a <code>i</code>.</p>
<p>Una vez más, no nos importa cuál es el número exacto de la dirección, por lo general. Sólo nos importa que es un puntero a “i”.</p>
<h2 data-number="5.2" id="pttypes"><span class="header-section-number">5.2</span> Tipos de puntero</h2>
<p>Así que… todo esto está muy bien. Ahora puede tomar con éxito la dirección de una variable e imprimirla en la pantalla. Hay algo para el viejo currículum, ¿verdad? Aquí es donde me agarras por el cuello y me preguntas amablemente ¡¡Para qué sirven los punteros!!</p>
<p>Excelente pregunta, y llegaremos a ella justo después de estos mensajes de nuestro patrocinador.</p>
<blockquote>
<p><code>SERVICIOS DE LIMPIEZA ROBOTIZADA DE VIVIENDAS. SU VIVIENDA  SERÁ DRÁSTICAMENTE MEJORADA O SERÁ DESPEDIDO.  FIN DEL MENSAJE.</code></p>
</blockquote>
<p>Bienvenidos a otra entrega de la Guía de Beej. La última vez que nos vimos estuvimos hablando de cómo hacer uso de los punteros. Pues bien, lo que vamos a hacer es almacenar un puntero en una variable para poder utilizarlo más adelante. Puedes identificar el <em>tipo de puntero</em> porque hay un asterisco (<code>*</code>) antes del nombre de la variable y después de su tipo:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="op">{</span></span>
<span id="cb68-3"><a href="#cb68-3"></a>    <span class="dt">int</span> i<span class="op">;</span>  <span class="co">// El tipo de i es &quot;int&quot;</span></span>
<span id="cb68-4"><a href="#cb68-4"></a>    <span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span> <span class="co">// El tipo de p es &quot;puntero a un int&quot;, o &quot;int-pointer&quot;.</span></span>
<span id="cb68-5"><a href="#cb68-5"></a><span class="op">}</span></span></code></pre></div>
<p>Así que.. aquí tenemos una variable, que es de tipo puntero, y puede apuntar a otros <code>int</code>s. Es decir, puede contener la dirección de otros <code>int</code>s. Sabemos que apunta a <code>int</code>s, ya que es de tipo <code>int*</code> (léase “int-pointer”).</p>
<p>Cuando haces una asignación a una variable puntero, el tipo de la parte derecha de la asignación tiene que ser del mismo tipo que la variable puntero. Afortunadamente para nosotros, cuando tomas la <code>dirección de</code> (<code>address-of</code>) de una variable, el tipo resultante es un puntero a ese tipo de variable, por lo que asignaciones como la siguiente son perfectas:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span>  <span class="co">// p es un puntero, pero no está inicializado y apunta a basura</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>i<span class="op">;</span>  <span class="co">// a p se le asigna la dirección de i--p ahora &quot;apunta a&quot; i</span></span></code></pre></div>
<p>A la izquierda de la asignación, tenemos una variable de tipo puntero a <code>int</code> (<code>int*</code>), y a la derecha, tenemos una expresión de tipo puntero a <code>int</code> ya que <code>i</code> es un <code>int</code> (porque la dirección de <code>int</code> te da un puntero a <code>int</code>). La dirección de una cosa puede almacenarse en un puntero a esa cosa.</p>
<p>¿Lo entiendes? Sé que todavía no tiene mucho sentido ya que no has visto un uso “real” para la variable puntero, pero estamos dando pequeños pasos aquí para que nadie se pierda. Así que ahora, vamos a presentarte el operador <code>anti-dirección-de</code>. Es algo así como lo que sería <code>address-of</code> en Bizarro World.</p>
<h2 data-number="5.3" id="deref"><span class="header-section-number">5.3</span> Desreferenciación</h2>
<p>Una variable puntero puede considerarse como <em>referida</em> a otra variable apuntando a ella. Es raro que oigas a alguien en la tierra de C hablar de “referir” o “referencias”, pero lo traigo a colación sólo para que el nombre de este operador tenga un poco más de sentido.</p>
<p>Cuando tienes un puntero a una variable (más o menos “una referencia a una variable”), puedes usar la variable original a través del puntero <em>referenciando</em> el puntero. (Puedes pensar en esto como “despointerizar” el puntero, pero nadie dice nunca “despointerizar”).</p>
<p>Volviendo a nuestra analogía, esto es vagamente como mirar la dirección de una casa y luego ir a esa casa.</p>
<p>Ahora bien, ¿qué quiero decir con “acceder a la variable original”? Bueno, si tienes una variable llamada <code>i</code>, y tienes un puntero a <code>i</code> llamado <code>p</code>, ¡puedes usar el puntero desreferenciado <code>p</code> <em>exactamente como si fuera la variable original <code>i</code></em>!</p>
<p>Casi tienes conocimientos suficientes para manejar un ejemplo. El último dato que necesitas saber es el siguiente: ¿qué es el operador de desreferencia? En realidad se llama <em>operador de dirección</em>, porque estás accediendo a valores indirectamente a través del puntero. Y es el asterisco, otra vez: <code>*</code>. No lo confundas con el asterisco que usaste antes en la declaración del puntero. Son el mismo carácter, pero tienen significados diferentes en contextos diferentes<a href="#fn48" class="footnote-ref" id="fnref48" role="doc-noteref"><sup>48</sup></a>.</p>
<p>He aquí un ejemplo en toda regla:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb70-1"><a href="#cb70-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb70-2"><a href="#cb70-2"></a></span>
<span id="cb70-3"><a href="#cb70-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="op">{</span></span>
<span id="cb70-5"><a href="#cb70-5"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb70-6"><a href="#cb70-6"></a>    <span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span>  <span class="co">// esto NO es una desreferencia--esto es un tipo &quot;int*&quot;</span></span>
<span id="cb70-7"><a href="#cb70-7"></a></span>
<span id="cb70-8"><a href="#cb70-8"></a>    p <span class="op">=</span> <span class="op">&amp;</span>i<span class="op">;</span>  <span class="co">// p apunta ahora a i, p tiene la dirección de i</span></span>
<span id="cb70-9"><a href="#cb70-9"></a></span>
<span id="cb70-10"><a href="#cb70-10"></a>    i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// i es ahora 10</span></span>
<span id="cb70-11"><a href="#cb70-11"></a>    <span class="op">*</span>p <span class="op">=</span> <span class="dv">20</span><span class="op">;</span> <span class="co">// lo que p señala (es decir, i!) es ahora 20!!</span></span>
<span id="cb70-12"><a href="#cb70-12"></a></span>
<span id="cb70-13"><a href="#cb70-13"></a>    printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>   <span class="co">// Imprime &quot;20&quot;</span></span>
<span id="cb70-14"><a href="#cb70-14"></a>    printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// ¡&quot;20&quot;! ¡Dereferencia-p es lo mismo que i!</span></span>
<span id="cb70-15"><a href="#cb70-15"></a><span class="op">}</span></span></code></pre></div>
<p>Recuerda que <code>p</code> contiene la dirección de <code>i</code>, como puedes ver donde hicimos la asignación a <code>p</code> en la línea 8. Lo que hace el operador de indirección es decirle al ordenador que <em>utilice el objeto al que apunta el puntero</em> en lugar de utilizar el propio puntero. De esta manera, hemos convertido <code>*p</code> en una especie de alias para <code>i</code>.</p>
<p>Genial, pero <em>¿por qué?</em> ¿Por qué hacer algo de esto?</p>
<h2 data-number="5.4" id="ptpass"><span class="header-section-number">5.4</span> Pasar punteros como argumentos</h2>
<p>Ahora mismo estarás pensando que tienes muchísimos conocimientos sobre punteros, pero absolutamente ninguna aplicación, ¿verdad? Quiero decir, ¿para qué sirve <code>*p</code> si en su lugar puedes decir simplemente <code>i</code>?</p>
<p>Pues bien, amigo mío, el verdadero poder de los punteros entra en juego cuando empiezas a pasarlos a funciones. ¿Por qué es esto tan importante? Tal vez recuerdes que antes podías pasar todo tipo de argumentos a las funciones los cuales se copiarían en parámetros, que luego podías manipular en copias locales de esas variables desde dentro de la función, y así devolver un único valor.</p>
<p>¿Qué pasa si quieres devolver más de un dato de la función? Es decir, sólo puedes devolver una cosa, ¿verdad? ¿Y si respondo a esa pregunta con otra pregunta? …Er, ¿dos preguntas?</p>
<p>¿Qué ocurre cuando se pasa un puntero como argumento a una función? ¿Se coloca una copia del puntero en el parámetro correspondiente? ¿Recuerdas que antes he divagado sobre cómo <em>CADA ARGUMENTO</em> se copia en los parámetros y la función utiliza una COPIA del argumento? Pues aquí ocurre lo mismo. La función obtendrá una copia del puntero.</p>
<p>Pero, y esta es la parte inteligente: habremos configurado el puntero de antemano para que apunte a una variable… ¡y entonces la función puede desreferenciar su copia del puntero para volver a la variable original! La función no puede ver la variable en sí, ¡pero sí puede desreferenciar un puntero a esa variable!</p>
<p>Esto es análogo a escribir la dirección de una casa en un papel y luego copiarla en otro papel. Ahora tienes <em>dos</em> punteros a esa casa, y ambos son igualmente buenos para llevarte a la casa misma.</p>
<p>En el caso de una llamada a una función, una de las copias se almacena en una variable puntero fuera del ámbito de llamada, y la otra se almacena en una variable puntero que es el parámetro de la función.</p>
<p>Ejemplo: Volvamos a nuestra vieja función <code>increment()</code>, pero esta vez hagámosla de modo que realmente incremente el valor en el ámbito de la llamada.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb71-1"><a href="#cb71-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb71-2"><a href="#cb71-2"></a></span>
<span id="cb71-3"><a href="#cb71-3"></a><span class="co">// Nota: ten en cuenta que acepta un puntero a un int</span></span>
<span id="cb71-4"><a href="#cb71-4"></a><span class="dt">void</span> increment<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>p<span class="op">)</span> </span>
<span id="cb71-5"><a href="#cb71-5"></a><span class="op">{</span></span>
<span id="cb71-6"><a href="#cb71-6"></a>    <span class="op">*</span>p <span class="op">=</span> <span class="op">*</span>p <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>        <span class="co">// Añade uno a la cosa a la que p apunta</span></span>
<span id="cb71-7"><a href="#cb71-7"></a><span class="op">}</span></span>
<span id="cb71-8"><a href="#cb71-8"></a></span>
<span id="cb71-9"><a href="#cb71-9"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb71-10"><a href="#cb71-10"></a><span class="op">{</span></span>
<span id="cb71-11"><a href="#cb71-11"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb71-12"><a href="#cb71-12"></a>    <span class="dt">int</span> <span class="op">*</span>j <span class="op">=</span> <span class="op">&amp;</span>i<span class="op">;</span>  <span class="co">// Nota: la dirección de [address-of (&amp;)]; lo convierte en un puntero a i</span></span>
<span id="cb71-13"><a href="#cb71-13"></a></span>
<span id="cb71-14"><a href="#cb71-14"></a>    printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>        <span class="co">// Imprime &quot;10&quot;</span></span>
<span id="cb71-15"><a href="#cb71-15"></a>    printf<span class="op">(</span><span class="st">&quot;i es también </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>j<span class="op">);</span>  <span class="co">// Imprime &quot;10&quot;</span></span>
<span id="cb71-16"><a href="#cb71-16"></a></span>
<span id="cb71-17"><a href="#cb71-17"></a>    increment<span class="op">(</span>j<span class="op">);</span>                  <span class="co">// j es un int*--a i</span></span>
<span id="cb71-18"><a href="#cb71-18"></a></span>
<span id="cb71-19"><a href="#cb71-19"></a>    printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>        <span class="co">// Imprime &quot;11&quot;!</span></span>
<span id="cb71-20"><a href="#cb71-20"></a><span class="op">}</span></span></code></pre></div>
<p>¡Ok! Hay un par de cosas que ver aquí… la menor de ellas es que la función <code>increment()</code> toma un <code>int*</code> como argumento. Le pasamos un <code>int*</code> en la llamada cambiando la variable <code>int</code> <code>i</code> a un <code>int*</code> usando el operador <code>address-of (&amp;)</code>. (Recuerda, un puntero contiene una dirección, así que hacemos punteros a variables pasándolas por el operador <code>address-of</code>).</p>
<p>La función <code>increment()</code> obtiene una copia del puntero. Tanto el puntero original <code>j</code> (en <code>main()</code>) como la copia de ese puntero <code>p</code> (el parámetro en <code>increment()</code>) apuntan a la misma dirección, la que contiene el valor <code>i</code>. (De nuevo, por analogía, como dos trozos de papel con la misma dirección escrita en ellos). Si desreferenciamos cualquiera de las dos, podremos modificar la variable original <code>i</code>. La función puede modificar una variable en otro ámbito. ¡Muévete!</p>
<p>El ejemplo anterior a menudo se escribe de forma más concisa en la llamada simplemente utilizando address-of en la lista de argumentos:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>  <span class="co">// Imprime &quot;10&quot;</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>increment<span class="op">(&amp;</span>i<span class="op">);</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i es </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>  <span class="co">// Imprime &quot;11&quot;!</span></span></code></pre></div>
<p>Como regla general, si quieres que la función modifique la cosa que estás pasando para que veas el resultado, tendrás que pasar un puntero a esa cosa.</p>
<h2 data-number="5.5" id="el-puntero-null"><span class="header-section-number">5.5</span> El puntero <code>NULL</code></h2>
<p>Cualquier variable puntero de cualquier tipo de puntero puede establecerse a un valor especial llamado <code>NULL</code>. Esto indica que este puntero no apunta a nada.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> NULL<span class="op">;</span></span></code></pre></div>
<p>Dado que no apunta a un valor, su desreferencia es un comportamiento INDEFINIDO y probablemente provoque un fallo:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">12</span><span class="op">;</span>  <span class="co">// FALLA o ALGO PROBABLEMENTE MALO. LO MEJOR ES EVITARLO.</span></span></code></pre></div>
<p>A pesar de ser llamado <a href="https://en.wikipedia.org/wiki/Null_pointer#Historia">el error del millon de dolares por su creador</a><a href="#fn49" class="footnote-ref" id="fnref49" role="doc-noteref"><sup>49</sup></a>, el puntero <code>NULL</code> es un buen <a href="https://en.wikipedia.org/wiki/Sentinel%20value">sentinela</a><a href="#fn50" class="footnote-ref" id="fnref50" role="doc-noteref"><sup>50</sup></a> e indicador general de que un puntero aún no ha sido inicializado.</p>
<p>(Por supuesto, al igual que otras variables, el puntero apunta a basura a menos que le asignes explícitamente que apunte a una dirección o a <code>NULL</code>). </p>
<h2 data-number="5.6" id="nota-sobre-la-declaración-de-punteros"><span class="header-section-number">5.6</span> Nota sobre la declaración de punteros</h2>
<p>La sintaxis para declarar un puntero puede ser un poco extraña. Veamos este ejemplo:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b<span class="op">;</span></span></code></pre></div>
<p>Podemos condensarlo en una sola línea, ¿verdad?</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">,</span> b<span class="op">;</span>  <span class="co">// Es lo mismo</span></span></code></pre></div>
<p>Así que <code>a</code> y <code>b</code> son ambas <code>int</code>s. No hay problema.</p>
<p>Pero, ¿y esto?</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span></span></code></pre></div>
<p>¿Podemos convertirlo en una línea? Sí, podemos. ¿Pero dónde va el <code>*</code>?</p>
<p>La regla es que el <code>*</code> va delante de cualquier variable que sea de tipo puntero. Es decir, el <code>*</code> no es parte del <code>int</code> en este ejemplo. es parte de la variable <code>p</code>.</p>
<p>Con eso en mente, podemos escribir esto:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">,</span> <span class="op">*</span>p<span class="op">;</span>  <span class="co">// Es lo mismo</span></span></code></pre></div>
<p>Es importante notar que la siguiente línea <em>no</em> declara dos punteros:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p<span class="op">,</span> q<span class="op">;</span>  <span class="co">// p es un puntero a un int; q es sólo un int.</span></span></code></pre></div>
<p>Esto puede ser particularmente insidioso si el programador escribe la siguiente línea de código (válida) que es funcionalmente idéntica a la anterior.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> p<span class="op">,</span> q<span class="op">;</span>  <span class="co">// p es un puntero a un int; q es sólo un int.</span></span></code></pre></div>
<p>Así que echa un vistazo a esto y determina qué variables son punteros y cuáles no:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> b<span class="op">,</span> c<span class="op">,</span> <span class="op">*</span>d<span class="op">,</span> e<span class="op">,</span> <span class="op">*</span>f<span class="op">,</span> g<span class="op">,</span> h<span class="op">,</span> <span class="op">*</span>i<span class="op">;</span></span></code></pre></div>
<p>Dejaré la respuesta en una nota al pie<a href="#fn51" class="footnote-ref" id="fnref51" role="doc-noteref"><sup>51</sup></a>..</p>
<h2 data-number="5.7" id="sizeof-y-punteros"><span class="header-section-number">5.7</span> <code>sizeof</code> y punteros</h2>
<p>Sólo un poco de sintaxis aquí que puede ser confusa y que puedes ver de vez en cuando.</p>
<p>Recuerda que <code>sizeof</code> opera sobre el <em>tipo</em> de la expresión.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Imprime el tamaño de un &#39;int</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="co">// p es de tipo &#39;int *&#39;, por lo que imprime el tamaño de &#39;int*&#39;</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> p<span class="op">);</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="co">// *p es de tipo &#39;int&#39;, por lo que imprime el tamaño de &#39;int&#39;</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> <span class="op">*</span>p<span class="op">);</span></span></code></pre></div>
<p>Usted puede ver el código en la naturaleza con ese último <code>sizeof</code> allí. Recuerda que <code>sizeof</code> se refiere al tipo de expresión, no a las variables de la expresión.</p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="6" id="arrays"><span class="header-section-number">6</span> Arrays</h1>
<blockquote>
<p>“¿Los índices de las matrices deben empezar en 0 o en 1?<br />
Mi compromiso de 0.5 fue rechazado sin, pensé, la debida consideración.”_</p>
<p>—Stan Kelly-Bootle, informático</p>
</blockquote>
<p>Por suerte, C tiene matrices. Ya sé que se considera un lenguaje de bajo nivel <a href="#fn52" class="footnote-ref" id="fnref52" role="doc-noteref"><sup>52</sup></a>, pero al menos incorpora el concepto de arrays. Y como muchos lenguajes se inspiraron en la sintaxis de C, probablemente ya estés familiarizado con el uso de <code>[</code> y <code>]</code> para declarar y usar matrices.</p>
<p>Pero C apenas tiene arrays. Como veremos más adelante, los arrays, en el fondo, son sólo azúcar sintáctico en C—en realidad son todo punteros. Pero por ahora, usémoslos como arrays. <em>Phew</em>.</p>
<h2 data-number="6.1" id="ejemplo-sencillo"><span class="header-section-number">6.1</span> Ejemplo sencillo</h2>
<p>Pongamos un ejemplo:</p>
<p></p>
<div class="sourceCode" id="cb83"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb83-1"><a href="#cb83-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb83-2"><a href="#cb83-2"></a></span>
<span id="cb83-3"><a href="#cb83-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb83-4"><a href="#cb83-4"></a><span class="op">{</span></span>
<span id="cb83-5"><a href="#cb83-5"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb83-6"><a href="#cb83-6"></a>    <span class="dt">float</span> f<span class="op">[</span><span class="dv">4</span><span class="op">];</span>  <span class="co">// Declara un array de 4 floats</span></span>
<span id="cb83-7"><a href="#cb83-7"></a></span>
<span id="cb83-8"><a href="#cb83-8"></a>    f<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">3.14159</span><span class="op">;</span>  <span class="co">// La indexación empieza en 0, por supuesto.</span></span>
<span id="cb83-9"><a href="#cb83-9"></a>    f<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1.41421</span><span class="op">;</span></span>
<span id="cb83-10"><a href="#cb83-10"></a>    f<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1.61803</span><span class="op">;</span></span>
<span id="cb83-11"><a href="#cb83-11"></a>    f<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="fl">2.71828</span><span class="op">;</span></span>
<span id="cb83-12"><a href="#cb83-12"></a></span>
<span id="cb83-13"><a href="#cb83-13"></a>    <span class="co">// Imprímelos todos:</span></span>
<span id="cb83-14"><a href="#cb83-14"></a></span>
<span id="cb83-15"><a href="#cb83-15"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb83-16"><a href="#cb83-16"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> f<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb83-17"><a href="#cb83-17"></a>    <span class="op">}</span></span>
<span id="cb83-18"><a href="#cb83-18"></a><span class="op">}</span></span></code></pre></div>
<p>Cuando declaras un array, tienes que darle un tamaño. Y el tamaño tiene que ser fijo <a href="#fn53" class="footnote-ref" id="fnref53" role="doc-noteref"><sup>53</sup></a>.</p>
<p>En el ejemplo anterior, hicimos un array de 4 <code>float</code>s. El valor entre corchetes de la declaración nos lo indica.</p>
<p>Más tarde, en las líneas siguientes, accedemos a los valores de la matriz, estableciéndolos u obteniéndolos, de nuevo con corchetes. </p>
<p>Espero que le suenen de alguno de los idiomas que ya conoce.</p>
<h2 data-number="6.2" id="obtener-la-longitud-de-una-matriz"><span class="header-section-number">6.2</span> Obtener la longitud de una matriz</h2>
<p> No puedes…ish. C no registra esta información<a href="#fn54" class="footnote-ref" id="fnref54" role="doc-noteref"><sup>54</sup></a>. Tienes que gestionarlo por separado en otra variable.</p>
<p>Cuando digo “no se puede”, en realidad quiero decir que hay algunas circunstancias en las que <em>se puede</em>. Hay un truco para obtener el número de elementos de un array en el ámbito en el que se declara un array. Pero, en general, esto no funcionará como quieres si pasas el array a una función<a href="#fn55" class="footnote-ref" id="fnref55" role="doc-noteref"><sup>55</sup></a>.</p>
<p>Veamos este truco. La idea básica es que usted toma el <code>sizeof</code> de la matriz, y luego se divide por el tamaño de cada elemento para obtener la longitud. Por ejemplo, si un <code>int</code> es de 4 bytes, y la matriz es de 32 bytes de largo, debe haber espacio para <span class="math inline">\(\frac{32}{4}\)</span> o <span class="math inline">\(8\)</span> <code>int</code>s allí.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[</span><span class="dv">12</span><span class="op">];</span>  <span class="co">// 12 ints</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> x<span class="op">);</span>     <span class="co">// 48 bytes totales</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span>  <span class="co">// 4 bytes por int</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> x <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span>  <span class="co">// 48/4 = 12 ints!</span></span></code></pre></div>
<p>Si es un array de <code>char</code>s, entonces <code>sizeof</code> del array <em>es</em> el número de elementos, ya que <code>sizeof(char)</code> está definido como 1. Para cualquier otro tipo, tienes que dividir por el tamaño de cada elemento.</p>
<p>Pero este truco sólo funciona en el ámbito en el que se definió el array. Si pasas el array a una función, no funciona. Incluso si lo haces “grande” en la firma de la función:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span> x<span class="op">[</span><span class="dv">12</span><span class="op">])</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> x<span class="op">);</span>     <span class="co">// ¡8?! ¿Qué ha sido del 48?</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span>  <span class="co">// 4 bytes por int</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> x <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span>  <span class="co">// 8/4 = 2 ints?? INCORRECTO.</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Esto se debe a que cuando “pasas” arrays a funciones, sólo estás pasando un puntero al primer elemento, y eso es lo que mide <code>sizeof</code>. Más sobre esto en la sección, <a href="#passing1darrays">Pasar arrays unidimensionales a funciones</a>. más abajo.</p>
<p>Otra cosa que puedes hacer con <code>sizeof</code> y arrays es obtener el tamaño de un array de un número fijo de elementos sin declarar el array. Es como obtener el tamaño de un <code>int</code> con <code>sizeof(int)</code>.</p>
<p>Por ejemplo, para ver cuántos bytes se necesitarían para un array de 48 <code>dobles</code>s, puedes hacer esto:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span> <span class="op">[</span><span class="dv">48</span><span class="op">]);</span></span></code></pre></div>
<p> </p>
<h2 data-number="6.3" id="inicializadores-de-matrices"><span class="header-section-number">6.3</span> Inicializadores de matrices</h2>
<p> Puedes inicializar un array de antemano:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb87-2"><a href="#cb87-2"></a></span>
<span id="cb87-3"><a href="#cb87-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb87-4"><a href="#cb87-4"></a><span class="op">{</span></span>
<span id="cb87-5"><a href="#cb87-5"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb87-6"><a href="#cb87-6"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">22</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">3490</span><span class="op">,</span> <span class="dv">18</span><span class="op">,</span> <span class="dv">95</span><span class="op">};</span>  <span class="co">// Inicializar con estos valores</span></span>
<span id="cb87-7"><a href="#cb87-7"></a></span>
<span id="cb87-8"><a href="#cb87-8"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb87-9"><a href="#cb87-9"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb87-10"><a href="#cb87-10"></a>    <span class="op">}</span></span>
<span id="cb87-11"><a href="#cb87-11"></a><span class="op">}</span></span></code></pre></div>
<p>Nunca debes tener más elementos en tu inicializador de los que caben en el array, o el compilador se pondrá de mal humor:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ex">foo.c:</span> In function ‘main’:</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="ex">foo.c:6:39:</span> warning: excess elements in array initializer</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">6</span> <span class="kw">|</span>     <span class="ex">int</span> a<span class="pp">[</span><span class="st">5</span><span class="pp">]</span> <span class="kw">=</span> {22, 37, 3490, 18, 95, 999<span class="er">}</span><span class="kw">;</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">|</span>                                       <span class="ex">^~~</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="ex">foo.c:6:39:</span> note: <span class="pp">(</span><span class="ss">near initialization for ‘a’</span><span class="pp">)</span></span></code></pre></div>
<p>Pero (¡dato curioso!) puedes tener <em>menos</em> elementos en tu inicializador de los que caben en el array. Los elementos restantes de la matriz se inicializarán automáticamente con cero. Esto es cierto en general para todos los tipos de inicializadores de matrices: si tienes un inicializador, todo lo que no se establezca explícitamente a un valor se establecerá a cero.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">22</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">3490</span><span class="op">};</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Es lo mismo que:</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">22</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">3490</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span></code></pre></div>
<p>Es un atajo común ver esto en un inicializador cuando quieres poner un array entero a cero:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">100</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span></code></pre></div>
<p>Lo que significa, “Haz el primer elemento cero, y luego automáticamente haz el resto cero, también”.</p>
<p>También puedes establecer elementos específicos del array en el inicializador, especificando un índice para el valor. Cuando haces esto, C seguirá inicializando los valores subsiguientes por ti hasta que el inicializador se agote, llenando todo lo demás con <code>0</code>.</p>
<p>Para hacer esto, pon el índice entre corchetes con un <code>=</code> después, y luego establece el valor.</p>
<p>Aquí hay un ejemplo donde construimos un array:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="op">[</span><span class="dv">5</span><span class="op">]=</span><span class="dv">55</span><span class="op">,</span> <span class="dv">66</span><span class="op">,</span> <span class="dv">77</span><span class="op">};</span></span></code></pre></div>
<p>Como hemos puesto el índice 5 como inicio para <code>55</code>, los datos resultantes en el array son:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>0 11 22 0 0 55 66 77 0 0</span></code></pre></div>
<p>También puedes introducir expresiones constantes sencillas.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define COUNT </span><span class="dv">5</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>COUNT<span class="op">]</span> <span class="op">=</span> <span class="op">{[</span>COUNT<span class="op">-</span><span class="dv">3</span><span class="op">]=</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span></code></pre></div>
<p>que nos da:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>0 0 3 2 1</span></code></pre></div>
<p>Por último, también puedes hacer que C calcule el tamaño del array a partir del inicializador, simplemente dejando el tamaño desactivado:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">22</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">3490</span><span class="op">};</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Es lo mismo que:</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">22</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">3490</span><span class="op">};</span>  <span class="co">// ¡Dejé el tamaño!</span></span></code></pre></div>
<p></p>
<h2 data-number="6.4" id="fuera-de-los-límites-out-of-bounds"><span class="header-section-number">6.4</span> ¡Fuera de los límites! (Out of Bounds!)</h2>
<p> C no te impide acceder a matrices fuera de los límites. Puede que ni siquiera te avise.</p>
<p>Robemos el ejemplo de arriba y sigamos imprimiendo el final del array. Sólo tiene 5 elementos, pero vamos a tratar de imprimir 10 y ver lo que sucede:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb96-1"><a href="#cb96-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb96-2"><a href="#cb96-2"></a></span>
<span id="cb96-3"><a href="#cb96-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb96-4"><a href="#cb96-4"></a><span class="op">{</span></span>
<span id="cb96-5"><a href="#cb96-5"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb96-6"><a href="#cb96-6"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">22</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">3490</span><span class="op">,</span> <span class="dv">18</span><span class="op">,</span> <span class="dv">95</span><span class="op">};</span></span>
<span id="cb96-7"><a href="#cb96-7"></a></span>
<span id="cb96-8"><a href="#cb96-8"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span>  <span class="co">// MALAS NOTICIAS: ¡imprime demasiados elementos!</span></span>
<span id="cb96-9"><a href="#cb96-9"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb96-10"><a href="#cb96-10"></a>    <span class="op">}</span></span>
<span id="cb96-11"><a href="#cb96-11"></a><span class="op">}</span></span></code></pre></div>
<p>Ejecutándolo en mi computadora imprime:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>22</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>37</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>3490</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>18</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>95</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>32765</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>1847052032</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>1780534144</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>-56487472</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>21890</span></code></pre></div>
<p>¡Caramba! ¿Qué es esto? Bueno, resulta que imprimir el final de un array resulta en lo que los desarrolladores de C llaman <em>comportamiento indefinido</em>. Hablaremos más sobre esta bestia más adelante, pero por ahora significa: “Has hecho algo malo, y cualquier cosa podría pasar durante la ejecución de tu programa”.</p>
<p>Y por cualquier cosa, me refiero típicamente a cosas como encontrar ceros, encontrar números basura, o bloquearse. Pero en realidad la especificación de C dice que en estas circunstancias el compilador puede emitir código que haga <em>cualquier cosa</em><a href="#fn56" class="footnote-ref" id="fnref56" role="doc-noteref"><sup>56</sup></a>.</p>
<p>Versión corta: no hagas nada que cause un comportamiento indefinido. Nunca <a href="#fn57" class="footnote-ref" id="fnref57" role="doc-noteref"><sup>57</sup></a>. </p>
<h2 data-number="6.5" id="matrices-multidimensionales"><span class="header-section-number">6.5</span> Matrices multidimensionales</h2>
<p> Puede añadir tantas dimensiones como desee a sus matrices.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">7</span><span class="op">];</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> c<span class="op">[</span><span class="dv">4</span><span class="op">][</span><span class="dv">5</span><span class="op">][</span><span class="dv">6</span><span class="op">];</span></span></code></pre></div>
<p>Se almacenan en memoria en <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major order</a><a href="#fn58" class="footnote-ref" id="fnref58" role="doc-noteref"><sup>58</sup></a>.Esto significa que en una matriz 2D, el primer índice de la lista indica la <em>fila</em> y el segundo la <em>columna</em>. También puedes utilizar inicializadores en matrices multidimensionales anidándolos:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb99-1"><a href="#cb99-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb99-2"><a href="#cb99-2"></a></span>
<span id="cb99-3"><a href="#cb99-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb99-4"><a href="#cb99-4"></a><span class="op">{</span></span>
<span id="cb99-5"><a href="#cb99-5"></a>    <span class="dt">int</span> row<span class="op">,</span> col<span class="op">;</span></span>
<span id="cb99-6"><a href="#cb99-6"></a></span>
<span id="cb99-7"><a href="#cb99-7"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span>      <span class="co">// Inicializar una matriz 2D</span></span>
<span id="cb99-8"><a href="#cb99-8"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span></span>
<span id="cb99-9"><a href="#cb99-9"></a>        <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">}</span></span>
<span id="cb99-10"><a href="#cb99-10"></a>    <span class="op">};</span></span>
<span id="cb99-11"><a href="#cb99-11"></a></span>
<span id="cb99-12"><a href="#cb99-12"></a>    <span class="cf">for</span> <span class="op">(</span>row <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> row <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> row<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb99-13"><a href="#cb99-13"></a>        <span class="cf">for</span> <span class="op">(</span>col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> col <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> col<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb99-14"><a href="#cb99-14"></a>            printf<span class="op">(</span><span class="st">&quot;(</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> row<span class="op">,</span> col<span class="op">,</span> a<span class="op">[</span>row<span class="op">][</span>col<span class="op">]);</span></span>
<span id="cb99-15"><a href="#cb99-15"></a>        <span class="op">}</span></span>
<span id="cb99-16"><a href="#cb99-16"></a>    <span class="op">}</span></span>
<span id="cb99-17"><a href="#cb99-17"></a><span class="op">}</span></span></code></pre></div>
<p>Para la salida de:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>(0,0) = 0</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>(0,1) = 1</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>(0,2) = 2</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>(0,3) = 3</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>(0,4) = 4</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>(1,0) = 5</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>(1,1) = 6</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>(1,2) = 7</span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>(1,3) = 8</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>(1,4) = 9</span></code></pre></div>
<p>Y se puede inicializar con índices explícitos:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Hacer una matriz de identidad 3x3</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]=</span><span class="dv">1</span><span class="op">,</span> <span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">]=</span><span class="dv">1</span><span class="op">,</span> <span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">]=</span><span class="dv">1</span><span class="op">};</span></span></code></pre></div>
<p>que construye un array 2D como este:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>1 0 0</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>0 1 0</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>0 0 1</span></code></pre></div>
<p></p>
<h2 data-number="6.6" id="matrices-y-punteros"><span class="header-section-number">6.6</span> Matrices y punteros</h2>
<p> Así que… “<em>Casualmente</em>” ¿podría haber mencionado que los arrays eran punteros, en el fondo? Deberíamos hacer una inmersión superficial en eso ahora para que las cosas no sean completamente confusas. Más adelante veremos cuál es la relación real entre arrays y punteros, pero por ahora sólo quiero pasar arrays a funciones.</p>
<h3 data-number="6.6.1" id="obtener-un-puntero-a-una-matriz"><span class="header-section-number">6.6.1</span> Obtener un puntero a una matriz</h3>
<p>Quiero contarte un secreto. En general, cuando un programador de C habla de un puntero a un array, está hablando de un puntero <em>al primer elemento</em> del array <a href="#fn59" class="footnote-ref" id="fnref59" role="doc-noteref"><sup>59</sup></a>.</p>
<p>Obtengamos un puntero al primer elemento de un array.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb103-1"><a href="#cb103-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb103-2"><a href="#cb103-2"></a></span>
<span id="cb103-3"><a href="#cb103-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb103-4"><a href="#cb103-4"></a><span class="op">{</span></span>
<span id="cb103-5"><a href="#cb103-5"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb103-6"><a href="#cb103-6"></a>    <span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb103-7"><a href="#cb103-7"></a></span>
<span id="cb103-8"><a href="#cb103-8"></a>    p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// p apunta a la matriz</span></span>
<span id="cb103-9"><a href="#cb103-9"></a>                <span class="co">// Bueno, al primer elemento, en realidad</span></span>
<span id="cb103-10"><a href="#cb103-10"></a></span>
<span id="cb103-11"><a href="#cb103-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// Imprime &quot;11&quot;</span></span>
<span id="cb103-12"><a href="#cb103-12"></a><span class="op">}</span></span></code></pre></div>
<p>Esto es tan común de hacer en C que el lenguaje nos permite una forma abreviada:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb104-1"><a href="#cb104-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// p apunta a la matriz</span></span>
<span id="cb104-2"><a href="#cb104-2"></a></span>
<span id="cb104-3"><a href="#cb104-3"></a><span class="co">// Es lo mismo que:</span></span>
<span id="cb104-4"><a href="#cb104-4"></a></span>
<span id="cb104-5"><a href="#cb104-5"></a>p <span class="op">=</span> a<span class="op">;</span>      <span class="co">// p apunta a la matriz, ¡pero es mucho más bonito!</span></span></code></pre></div>
<p>Hacer referencia al nombre del array de forma aislada es lo mismo que obtener un puntero al primer elemento del array. Vamos a utilizar esto ampliamente en los próximos ejemplos.</p>
<p>Pero espera un segundo… ¿no es <code>p</code> un <code>int*</code>? ¿Y <code>*p</code> nos da <code>11</code>, lo mismo que <code>a[0]</code>? Sí. Estás empezando a ver cómo se relacionan las matrices y los punteros en C. </p>
<h3 data-number="6.6.2" id="passing1darrays"><span class="header-section-number">6.6.2</span> Paso de matrices unidimensionales a funciones</h3>
<p> Hagamos un ejemplo con un array unidimensional. Voy a escribir un par de funciones a las que podemos pasar el array para que hagan cosas diferentes.</p>
<p>¡Prepárate para algunas firmas de funciones alucinantes!</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb105-1"><a href="#cb105-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb105-2"><a href="#cb105-2"></a></span>
<span id="cb105-3"><a href="#cb105-3"></a><span class="co">// Pasar como puntero al primer elemento</span></span>
<span id="cb105-4"><a href="#cb105-4"></a><span class="dt">void</span> times2<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> len<span class="op">)</span></span>
<span id="cb105-5"><a href="#cb105-5"></a><span class="op">{</span></span>
<span id="cb105-6"><a href="#cb105-6"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb105-7"><a href="#cb105-7"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb105-8"><a href="#cb105-8"></a><span class="op">}</span></span>
<span id="cb105-9"><a href="#cb105-9"></a></span>
<span id="cb105-10"><a href="#cb105-10"></a><span class="co">// Lo mismo, pero utilizando la notación de matriz</span></span>
<span id="cb105-11"><a href="#cb105-11"></a><span class="dt">void</span> times3<span class="op">(</span><span class="dt">int</span> a<span class="op">[],</span> <span class="dt">int</span> len<span class="op">)</span></span>
<span id="cb105-12"><a href="#cb105-12"></a><span class="op">{</span></span>
<span id="cb105-13"><a href="#cb105-13"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb105-14"><a href="#cb105-14"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb105-15"><a href="#cb105-15"></a><span class="op">}</span></span>
<span id="cb105-16"><a href="#cb105-16"></a></span>
<span id="cb105-17"><a href="#cb105-17"></a><span class="co">// Lo mismo, pero utilizando la notación de matriz con tamaño</span></span>
<span id="cb105-18"><a href="#cb105-18"></a><span class="dt">void</span> times4<span class="op">(</span><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">],</span> <span class="dt">int</span> len<span class="op">)</span></span>
<span id="cb105-19"><a href="#cb105-19"></a><span class="op">{</span></span>
<span id="cb105-20"><a href="#cb105-20"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb105-21"><a href="#cb105-21"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb105-22"><a href="#cb105-22"></a><span class="op">}</span></span>
<span id="cb105-23"><a href="#cb105-23"></a></span>
<span id="cb105-24"><a href="#cb105-24"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb105-25"><a href="#cb105-25"></a><span class="op">{</span></span>
<span id="cb105-26"><a href="#cb105-26"></a>    <span class="dt">int</span> x<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb105-27"><a href="#cb105-27"></a></span>
<span id="cb105-28"><a href="#cb105-28"></a>    times2<span class="op">(</span>x<span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb105-29"><a href="#cb105-29"></a>    times3<span class="op">(</span>x<span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb105-30"><a href="#cb105-30"></a>    times4<span class="op">(</span>x<span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb105-31"><a href="#cb105-31"></a><span class="op">}</span></span></code></pre></div>
<p>Todos esos métodos de enumerar el array como parámetro en la función son idénticos.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> times2<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> len<span class="op">)</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> times3<span class="op">(</span><span class="dt">int</span> a<span class="op">[],</span> <span class="dt">int</span> len<span class="op">)</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> times4<span class="op">(</span><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">],</span> <span class="dt">int</span> len<span class="op">)</span></span></code></pre></div>
<p>En el uso por parte de los habituales de C, la primera es la más común, con diferencia.</p>
<p>Y, de hecho, en la última situación, el compilador ni siquiera le importa qué número le pasas (aparte de que tiene que ser mayor que cero<a href="#fn60" class="footnote-ref" id="fnref60" role="doc-noteref"><sup>60</sup></a>). No impone nada en absoluto.</p>
<p>Ahora que lo he dicho, el tamaño del array en la declaración de la función realmente <em>importa</em> cuando pasas arrays multidimensionales a funciones, pero volveremos a eso. </p>
<h3 data-number="6.6.3" id="modificación-de-matrices-en-funciones"><span class="header-section-number">6.6.3</span> Modificación de matrices en funciones</h3>
<p> Ya hemos dicho que las matrices son punteros disfrazados. Esto significa que si pasas un array a una función, probablemente estés pasando un puntero al primer elemento del array.</p>
<p>Pero si la función tiene un puntero a los datos, ¡puede manipular esos datos! Así que los cambios que una función hace a un array serán visibles de nuevo en el invocador.</p>
<p>He aquí un ejemplo en el que pasamos un puntero a un array a una función, la función manipula los valores de ese array, y esos cambios son visibles en la llamada.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb107-1"><a href="#cb107-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb107-2"><a href="#cb107-2"></a></span>
<span id="cb107-3"><a href="#cb107-3"></a><span class="dt">void</span> double_array<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> len<span class="op">)</span></span>
<span id="cb107-4"><a href="#cb107-4"></a><span class="op">{</span></span>
<span id="cb107-5"><a href="#cb107-5"></a>    <span class="co">// Multiplica cada elemento por 2</span></span>
<span id="cb107-6"><a href="#cb107-6"></a>    <span class="co">//</span></span>
<span id="cb107-7"><a href="#cb107-7"></a>    <span class="co">// Esto duplica los valores en &#39;x&#39; en main() ya que &#39;x&#39; y &#39;a&#39; apuntan</span></span>
<span id="cb107-8"><a href="#cb107-8"></a>    <span class="co">// ¡Al mismo array en memoria!</span></span>
<span id="cb107-9"><a href="#cb107-9"></a></span>
<span id="cb107-10"><a href="#cb107-10"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb107-11"><a href="#cb107-11"></a>        a<span class="op">[</span>i<span class="op">]</span> <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb107-12"><a href="#cb107-12"></a><span class="op">}</span></span>
<span id="cb107-13"><a href="#cb107-13"></a></span>
<span id="cb107-14"><a href="#cb107-14"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb107-15"><a href="#cb107-15"></a><span class="op">{</span></span>
<span id="cb107-16"><a href="#cb107-16"></a>    <span class="dt">int</span> x<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb107-17"><a href="#cb107-17"></a></span>
<span id="cb107-18"><a href="#cb107-18"></a>    double_array<span class="op">(</span>x<span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb107-19"><a href="#cb107-19"></a></span>
<span id="cb107-20"><a href="#cb107-20"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb107-21"><a href="#cb107-21"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">[</span>i<span class="op">]);</span>  <span class="co">// 2, 4, 6, 8, 10!</span></span>
<span id="cb107-22"><a href="#cb107-22"></a><span class="op">}</span></span></code></pre></div>
<p>Aunque pasamos el array como parámetro <code>a</code> que es de tipo <code>int*</code>, ¡mira cómo accedemos a él usando la notación array con <code>a[i]</code>! Vaya. Esto está totalmente permitido.</p>
<p>Más adelante, cuando hablemos de la equivalencia entre arrays y punteros, veremos que esto tiene mucho más sentido. Por ahora, es suficiente saber que las funciones pueden hacer cambios a los arrays que son visibles en el llamador. </p>
<h3 data-number="6.6.4" id="paso-de-matrices-multidimensionales-a-funciones"><span class="header-section-number">6.6.4</span> Paso de matrices multidimensionales a funciones</h3>
<p> La historia cambia un poco cuando hablamos de matrices multidimensionales. C necesita conocer todas las dimensiones (excepto la primera) para saber en qué parte de la memoria debe buscar un valor.</p>
<p>He aquí un ejemplo en el que somos explícitos con todas las dimensiones:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb108-1"><a href="#cb108-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb108-2"><a href="#cb108-2"></a></span>
<span id="cb108-3"><a href="#cb108-3"></a><span class="dt">void</span> print_2D_array<span class="op">(</span><span class="dt">int</span> a<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">])</span></span>
<span id="cb108-4"><a href="#cb108-4"></a><span class="op">{</span></span>
<span id="cb108-5"><a href="#cb108-5"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> row <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> row <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> row<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb108-6"><a href="#cb108-6"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> col <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> col<span class="op">++)</span></span>
<span id="cb108-7"><a href="#cb108-7"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span><span class="op">,</span> a<span class="op">[</span>row<span class="op">][</span>col<span class="op">]);</span></span>
<span id="cb108-8"><a href="#cb108-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb108-9"><a href="#cb108-9"></a>    <span class="op">}</span></span>
<span id="cb108-10"><a href="#cb108-10"></a><span class="op">}</span></span>
<span id="cb108-11"><a href="#cb108-11"></a></span>
<span id="cb108-12"><a href="#cb108-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb108-13"><a href="#cb108-13"></a><span class="op">{</span></span>
<span id="cb108-14"><a href="#cb108-14"></a>    <span class="dt">int</span> x<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb108-15"><a href="#cb108-15"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span></span>
<span id="cb108-16"><a href="#cb108-16"></a>        <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}</span></span>
<span id="cb108-17"><a href="#cb108-17"></a>    <span class="op">};</span></span>
<span id="cb108-18"><a href="#cb108-18"></a></span>
<span id="cb108-19"><a href="#cb108-19"></a>    print_2D_array<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb108-20"><a href="#cb108-20"></a><span class="op">}</span></span></code></pre></div>
<p>Pero en este caso, estos dos<a href="#fn61" class="footnote-ref" id="fnref61" role="doc-noteref"><sup>61</sup></a> son equivalentes:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_2D_array<span class="op">(</span><span class="dt">int</span> a<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">])</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_2D_array<span class="op">(</span><span class="dt">int</span> a<span class="op">[][</span><span class="dv">3</span><span class="op">])</span></span></code></pre></div>
<p>En realidad, el compilador sólo necesita la segunda dimensión para poder calcular la distancia de memoria que debe saltarse en cada incremento de la primera dimensión. En general, necesita conocer todas las dimensiones excepto la primera.</p>
<p>Además, recuerda que el compilador hace una comprobación mínima de los límites en tiempo de compilación (si tienes suerte), y C no hace ninguna comprobación de los límites en tiempo de ejecución.¡Sin cinturones de seguridad! No te estrelles accediendo a elementos del array fuera de los límites. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="7" id="strings-cadenas-de-caracteres"><span class="header-section-number">7</span> Strings (“Cadenas” de caracteres)</h1>
<p>¡Por fin! ¡Cadenas! ¿Qué podría ser más sencillo?</p>
<p>Bueno, resulta que las cadenas en realidad no son cadenas en C. ¡Así es! ¡Son punteros! Por supuesto que lo son.</p>
<p>Al igual que las matrices, las cadenas en C <em>apenas existen</em>.</p>
<p>Pero vamos a comprobarlo… en realidad no es para tanto.</p>
<h2 data-number="7.1" id="literales-de-cadena"><span class="header-section-number">7.1</span> Literales de cadena</h2>
<p>Antes de empezar, hablemos de los literales de cadena en C. Son secuencias de caracteres entre comillas <em>dobles</em> (<code>"</code>). (Las comillas simples encierran caracteres, y son un animal completamente diferente).</p>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;This is a test.&quot;</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;When asked if this string had quotes in it, she replied, </span><span class="sc">\&quot;</span><span class="st">It does.</span><span class="sc">\&quot;</span><span class="st">&quot;</span></span></code></pre></div>
<p>El primero tiene una nueva línea al final, algo bastante común.</p>
<p>La última tiene comillas incrustadas, pero cada una está precedida por (decimos «escapada por») una barra invertida (<code>\</code>) indicando que una comilla literal pertenece a la cadena en este punto. Así es como el compilador de C, puede diferenciar entre, imprimir una comilla doble y la comilla doble al final de la cadena.</p>
<h2 data-number="7.2" id="variables-de-cadena"><span class="header-section-number">7.2</span> Variables de cadena</h2>
<p>Ahora que sabemos cómo hacer un literal de cadena, asignémoslo a una variable para poder hacer algo con él.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Fíjate en el tipo: puntero a un <code>char</code>. La variable de cadena <code>s</code> es en realidad un puntero al primer carácter de esa cadena, concretamente la <code>H</code>.</p>
<p>Y podemos imprimirlo con el especificador de formato <code>%s</code> (de <strong>S</strong>tring «cadena»):</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span> <span class="co">// &quot;Hola, mundo!&quot;</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>  <span class="co">// Hello, world!</span></span></code></pre></div>
<p></p>
<h2 data-number="7.3" id="variables-de-cadena-como-matrices"><span class="header-section-number">7.3</span> Variables de cadena como matrices</h2>
<p> Otra opción es ésta, casi equivalente al uso anterior de <code>char*</code>:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> s<span class="op">[</span><span class="dv">14</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="co">// o, si fuéramos perezosos y dejáramos que el compilador</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="co">// calculara la longitud por nosotros:</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Esto significa que puedes utilizar la notación de matrices para acceder a los caracteres de una cadena.Hagamos exactamente eso para imprimir todos los caracteres de una cadena en la misma línea:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb114-1"><a href="#cb114-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb114-2"><a href="#cb114-2"></a></span>
<span id="cb114-3"><a href="#cb114-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb114-4"><a href="#cb114-4"></a><span class="op">{</span></span>
<span id="cb114-5"><a href="#cb114-5"></a>    <span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb114-6"><a href="#cb114-6"></a></span>
<span id="cb114-7"><a href="#cb114-7"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">13</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb114-8"><a href="#cb114-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb114-9"><a href="#cb114-9"></a><span class="op">}</span></span></code></pre></div>
<p>Tenga en cuenta que estamos utilizando el especificador de formato <code>%c</code> para imprimir un solo carácter.</p>
<p>Además, fíjate en esto. El programa seguirá funcionando bien si cambiamos la definición de <code>s</code> para que sea de tipo <code>char*</code>:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb115-1"><a href="#cb115-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb115-2"><a href="#cb115-2"></a></span>
<span id="cb115-3"><a href="#cb115-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb115-4"><a href="#cb115-4"></a><span class="op">{</span></span>
<span id="cb115-5"><a href="#cb115-5"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span>   <span class="co">// char* aqui</span></span>
<span id="cb115-6"><a href="#cb115-6"></a></span>
<span id="cb115-7"><a href="#cb115-7"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">13</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb115-8"><a href="#cb115-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">[</span>i<span class="op">]);</span>    <span class="co">// ¿Pero seguir usando arrays aquí...?</span></span>
<span id="cb115-9"><a href="#cb115-9"></a><span class="op">}</span></span></code></pre></div>
<p>Y aún podemos utilizar la notación de matrices para imprimirlo. Esto es sorprendente, pero sólo porque aún no hemos hablado de la equivalencia matriz/puntero. Pero esto es otra pista de que los arrays y los punteros son la misma cosa, en el fondo. </p>
<h2 data-number="7.4" id="inicializadores-de-cadenas"><span class="header-section-number">7.4</span> Inicializadores de cadenas</h2>
<p> Ya hemos visto algunos ejemplos con la inicialización de variables de cadena con literales de cadena:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> t<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Hello, again!&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Pero estas dos inicializaciones son sutilmente diferentes. Un literal de cadena, similar a un literal de número entero, tiene su memoria gestionada automáticamente por el compilador. Con un entero, es decir, un dato de tamaño fijo, el compilador puede gestionarlo con bastante facilidad. Pero las cadenas son una bestia de bytes variables que el compilador domestica lanzándolas a un trozo de memoria, y dándote un puntero a él.</p>
<p>Esta forma apunta al lugar donde se colocó esa cadena. Típicamente, ese lugar está en una tierra lejana del resto de la memoria de tu programa – memoria de sólo lectura – por razones relacionadas con el rendimiento y la seguridad.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Entonces, si intentas mutar esa cadena con esto:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>s<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;z&#39;</span><span class="op">;</span>  <span class="co">// MALAS NOTICIAS: ¡intentó mutar una cadena literal!</span></span></code></pre></div>
<p>El comportamiento es indefinido. Probablemente, dependiendo de su sistema, se producirá un fallo.</p>
<p>Pero declararlo como un array es diferente. El compilador no guarda esos bytes en otra parte de la ciudad, están al final de la calle. Esta es una <em>copia</em> mutable de la cadena – una que podemos cambiar a voluntad:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> t<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Hello, again!&quot;</span><span class="op">;</span>  <span class="co">// t es una copia de la cadena </span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>t<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;z&#39;</span><span class="op">;</span> <span class="co">//  No hay problema</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> t<span class="op">);</span>  <span class="co">// &quot;zello, again!&quot;</span></span></code></pre></div>
<p>Así que recuerda: si tienes un puntero a un literal de cadena, ¡no intentes cambiarlo! Y si usas una cadena entre comillas dobles para inicializar un array, no es realmente un literal de cadena. </p>
<h2 data-number="7.5" id="obtención-de-la-longitud-de-la-cadena"><span class="header-section-number">7.5</span> Obtención de la longitud de la cadena</h2>
<p> No puedes, ya que C no lo rastrea por ti. Y cuando digo «no puede», en realidad quiero decir «puede»<a href="#fn62" class="footnote-ref" id="fnref62" role="doc-noteref"><sup>62</sup></a>. Hay una función en <code>&lt;string.h&gt;</code> llamada <code>strlen()</code> que puede usarse para calcular la longitud de cualquier cadena en bytes<a href="#fn63" class="footnote-ref" id="fnref63" role="doc-noteref"><sup>63</sup></a>.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb120-1"><a href="#cb120-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb120-2"><a href="#cb120-2"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb120-3"><a href="#cb120-3"></a></span>
<span id="cb120-4"><a href="#cb120-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb120-5"><a href="#cb120-5"></a><span class="op">{</span></span>
<span id="cb120-6"><a href="#cb120-6"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb120-7"><a href="#cb120-7"></a></span>
<span id="cb120-8"><a href="#cb120-8"></a>    printf<span class="op">(</span><span class="st">&quot;La cadena tiene </span><span class="sc">%zu</span><span class="st"> bytes de longitud.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> strlen<span class="op">(</span>s<span class="op">));</span></span>
<span id="cb120-9"><a href="#cb120-9"></a><span class="op">}</span></span></code></pre></div>
<p>La función <code>strlen()</code> devuelve el tipo <code>size_t</code>, que es un tipo entero por lo que se puede utilizar para matemáticas de enteros. Imprimimos <code>size_t</code> con <code>%zu</code>.</p>
<p>El programa anterior imprime:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>La cadena tiene 13 bytes de longitud.</span></code></pre></div>
<p>Estupendo. ¡Así que <em>es</em> posible obtener la longitud de la cadena! </p>
<p>Pero… si C no rastrea la longitud de la cadena en ninguna parte, ¿cómo sabe cuán larga es la cadena?</p>
<h2 data-number="7.6" id="terminación-de-la-cadena"><span class="header-section-number">7.6</span> Terminación de la cadena</h2>
<p> C hace las cadenas de forma un poco diferente a muchos lenguajes de programación, y de hecho de forma diferente a casi todos los lenguajes de programación modernos.</p>
<p>Cuando estás haciendo un nuevo lenguaje, tienes básicamente dos opciones para almacenar una cadena en memoria:</p>
<ol type="1">
<li><p>Almacenar los bytes de la cadena junto con un número que indica la longitud de la cadena.</p></li>
<li><p>Almacenar los bytes de la cadena, y marcar el final de la cadena con un byte especial llamado <em>terminador</em>.</p></li>
</ol>
<p>Si desea cadenas de más de 255 caracteres, la opción 1 requiere al menos dos bytes para almacenar la longitud. Mientras que la opción 2 sólo requiere un byte para terminar la cadena. Así que se ahorra un poco.</p>
<p>Por supuesto, hoy en día parece ridículo preocuparse por ahorrar un byte (o 3: muchos lenguajes te permiten tener cadenas de 4 gigabytes de longitud). Pero en su día, era un problema mayor.</p>
<p>Así que C adoptó el enfoque nº 2. En C, una «cadena» se define por dos características básicas:</p>
<ul>
<li>Un puntero al primer carácter de la cadena.</li>
<li>Un byte de valor cero (o carácter <code>NUL</code><a href="#fn64" class="footnote-ref" id="fnref64" role="doc-noteref"><sup>64</sup></a>) en algún lugar de la memoria después del puntero que indica el final de la cadena.</li>
</ul>
<p>Un carácter <code>NUL</code> puede escribirse en código C como <code>\0</code>, aunque no es necesario hacerlo a menudo.</p>
<p>Cuando incluyes una cadena entre comillas dobles en tu código, el carácter <code>NUL</code> se incluye automática e implícitamente.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello!&quot;</span><span class="op">;</span>  <span class="co">// En realidad «Hola!\0» entre bastidores</span></span></code></pre></div>
<p>Así que con esto en mente, vamos a escribir nuestra propia función <code>strlen()</code> que cuenta <code>caracteres</code> en una cadena hasta que encuentra un <code>NUL</code>.</p>
<p>El procedimiento es buscar en la cadena un único carácter <code>NUL</code>, contando a medida que avanzamos<a href="#fn65" class="footnote-ref" id="fnref65" role="doc-noteref"><sup>65</sup></a>:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>s<span class="op">[</span>count<span class="op">]</span> <span class="op">!=</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">)</span>  <span class="co">// Comillas simples para caracteres simples</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>        count<span class="op">++;</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Y así es como la función <code>strlen()</code> hace su trabajo. </p>
<h2 data-number="7.7" id="copiar-una-cadena"><span class="header-section-number">7.7</span> Copiar una cadena</h2>
<p> No se puede copiar una cadena mediante el operador de asignación (<code>=</code>). Todo lo que hace es hacer una copia del puntero al primer carácter… por lo que terminas con dos punteros a la misma cadena:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb124-2"><a href="#cb124-2"></a></span>
<span id="cb124-3"><a href="#cb124-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb124-4"><a href="#cb124-4"></a><span class="op">{</span></span>
<span id="cb124-5"><a href="#cb124-5"></a>    <span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb124-6"><a href="#cb124-6"></a>    <span class="dt">char</span> <span class="op">*</span>t<span class="op">;</span></span>
<span id="cb124-7"><a href="#cb124-7"></a></span>
<span id="cb124-8"><a href="#cb124-8"></a>    <span class="co">// Esto hace una copia del puntero, ¡no una copia de la cadena!</span></span>
<span id="cb124-9"><a href="#cb124-9"></a>    t <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb124-10"><a href="#cb124-10"></a></span>
<span id="cb124-11"><a href="#cb124-11"></a>    <span class="co">// Modificamos t</span></span>
<span id="cb124-12"><a href="#cb124-12"></a>    t<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;z&#39;</span><span class="op">;</span></span>
<span id="cb124-13"><a href="#cb124-13"></a></span>
<span id="cb124-14"><a href="#cb124-14"></a>    <span class="co">// ¡Pero imprimir s muestra la modificación!</span></span>
<span id="cb124-15"><a href="#cb124-15"></a>    <span class="co">// ¡Porque t y s apuntan a la misma cadena!</span></span>
<span id="cb124-16"><a href="#cb124-16"></a></span>
<span id="cb124-17"><a href="#cb124-17"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>  <span class="co">// &quot;zello, world!&quot;</span></span>
<span id="cb124-18"><a href="#cb124-18"></a><span class="op">}</span></span></code></pre></div>
<p>Si quieres hacer una copia de una cadena, tienes que copiarla byte a byte—pero esto es más fácil con la función <code>strcpy()</code><a href="#fn66" class="footnote-ref" id="fnref66" role="doc-noteref"><sup>66</sup></a>.</p>
<p>Antes de copiar la cadena, asegúrate de que tienes espacio para copiarla, es decir, la matriz de destino que va a contener los caracteres debe ser al menos tan larga como la cadena que estás copiando.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb125-1"><a href="#cb125-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb125-2"><a href="#cb125-2"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb125-3"><a href="#cb125-3"></a></span>
<span id="cb125-4"><a href="#cb125-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb125-5"><a href="#cb125-5"></a><span class="op">{</span></span>
<span id="cb125-6"><a href="#cb125-6"></a>    <span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb125-7"><a href="#cb125-7"></a>    <span class="dt">char</span> t<span class="op">[</span><span class="dv">100</span><span class="op">];</span>  <span class="co">// Cada char es un byte, así que hay espacio de sobra</span></span>
<span id="cb125-8"><a href="#cb125-8"></a></span>
<span id="cb125-9"><a href="#cb125-9"></a>    <span class="co">// ¡Esto hace una copia de la cadena!</span></span>
<span id="cb125-10"><a href="#cb125-10"></a>    strcpy<span class="op">(</span>t<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb125-11"><a href="#cb125-11"></a></span>
<span id="cb125-12"><a href="#cb125-12"></a>    <span class="co">// Modificamos t</span></span>
<span id="cb125-13"><a href="#cb125-13"></a>    t<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;z&#39;</span><span class="op">;</span></span>
<span id="cb125-14"><a href="#cb125-14"></a></span>
<span id="cb125-15"><a href="#cb125-15"></a>    <span class="co">// Y s no se ve afectada porque es una cadena diferente</span></span>
<span id="cb125-16"><a href="#cb125-16"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>  <span class="co">// &quot;Hello, world!&quot;</span></span>
<span id="cb125-17"><a href="#cb125-17"></a></span>
<span id="cb125-18"><a href="#cb125-18"></a>    <span class="co">// Pero t ha cambiado</span></span>
<span id="cb125-19"><a href="#cb125-19"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> t<span class="op">);</span>  <span class="co">// &quot;zello, world!&quot;</span></span>
<span id="cb125-20"><a href="#cb125-20"></a><span class="op">}</span></span></code></pre></div>
<p>Observe que con <code>strcpy()</code>, el puntero de destino es el primer argumento, y el puntero de origen es el segundo. Una mnemotécnica que uso para recordar esto es que es el orden en el que habrías puesto <code>t</code> y <code>s</code> si una asignación <code>=</code> funcionara para cadenas, con el origen a la derecha y el destino a la izquierda. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="8" id="structs"><span class="header-section-number">8</span> Estructuras (Structs)</h1>
<p> En C, tenemos algo llamado <code>struct</code>, que es un tipo definible por el usuario, el cual, contiene múltiples piezas de datos, potencialmente de diferentes tipos.</p>
<p>Es una forma conveniente de agrupar múltiples variables en una sola. Esto puede ser beneficioso para pasar variables a funciones (así sólo tienes que pasar una en lugar de muchas), y útil para organizar datos y hacer el código más legible.</p>
<p>Si vienes de otro lenguaje, puede que estés familiarizado con la idea de <em>clases</em> y <em>objetos</em>. Estos no existen en C, de forma nativa<a href="#fn67" class="footnote-ref" id="fnref67" role="doc-noteref"><sup>67</sup></a>. Puedes pensar en una <code>struct</code> como una clase con sólo miembros de datos, y sin métodos.</p>
<h2 data-number="8.1" id="declaración-de-una-estructura"><span class="header-section-number">8.1</span> Declaración de una estructura</h2>
<p> Puedes declarar una <code>struct</code> en tu código de la siguiente manera:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> car <span class="op">{</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> price<span class="op">;</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> speed<span class="op">;</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Esto se hace a menudo en el ámbito global, fuera de cualquier función, para que la «estructura» esté disponible globalmente.</p>
<p>Cuando haces esto, estás creando un nuevo <em>tipo</em>. El nombre completo del tipo es <code>struct car</code>. (No sólo <code>car</code>—eso no funcionará).</p>
<p>Todavía no hay variables de ese tipo, pero podemos declarar algunas:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> car saturn<span class="op">;</span>  <span class="co">// Variable «saturn» de tipo «struct car»</span></span></code></pre></div>
<p>Y ahora tenemos una variable no inicializada <code>saturn</code><a href="#fn68" class="footnote-ref" id="fnref68" role="doc-noteref"><sup>68</sup></a> de tipo <code>struct car</code>.</p>
<p>Deberíamos inicializarlo. Pero, ¿cómo establecemos los valores de cada uno de esos campos?</p>
<p>Como en muchos otros lenguajes que lo robaron de C, vamos a usar el operador punto (<code>.</code>) para acceder a los campos individuales.</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>saturn<span class="op">.</span>name <span class="op">=</span> <span class="st">&quot;Saturn SL/2&quot;</span><span class="op">;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>saturn<span class="op">.</span>price <span class="op">=</span> <span class="fl">15999.99</span><span class="op">;</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>saturn<span class="op">.</span>speed <span class="op">=</span> <span class="dv">175</span><span class="op">;</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Name:           </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> saturn<span class="op">.</span>name<span class="op">);</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Price (USD):    </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> saturn<span class="op">.</span>price<span class="op">);</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Top Speed (km): </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> saturn<span class="op">.</span>speed<span class="op">);</span></span></code></pre></div>
<p>Allí en las primeras líneas, establecemos los valores en la <code>struct car</code>, y luego en la siguiente parte, imprimimos esos valores. </p>
<h2 data-number="8.2" id="struct-initializers"><span class="header-section-number">8.2</span> Inicializadores de estructuras</h2>
<p> El ejemplo de la sección anterior era un poco difícil de manejar. Tiene que haber una forma mejor de inicializar esa variable <code>struct</code>.</p>
<p>Puedes hacerlo con un inicializador, poniendo valores en los campos <em>en el orden en que aparecen en la <code>struct</code></em>, cuando defines la variable. (Esto no funcionará después de que la variable haya sido definida - tiene que ocurrir en la definición).</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> car <span class="op">{</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> price<span class="op">;</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> speed<span class="op">;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a><span class="co">// ¡Ahora con un inicializador! Mismo orden de campos que en la declaración struct:</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> car saturn <span class="op">=</span> <span class="op">{</span><span class="st">&quot;Saturn SL/2&quot;</span><span class="op">,</span> <span class="fl">16000.99</span><span class="op">,</span> <span class="dv">175</span><span class="op">};</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Name:      </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> saturn<span class="op">.</span>name<span class="op">);</span></span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Price:     </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> saturn<span class="op">.</span>price<span class="op">);</span></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Top Speed: </span><span class="sc">%d</span><span class="st"> km</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> saturn<span class="op">.</span>speed<span class="op">);</span></span></code></pre></div>
<p>El hecho de que los campos del inicializador tengan que estar en el mismo orden, es un poco raro. Si alguien cambia el orden en <code>struct car</code>, ¡podría romper el resto del código!</p>
<p>Podemos ser más específicos con nuestros inicializadores:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> car saturn <span class="op">=</span> <span class="op">{.</span>speed<span class="op">=</span><span class="dv">175</span><span class="op">,</span> <span class="op">.</span>name<span class="op">=</span><span class="st">&quot;Saturn SL/2&quot;</span><span class="op">};</span></span></code></pre></div>
<p>Ahora, es independiente del orden, en la declaración <code>struct</code>. Lo que sin duda es un código más seguro.</p>
<p>De forma similar a los inicializadores de array, cualquier designador de campo que falte, se inicializa a cero (en este caso, sería <code>.price</code>, que he omitido). </p>
<h2 data-number="8.3" id="paso-de-estructuras-a-funciones"><span class="header-section-number">8.3</span> Paso de estructuras a funciones</h2>
<p> Puedes hacer un par de cosas para pasar una <code>struct</code> a una función.</p>
<ol type="1">
<li>Pasar la <code>struct</code>.</li>
<li>Pasar un puntero a la <code>struct</code>.</li>
</ol>
<p>Recuerda que cuando pasas algo a una función, se hace una <em>copia</em> de esa cosa para que la función opere sobre ella, ya sea una copia de un puntero, un <code>int</code>, una <code>struct</code>, o cualquier otra cosa.</p>
<p>Hay básicamente dos casos en los que querrías pasar un puntero a la <code>struct</code>:</p>
<ol type="1">
<li><p>Necesitas que la función sea capaz de hacer cambios a la <code>struct</code> que fue pasada, y que esos cambios se muestren en la llamada.</p></li>
<li><p>La <code>struct</code> es algo grande y es más caro copiarla en la pila que copiar un puntero<a href="#fn69" class="footnote-ref" id="fnref69" role="doc-noteref"><sup>69</sup></a>.</p></li>
</ol>
<p>Por estas dos razones, es mucho más común pasar un puntero a una <code>estructura</code> es una función, aunque no es ilegal pasar solamente la <code>estructura</code>.</p>
<p>Intentemos pasar un puntero, haciendo una función que nos permita establecer el campo <code>.price</code> de la <code>struct car</code>:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb131-1"><a href="#cb131-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb131-2"><a href="#cb131-2"></a></span>
<span id="cb131-3"><a href="#cb131-3"></a><span class="kw">struct</span> car <span class="op">{</span></span>
<span id="cb131-4"><a href="#cb131-4"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb131-5"><a href="#cb131-5"></a>    <span class="dt">float</span> price<span class="op">;</span></span>
<span id="cb131-6"><a href="#cb131-6"></a>    <span class="dt">int</span> speed<span class="op">;</span></span>
<span id="cb131-7"><a href="#cb131-7"></a><span class="op">};</span></span>
<span id="cb131-8"><a href="#cb131-8"></a></span>
<span id="cb131-9"><a href="#cb131-9"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb131-10"><a href="#cb131-10"></a><span class="op">{</span></span>
<span id="cb131-11"><a href="#cb131-11"></a>    <span class="kw">struct</span> car saturn <span class="op">=</span> <span class="op">{.</span>speed<span class="op">=</span><span class="dv">175</span><span class="op">,</span> <span class="op">.</span>name<span class="op">=</span><span class="st">&quot;Saturn SL/2&quot;</span><span class="op">};</span></span>
<span id="cb131-12"><a href="#cb131-12"></a></span>
<span id="cb131-13"><a href="#cb131-13"></a>    <span class="co">// Pasar un puntero a este coche struct, junto con un nuevo,</span></span>
<span id="cb131-14"><a href="#cb131-14"></a>    <span class="co">// más realista, precio:</span></span>
<span id="cb131-15"><a href="#cb131-15"></a>    set_price<span class="op">(&amp;</span>saturn<span class="op">,</span> <span class="fl">799.99</span><span class="op">);</span></span>
<span id="cb131-16"><a href="#cb131-16"></a></span>
<span id="cb131-17"><a href="#cb131-17"></a>    printf<span class="op">(</span><span class="st">&quot;Price: </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> saturn<span class="op">.</span>price<span class="op">);</span></span>
<span id="cb131-18"><a href="#cb131-18"></a><span class="op">}</span></span></code></pre></div>
<p>Usted debe ser capaz de llegar a la firma de la función para <code>set_price()</code> con sólo mirar los tipos de los argumentos que tenemos.</p>
<p><code>saturn</code> es un <code>struct car</code>, así que <code>&amp;saturn</code> debe ser la dirección del <code>struct car</code>, es decir, un puntero a un <code>struct car</code>, un <code>struct car*</code>.</p>
<p>Y <code>799.99</code> es un <code>float</code>.</p>
<p>Así que la declaración de la función debe tener este aspecto:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> set_price<span class="op">(</span><span class="kw">struct</span> car <span class="op">*</span>c<span class="op">,</span> <span class="dt">float</span> new_price<span class="op">)</span></span></code></pre></div>
<p>Sólo tenemos que escribir el cuerpo. Un intento podría ser:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> set_price<span class="op">(</span><span class="kw">struct</span> car <span class="op">*</span>c<span class="op">,</span> <span class="dt">float</span> new_price<span class="op">)</span> <span class="op">{</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>price <span class="op">=</span> new_price<span class="op">;</span>  <span class="co">// ERROR!!</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Eso no funcionará porque el operador punto sólo funciona en <code>struct</code>s… no funciona en <em>punteros</em> a <code>struct</code>s.</p>
<p>Entonces podemos desreferenciar la variable <code>c</code> para des-apuntarla y llegar a la propia <code>struct</code>. Dereferenciar una <code>struct car*</code> resulta en la <code>struct car</code> a la que apunta el puntero, sobre la que deberíamos poder usar el operador punto:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> set_price<span class="op">(</span><span class="kw">struct</span> car <span class="op">*</span>c<span class="op">,</span> <span class="dt">float</span> new_price<span class="op">)</span> <span class="op">{</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*</span>c<span class="op">).</span>price <span class="op">=</span> new_price<span class="op">;</span>  <span class="co">// Funciona, pero es feo y no idiomático :(</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Y funciona. Pero es un poco engorroso teclear todos esos paréntesis y el asterisco. C tiene un azúcar sintáctico llamado, operador <em>flecha</em> <em>(arrow)</em> que ayuda con eso. </p>
<h2 data-number="8.4" id="el-operador-arrow-flecha--"><span class="header-section-number">8.4</span> El operador Arrow / flecha (-&gt;)</h2>
<p> El operador flecha ayuda a referirse a campos en punteros a <code>struct</code>s.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> set_price<span class="op">(</span><span class="kw">struct</span> car <span class="op">*</span>c<span class="op">,</span> <span class="dt">float</span> new_price<span class="op">)</span> <span class="op">{</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (*c).price = new_price;  // Funciona, pero no es idiomático :(</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// La línea de arriba es 100% equivalente a la de abajo:</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>    c<span class="op">-&gt;</span>price <span class="op">=</span> new_price<span class="op">;</span>  <span class="co">// ¡Ese es!</span></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Así que.. cuando accedemos a campos, ¿cuándo usamos punto, y cuándo usamos flecha?</p>
<ul>
<li>Si tienes una <code>struct</code>, usa punto (<code>.</code>).</li>
<li>Si tienes un puntero a una <code>struct</code>, usa arrow/flecha (<code>-&gt;</code>). </li>
</ul>
<h2 data-number="8.5" id="copiar-y-devolver-structs"><span class="header-section-number">8.5</span> Copiar y devolver <code>struct</code>s</h2>
<p> Aquí tienes una fácil.</p>
<p>¡Sólo tienes que asignar de uno a otro!</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> car a<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a<span class="op">;</span>  <span class="co">// Copiar la estructura</span></span></code></pre></div>
<p>Devolver una <code>estructura</code> (en lugar de un puntero a una) desde una función, también hace una copia similar a la variable receptora.</p>
<p>Esto no es una «copia profunda»<a href="#fn70" class="footnote-ref" id="fnref70" role="doc-noteref"><sup>70</sup></a>. Todos los campos se copian tal cual, incluyendo los punteros a cosas. </p>
<h2 data-number="8.6" id="comparación-de-structs"><span class="header-section-number">8.6</span> Comparación de <code>struct</code>s</h2>
<p> Sólo hay una forma segura de hacerlo: comparar cada campo de uno en uno.</p>
<p>Podrías pensar que podrías utilizar <a href="https://beej.us/guide/bgclr/html/split/stringref.html#man-strcmp"><code>memcmp()</code></a><a href="#fn71" class="footnote-ref" id="fnref71" role="doc-noteref"><sup>71</sup></a>, pero eso no maneja el caso de los posibles <a href="#struct-padding-bytes">bytes de relleno</a> que pueda haber.</p>
<p>Si primero borras la <code>struct</code> a cero con <a href="https://beej.us/guide/bgclr/html/split/stringref.html#man-memset"><code>memset()</code></a><a href="#fn72" class="footnote-ref" id="fnref72" role="doc-noteref"><sup>72</sup></a>, entonces <em>podría</em> funcionar, aunque podría haber elementos extraños que <a href="https://stackoverflow.com/questions/141720/how-do-you-compare-structs-for-equality-in-c">puede que no se compare como usted espera</a><a href="#fn73" class="footnote-ref" id="fnref73" role="doc-noteref"><sup>73</sup></a>. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="9" id="archivo-de-entradasalida-inputoutput"><span class="header-section-number">9</span> Archivo de Entrada/Salida (Input/Output)</h1>
<p> Ya hemos visto algunos ejemplos de E/S con <code>printf()</code> para hacer E/S en la consola.</p>
<p>Pero llevaremos estos conceptos un poco más lejos en este capítulo.</p>
<h2 data-number="9.1" id="el-tipo-de-dato-file."><span class="header-section-number">9.1</span> El tipo de dato <code>FILE*</code>.</h2>
<p> Cuando hacemos cualquier tipo de E/S en C, lo hacemos a través de un dato que se obtiene en forma de un tipo <code>FILE*</code>. Este <code>FILE*</code> contiene toda la información necesaria, para comunicarse con el subsistema de E/S acerca de qué fichero tienes abierto, en qué parte del fichero te encuentras, etc.</p>
<p>La especificación se refiere a estos como <em>streams</em>, es decir, un flujo de datos de un archivo o de cualquier fuente. Voy a utilizar «archivos (File)» y «flujos (streams)» indistintamente, pero en realidad deberías pensar en un «archivo (File)» como un caso especial de un «flujo (Stream)». Hay otras formas de introducir datos en un programa además de leerlos de un fichero.</p>
<p>Veremos en un momento, cómo pasar de tener un nombre de fichero, a obtener un <code>FILE*</code> abierto para él, pero primero quiero mencionar tres flujos que ya están abiertos para ti y listos para usar.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th><code>FILE*</code> nombre</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>stdin</code></td>
<td>Entrada estándar, generalmente por defecto es el teclado</td>
</tr>
<tr class="even">
<td><code>stdout</code></td>
<td>Salida estándar, generalmente por defecto es la pantalla</td>
</tr>
<tr class="odd">
<td><code>stderr</code></td>
<td>Error estándar, generalmente por defecto es la pantalla</td>
</tr>
</tbody>
</table>
<p>Resulta que ya los hemos estado utilizando implícitamente. Por ejemplo, estas dos llamadas son iguales:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>fprintf<span class="op">(</span>stdout<span class="op">,</span> <span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// printf a un fichero</span></span></code></pre></div>
<p>Pero hablaremos de ello más adelante.</p>
<p>También notarás que tanto <code>stdout</code> como <code>stderr</code> van a la pantalla. Aunque al principio esto parece un descuido o una redundancia, en realidad no lo es. Los sistemas operativos típicos, te permiten <em>redirigir</em> la salida de cualquiera de ellos a archivos diferentes, y puede ser conveniente poder separar los mensajes de error, de la salida normal que no es de error.</p>
<p>Por ejemplo, en un shell POSIX (como sh, ksh, bash, zsh, etc.) en un sistema tipo Unix, podríamos ejecutar un programa y enviar sólo la salida no error (<code>stdout</code>) a un fichero, y toda la salida error (<code>stderr</code>) a otro fichero.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./foo</span> <span class="op">&gt;</span> output.txt <span class="dv">2</span><span class="op">&gt;</span> errors.txt   <span class="co"># Este comando es específico de Unix</span></span></code></pre></div>
<p>Por este motivo, debe enviar los mensajes de error graves a <code>stderr</code> en lugar de a <code>stdout</code>. </p>
<p>Más adelante se explica cómo hacerlo. </p>
<h2 data-number="9.2" id="lectura-de-archivos-de-texto"><span class="header-section-number">9.2</span> Lectura de archivos de texto</h2>
<p></p>
<p>Los flujos se clasifican en dos categorías diferentes: <em>texto</em> y <em>binario</em>.</p>
<p>A los flujos de texto, se les permite hacer traducciones significativas de los datos, sobre todo, traducciones de nuevas líneas a sus diferentes representaciones<a href="#fn74" class="footnote-ref" id="fnref74" role="doc-noteref"><sup>74</sup></a>. Los archivos de texto son lógicamente una secuencia de <em>líneas</em> separadas por nuevas líneas. Para que sean portables, los datos de entrada deben terminar siempre con una nueva línea.</p>
<p>Pero la regla general, es que si puedes editar el archivo en un editor de texto normal, es un archivo de texto. En caso contrario, es binario. Hablaremos más sobre binario en un momento.</p>
<p>Así que manos a la obra: ¿cómo abrimos un archivo para leerlo y extraer datos de él?</p>
<p>Creemos un archivo llamado <code>hello.txt</code> que contenga esto:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>Hello, world!</span></code></pre></div>
<p>Y vamos a escribir un programa para abrir el archivo, leer un carácter fuera de él, y luego cerrar el archivo cuando hayamos terminado. ¡Ese es el plan!</p>
<p> </p>
<div class="sourceCode" id="cb140"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb140-1"><a href="#cb140-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb140-2"><a href="#cb140-2"></a></span>
<span id="cb140-3"><a href="#cb140-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb140-4"><a href="#cb140-4"></a><span class="op">{</span></span>
<span id="cb140-5"><a href="#cb140-5"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">;</span>                      <span class="co">// Variable para representar el archivo abierto</span></span>
<span id="cb140-6"><a href="#cb140-6"></a></span>
<span id="cb140-7"><a href="#cb140-7"></a>    fp <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;hello.txt&quot;</span><span class="op">,</span> <span class="st">&quot;r&quot;</span><span class="op">);</span>  <span class="co">// Abrir archivo para lectura</span></span>
<span id="cb140-8"><a href="#cb140-8"></a></span>
<span id="cb140-9"><a href="#cb140-9"></a>    <span class="dt">int</span> c <span class="op">=</span> fgetc<span class="op">(</span>fp<span class="op">);</span>             <span class="co">// Leer un solo carácter</span></span>
<span id="cb140-10"><a href="#cb140-10"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">);</span>             <span class="co">// Imprimir char en stdout</span></span>
<span id="cb140-11"><a href="#cb140-11"></a></span>
<span id="cb140-12"><a href="#cb140-12"></a>    fclose<span class="op">(</span>fp<span class="op">);</span>                    <span class="co">// Cierre el archivo cuando haya terminado</span></span></code></pre></div>
<p>Mira como, cuando abrimos el fichero con <code>fopen()</code>, nos devolvió el <code>FILE*</code> para que pudiéramos usarlo más tarde.</p>
<p>(Lo estoy omitiendo por brevedad, pero <code>fopen()</code> devolverá <code>NULL</code> si algo va mal, como file-not-found (archivo no encontrado), ¡así que deberías comprobar el error!)</p>
<p>Fíjate también en la <code>«r»</code> que pasamos—esto significa «abrir un flujo de texto para lectura». (Hay varias cadenas que podemos pasar a <code>fopen()</code> con significado adicional, como escribir, o añadir, etc.). </p>
<p>Después, usamos la función <code>fgetc()</code> para obtener un carácter del flujo. Te estarás preguntando, por qué he hecho que <code>c</code> sea un <code>int</code> en lugar de un <code>char</code>… ¡espera un momento! </p>
<p>Por último, cerramos el flujo cuando hemos terminado con él. Todos los flujos se cierran automáticamente cuando el programa se cierra, pero es de buena educación y buena limpieza cerrar explícitamente cualquier archivo cuando se termina con ellos. </p>
<p>El <code>FILE*</code> mantiene un registro de nuestra posición en el fichero. Así, las siguientes llamadas a <code>fgetc()</code> obtendrían el siguiente carácter del fichero, y luego el siguiente, hasta el final.</p>
<p>Pero eso parece complicado. Veamos si podemos hacerlo más fácil. </p>
<h2 data-number="9.3" id="fin-de-fichero-eof"><span class="header-section-number">9.3</span> Fin de fichero: <code>EOF</code></h2>
<p> Existe un carácter especial definido como macro: <code>EOF</code>. Esto es lo que <code>fgetc()</code> devolverá cuando se haya alcanzado el final del fichero y haya intentado leer otro carácter.</p>
<p>Qué tal si comparto ese Fun Fact™(Hecho divertido / Hecho curioso), ahora. Resulta que <code>EOF</code> es la razón por la que <code>fgetc()</code> y funciones similares devuelven un <code>int</code> en lugar de un <code>char</code>. <code>EOF</code> no es un carácter propiamente dicho, y su valor probablemente cae fuera del rango de <code>char</code>. Dado que <code>fgetc()</code> necesita ser capaz de devolver cualquier byte <strong>y</strong> <code>EOF</code>, necesita ser un tipo más amplio que pueda contener más valores, así que será <code>int</code>. Pero a menos que estés comparando el valor devuelto con <code>EOF</code>, puedes saber, en el fondo, que es un <code>char</code>.</p>
<p>¡Muy bien! ¡Volvemos a la realidad! Podemos usar esto para leer todo el archivo en un bucle. </p>
<div class="sourceCode" id="cb141"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb141-1"><a href="#cb141-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb141-2"><a href="#cb141-2"></a></span>
<span id="cb141-3"><a href="#cb141-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb141-4"><a href="#cb141-4"></a><span class="op">{</span></span>
<span id="cb141-5"><a href="#cb141-5"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">;</span></span>
<span id="cb141-6"><a href="#cb141-6"></a>    <span class="dt">int</span> c<span class="op">;</span></span>
<span id="cb141-7"><a href="#cb141-7"></a></span>
<span id="cb141-8"><a href="#cb141-8"></a>    fp <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;hello.txt&quot;</span><span class="op">,</span> <span class="st">&quot;r&quot;</span><span class="op">);</span></span>
<span id="cb141-9"><a href="#cb141-9"></a></span>
<span id="cb141-10"><a href="#cb141-10"></a>    <span class="cf">while</span> <span class="op">((</span>c <span class="op">=</span> fgetc<span class="op">(</span>fp<span class="op">))</span> <span class="op">!=</span> EOF<span class="op">)</span></span>
<span id="cb141-11"><a href="#cb141-11"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">);</span></span>
<span id="cb141-12"><a href="#cb141-12"></a></span>
<span id="cb141-13"><a href="#cb141-13"></a>    fclose<span class="op">(</span>fp<span class="op">);</span></span>
<span id="cb141-14"><a href="#cb141-14"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>(Si la línea 10 es demasiado rara, basta con descomponerla empezando por los paréntesis más internos. Lo primero que hacemos es asignar el resultado de <code>fgetc()</code> a <code>c</code>, y <em>luego</em> comparamos <em>eso</em> con <code>EOF</code>. Lo hemos metido todo en una sola línea. Esto puede parecer difícil de leer, pero estúdialo—es C idiomático). </p>
<p>Y ejecutando esto, vemos:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>Hello, world!</span></code></pre></div>
<p>Pero aún así, estamos operando carácter por carácter, y muchos archivos de texto tienen más sentido a nivel de línea. Vamos a cambiar a eso. </p>
<h3 data-number="9.3.1" id="leer-línea-a-línea"><span class="header-section-number">9.3.1</span> Leer línea a línea</h3>
<p> Entonces, ¿cómo podemos obtener una línea entera de una vez? <code>fgets()</code> ¡al rescate! Como argumentos, toma un puntero a un buffer <code>char</code> para almacenar bytes, un número máximo de bytes a leer, y un <code>FILE*</code> del que leer. Devuelve <code>NULL</code> al final del archivo o en caso de error. <code>fgets()</code> es incluso lo suficientemente amable como para terminar con NUL la cadena cuando ha terminado<a href="#fn75" class="footnote-ref" id="fnref75" role="doc-noteref"><sup>75</sup></a>. </p>
<p>Vamos a hacer un bucle similar al anterior, excepto que vamos a tener un fichero multilínea y lo vamos a leer línea a línea.</p>
<p>Aquí hay un archivo <code>quote.txt</code>:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>Un hombre sabio puede aprender más de</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>una pregunta tonta que un tonto</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>puede aprender de una respuesta sabia.</span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>                  --Bruce Lee</span></code></pre></div>
<p>Y aquí hay algo de código que lee ese archivo línea por línea e imprime un número de línea antes de cada una:</p>
<p></p>
<div class="sourceCode" id="cb144"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb144-1"><a href="#cb144-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb144-2"><a href="#cb144-2"></a></span>
<span id="cb144-3"><a href="#cb144-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb144-4"><a href="#cb144-4"></a><span class="op">{</span></span>
<span id="cb144-5"><a href="#cb144-5"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">;</span></span>
<span id="cb144-6"><a href="#cb144-6"></a>    <span class="dt">char</span> s<span class="op">[</span><span class="dv">1024</span><span class="op">];</span>  <span class="co">// Suficientemente grande para cualquier línea</span></span>
<span id="cb144-7"><a href="#cb144-7"></a>                   <span class="co">// que encuentre este programa.</span></span>
<span id="cb144-8"><a href="#cb144-8"></a></span>
<span id="cb144-9"><a href="#cb144-9"></a>    <span class="dt">int</span> linecount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb144-10"><a href="#cb144-10"></a></span>
<span id="cb144-11"><a href="#cb144-11"></a>    fp <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;quote.txt&quot;</span><span class="op">,</span> <span class="st">&quot;r&quot;</span><span class="op">);</span></span>
<span id="cb144-12"><a href="#cb144-12"></a></span>
<span id="cb144-13"><a href="#cb144-13"></a>    <span class="cf">while</span> <span class="op">(</span>fgets<span class="op">(</span>s<span class="op">,</span> <span class="kw">sizeof</span> s<span class="op">,</span> fp<span class="op">)</span> <span class="op">!=</span> NULL<span class="op">)</span> </span>
<span id="cb144-14"><a href="#cb144-14"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">: </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">++</span>linecount<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb144-15"><a href="#cb144-15"></a></span>
<span id="cb144-16"><a href="#cb144-16"></a>    fclose<span class="op">(</span>fp<span class="op">);</span></span>
<span id="cb144-17"><a href="#cb144-17"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Lo que da la salida:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>1: Un hombre sabio puede aprender más de</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>2: una pregunta tonta que un tonto</span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>3: puede aprender de una respuesta sabia.</span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>4:                   --Bruce Lee</span></code></pre></div>
<p></p>
<h2 data-number="9.4" id="entrada-con-formato"><span class="header-section-number">9.4</span> Entrada con formato</h2>
<p> ¿Sabes cómo puedes obtener una salida formateada con <code>printf()</code> (y, por tanto, <code>fprintf()</code> como veremos, más adelante)? Puede hacer lo mismo con <code>fscanf()</code>.</p>
<blockquote>
<p>Antes de empezar, deberías saber que usar funciones del estilo de <code>scanf()</code> puede ser peligroso con entradas no confiables. Si no especifica anchos de campo con tu <code>%s</code>, podrías desbordar el buffer. Peor aún, una conversión numérica inválida puede resultar en un comportamiento indefinido. Lo más seguro es usar <code>%s</code> con un ancho de campo, luego usar funciones como <code>strtol()</code> o <code>strtod()</code> para hacer las conversiones.</p>
</blockquote>
<p>Dispongamos de un fichero con una serie de registros de datos. En este caso, ballenas, con nombre, longitud en metros y peso en toneladas. <code>ballenas.txt</code>:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>blue 29.9 173</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>right 20.7 135</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>gray 14.9 41</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>humpback 16.0 30</span></code></pre></div>
<p>Sí, podríamos leerlos con <code>fgets()</code> y luego analizar la cadena con <code>sscanf()</code> (y en eso es más resistente contra archivos corruptos), pero en este caso, vamos a usar <code>fscanf()</code> y sacarlo directamente.</p>
<p>La función <code>fscanf()</code> se salta los espacios en blanco al leer, y devuelve <code>EOF</code> al final del fichero o en caso de error.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb147-1"><a href="#cb147-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb147-2"><a href="#cb147-2"></a></span>
<span id="cb147-3"><a href="#cb147-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb147-4"><a href="#cb147-4"></a><span class="op">{</span></span>
<span id="cb147-5"><a href="#cb147-5"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">;</span></span>
<span id="cb147-6"><a href="#cb147-6"></a>    <span class="dt">char</span> name<span class="op">[</span><span class="dv">1024</span><span class="op">];</span>  <span class="co">// Suficientemente grande para cualquier</span></span>
<span id="cb147-7"><a href="#cb147-7"></a>                      <span class="co">//línea que encuentre este programa.</span></span>
<span id="cb147-8"><a href="#cb147-8"></a>    <span class="dt">float</span> length<span class="op">;</span></span>
<span id="cb147-9"><a href="#cb147-9"></a>    <span class="dt">int</span> mass<span class="op">;</span></span>
<span id="cb147-10"><a href="#cb147-10"></a></span>
<span id="cb147-11"><a href="#cb147-11"></a>    fp <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;whales.txt&quot;</span><span class="op">,</span> <span class="st">&quot;r&quot;</span><span class="op">);</span></span>
<span id="cb147-12"><a href="#cb147-12"></a></span>
<span id="cb147-13"><a href="#cb147-13"></a>    <span class="cf">while</span> <span class="op">(</span>fscanf<span class="op">(</span>fp<span class="op">,</span> <span class="st">&quot;</span><span class="sc">%s</span><span class="st"> </span><span class="sc">%f</span><span class="st"> </span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">,</span> <span class="op">&amp;</span>length<span class="op">,</span> <span class="op">&amp;</span>mass<span class="op">)</span> <span class="op">!=</span> EOF<span class="op">)</span></span>
<span id="cb147-14"><a href="#cb147-14"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st"> whale, </span><span class="sc">%d</span><span class="st"> tonnes, </span><span class="sc">%.1f</span><span class="st"> meters</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">,</span> mass<span class="op">,</span> length<span class="op">);</span></span>
<span id="cb147-15"><a href="#cb147-15"></a></span>
<span id="cb147-16"><a href="#cb147-16"></a>    fclose<span class="op">(</span>fp<span class="op">);</span></span>
<span id="cb147-17"><a href="#cb147-17"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Lo que da el resultado:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>blue whale, 173 tonnes, 29.9 meters</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>right whale, 135 tonnes, 20.7 meters</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>gray whale, 41 tonnes, 14.9 meters</span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>humpback whale, 30 tonnes, 16.0 meters</span></code></pre></div>
<p></p>
<h2 data-number="9.5" id="escribir-archivos-de-texto"><span class="header-section-number">9.5</span> Escribir archivos de texto</h2>
<p> Del mismo modo que podemos usar <code>fgetc()</code>, <code>fgets()</code> y <code>fscanf()</code> para leer flujos de texto, podemos usar <code>fputc()</code>, <code>fputs()</code> y <code>fprintf()</code> para escribir flujos de texto.</p>
<p>Para ello, tenemos que <code>fopen()</code> el archivo, en modo de escritura pasando <code>«w»</code> como segundo argumento. Abrir un fichero existente en modo <code>«w»</code> truncará instantáneamente ese fichero a 0 bytes para una sobreescritura completa.</p>
<p>Vamos a montar un programa sencillo que da salida a un archivo <code>output.txt</code> usando una variedad de funciones de salida.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb149-1"><a href="#cb149-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb149-2"><a href="#cb149-2"></a></span>
<span id="cb149-3"><a href="#cb149-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb149-4"><a href="#cb149-4"></a><span class="op">{</span></span>
<span id="cb149-5"><a href="#cb149-5"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">;</span></span>
<span id="cb149-6"><a href="#cb149-6"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb149-7"><a href="#cb149-7"></a></span>
<span id="cb149-8"><a href="#cb149-8"></a>    fp <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;output.txt&quot;</span><span class="op">,</span> <span class="st">&quot;w&quot;</span><span class="op">);</span></span>
<span id="cb149-9"><a href="#cb149-9"></a></span>
<span id="cb149-10"><a href="#cb149-10"></a>    fputc<span class="op">(</span><span class="ch">&#39;B&#39;</span><span class="op">,</span> fp<span class="op">);</span></span>
<span id="cb149-11"><a href="#cb149-11"></a>    fputc<span class="op">(</span><span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">,</span> fp<span class="op">);</span>   <span class="co">// Salto de linea</span></span>
<span id="cb149-12"><a href="#cb149-12"></a>    fprintf<span class="op">(</span>fp<span class="op">,</span> <span class="st">&quot;x = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb149-13"><a href="#cb149-13"></a>    fputs<span class="op">(</span><span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> fp<span class="op">);</span></span>
<span id="cb149-14"><a href="#cb149-14"></a></span>
<span id="cb149-15"><a href="#cb149-15"></a>    fclose<span class="op">(</span>fp<span class="op">);</span></span>
<span id="cb149-16"><a href="#cb149-16"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Y esto produce un archivo, <code>output.txt</code>, con el siguiente contenido:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>B</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>x = 32</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>Hello, world!</span></code></pre></div>
<p>Dato curioso: como <code>stdout</code> es un archivo, podrías sustituir la línea 8 por:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>fp <span class="op">=</span> stdout<span class="op">;</span></span></code></pre></div>
<p>y el programa habría dado salida a la consola en lugar de a un archivo. Pruébalo.</p>
<p></p>
<h2 data-number="9.6" id="es-de-archivos-binarios"><span class="header-section-number">9.6</span> E/S de archivos binarios</h2>
<p> Hasta ahora sólo hemos hablado de archivos de texto. Pero existe esa otra bestia que mencionamos al principio llamada archivos <em>binarios</em>, o flujos binarios.</p>
<p>Funcionan de forma muy similar a los archivos de texto, excepto que el subsistema de E/S no realiza ninguna traducción de los datos como haría con un archivo de texto. Con los archivos binarios, se obtiene un flujo de bytes sin procesar, y eso es todo.</p>
<p>La gran diferencia al abrir el fichero es que tienes que añadir una <code>«b»</code> al modo. Es decir, para leer un fichero binario, ábralo en modo «rb». Para escribir un fichero, ábrelo en modo «wb».</p>
<p>Como son flujos de bytes, y los flujos de bytes pueden contener caracteres NUL, y el carácter NUL es el marcador de fin de cadena en C, es raro que la gente use las funciones <code>fprintf()</code> y amigas para operar con ficheros binarios. En cambio, las funciones más comunes son <code>fread()</code> y <code>fwrite()</code>. Las funciones leen y escriben un número especificado de bytes en el flujo.</p>
<p>Para la demostración, escribiremos un par de programas. Uno escribirá una secuencia de valores de bytes en el disco de una sola vez. Y el segundo programa leerá un byte a la vez y los imprimirá<a href="#fn76" class="footnote-ref" id="fnref76" role="doc-noteref"><sup>76</sup></a>.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb152-1"><a href="#cb152-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb152-2"><a href="#cb152-2"></a></span>
<span id="cb152-3"><a href="#cb152-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb152-4"><a href="#cb152-4"></a><span class="op">{</span></span>
<span id="cb152-5"><a href="#cb152-5"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">;</span></span>
<span id="cb152-6"><a href="#cb152-6"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> bytes<span class="op">[</span><span class="dv">6</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">88</span><span class="op">,</span> <span class="dv">255</span><span class="op">,</span> <span class="dv">12</span><span class="op">};</span></span>
<span id="cb152-7"><a href="#cb152-7"></a></span>
<span id="cb152-8"><a href="#cb152-8"></a>    fp <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;output.bin&quot;</span><span class="op">,</span> <span class="st">&quot;wb&quot;</span><span class="op">);</span>  <span class="co">// ¡modo wb para &quot;escribir binario&quot;!</span></span>
<span id="cb152-9"><a href="#cb152-9"></a></span>
<span id="cb152-10"><a href="#cb152-10"></a>    <span class="co">// En la llamada a fwrite, los argumentos son:</span></span>
<span id="cb152-11"><a href="#cb152-11"></a>    <span class="co">//</span></span>
<span id="cb152-12"><a href="#cb152-12"></a>    <span class="co">// * Puntero a los datos a escribir</span></span>
<span id="cb152-13"><a href="#cb152-13"></a>    <span class="co">// * Tamaño de cada «pieza» de datos</span></span>
<span id="cb152-14"><a href="#cb152-14"></a>    <span class="co">// * Recuento de cada «pieza» de datos</span></span>
<span id="cb152-15"><a href="#cb152-15"></a>    <span class="co">// * ARCHIVO</span></span>
<span id="cb152-16"><a href="#cb152-16"></a></span>
<span id="cb152-17"><a href="#cb152-17"></a>    fwrite<span class="op">(</span>bytes<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">),</span> <span class="dv">6</span><span class="op">,</span> fp<span class="op">);</span></span>
<span id="cb152-18"><a href="#cb152-18"></a></span>
<span id="cb152-19"><a href="#cb152-19"></a>    fclose<span class="op">(</span>fp<span class="op">);</span></span>
<span id="cb152-20"><a href="#cb152-20"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Esos dos argumentos centrales de <code>fwrite()</code> son bastante extraños. Pero básicamente lo que queremos decirle a la función es: «Tenemos elementos que son <em>así</em> de grandes, y queremos escribir <em>así</em> muchos de ellos». Esto hace que sea conveniente si usted tiene un registro de una longitud fija, y usted tiene un montón de ellos en una matriz. Sólo tienes que decirle el tamaño de un registro y cuántos escribir.</p>
<p>En el ejemplo anterior, le decimos que cada registro es del tamaño de un <code>char</code>, y tenemos 6 de ellos.</p>
<p>Ejecutando el programa obtenemos un fichero <code>output.bin</code>, pero al abrirlo en un editor de texto no aparece nada amigable. Son datos binarios, no texto. Y datos binarios aleatorios que me acabo de inventar.</p>
<p>Si lo paso por un programa <a href="https://en.wikipedia.org/wiki/Hex_dump">hex dump</a><a href="#fn77" class="footnote-ref" id="fnref77" role="doc-noteref"><sup>77</sup></a>, podemos ver la salida como bytes:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>05 25 00 58 ff 0c</span></code></pre></div>
<p>Y esos valores en hexadecimal coinciden con los valores (en decimal) que escribimos.</p>
<p>Pero ahora vamos a intentar leerlos de nuevo con un programa diferente. Este abrirá el fichero para lectura binaria (modo <code>«rb»</code>) y leerá los bytes de uno en uno en un bucle.</p>
<p> La función <code>fread()</code> devuelve el número de bytes leídos, o <code>0</code> en caso de EOF. Así que podemos hacer un bucle hasta que veamos eso, imprimiendo números a medida que avanzamos.</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb154-1"><a href="#cb154-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb154-2"><a href="#cb154-2"></a></span>
<span id="cb154-3"><a href="#cb154-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb154-4"><a href="#cb154-4"></a><span class="op">{</span></span>
<span id="cb154-5"><a href="#cb154-5"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">;</span></span>
<span id="cb154-6"><a href="#cb154-6"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb154-7"><a href="#cb154-7"></a></span>
<span id="cb154-8"><a href="#cb154-8"></a>    fp <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;output.bin&quot;</span><span class="op">,</span> <span class="st">&quot;rb&quot;</span><span class="op">);</span> <span class="co">// ¡rb para «leer binario»!</span></span>
<span id="cb154-9"><a href="#cb154-9"></a></span>
<span id="cb154-10"><a href="#cb154-10"></a>    <span class="cf">while</span> <span class="op">(</span>fread<span class="op">(&amp;</span>c<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">),</span> <span class="dv">1</span><span class="op">,</span> fp<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb154-11"><a href="#cb154-11"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">);</span></span>
<span id="cb154-12"><a href="#cb154-12"></a></span>
<span id="cb154-13"><a href="#cb154-13"></a>    fclose<span class="op">(</span>fp<span class="op">);</span></span>
<span id="cb154-14"><a href="#cb154-14"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Y, al ejecutarlo, ¡vemos nuestros números originales!</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>5</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>37</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>0</span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>88</span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>255</span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>12</span></code></pre></div>
<p>Woo hoo! </p>
<h3 data-number="9.6.1" id="struct-y-advertencias-sobre-números"><span class="header-section-number">9.6.1</span> <code>struct</code> y advertencias sobre números</h3>
<p> Como vimos en la sección <code>struct</code>s, el compilador es libre de añadir relleno a una <code>struct</code> como considere oportuno. Y diferentes compiladores pueden hacer esto de manera diferente. Y el mismo compilador en diferentes arquitecturas podría hacerlo de forma diferente. Y el mismo compilador en las mismas arquitecturas podría hacerlo de manera diferente.</p>
<p>A lo que quiero llegar es a esto: no es portable simplemente <code>fwrite()</code> una <code>struct</code> entera a un fichero cuando no sabes dónde acabará el relleno. </p>
<p>¿Cómo solucionarlo? Espera un momento… veremos algunas formas de hacerlo después de analizar otro problema relacionado.</p>
<p> Números.</p>
<p>Resulta que no todas las arquitecturas representan los números en memoria de la misma manera.</p>
<p>Veamos una simple <code>fwrite()</code> de un número de 2 bytes. Lo escribiremos en hexadecimal para que cada byte sea claro. El byte más significativo tendrá el valor <code>0x12</code> y el menos significativo tendrá el valor <code>0x34</code>.</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">short</span> v <span class="op">=</span> <span class="bn">0x1234</span><span class="op">;</span>  <span class="co">// Dos bytes, 0x12 y 0x34</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>fwrite<span class="op">(&amp;</span>v<span class="op">,</span> <span class="kw">sizeof</span> v<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> fp<span class="op">);</span></span></code></pre></div>
<p>¿Qué termina en el flujo?</p>
<p>Bueno, parece que debería ser <code>0x12</code> seguido de <code>0x34</code>, ¿no?</p>
<p>Pero si ejecuto esto en mi máquina y volcado hexadecimal el resultado, me sale:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>34 12</span></code></pre></div>
<p>¡Están al revés! ¿Por qué?</p>
<p>Esto tiene algo que ver con lo que se llama el <a href="https://en.wikipedia.org/wiki/Endianess"><em>endianess</em></a><a href="#fn78" class="footnote-ref" id="fnref78" role="doc-noteref"><sup>78</sup></a> de la arquitectura. Algunas escriben primero los bytes más significativos y otras los menos significativos.</p>
<p>Esto significa que si escribes un número multibyte directamente desde la memoria, no puedes hacerlo de forma portable<a href="#fn79" class="footnote-ref" id="fnref79" role="doc-noteref"><sup>79</sup></a>.</p>
<p>Un problema similar existe con el punto flotante. La mayoría de los sistemas usan el mismo formato para sus números en coma flotante, pero algunos no. No hay garantías. </p>
<p>Entonces… ¿cómo podemos solucionar todos estos problemas con números y <code>struct</code>s para que nuestros datos se escriban de forma portable?</p>
<p>El resumen es <em>serializar</em> los datos, que es un término general que significa tomar todos los datos y escribirlos en un formato que controlas, que es bien conocido, y programable, para funcionar de la misma manera en todas las plataformas.</p>
<p>Como puede imaginar, se trata de un problema resuelto. Hay un montón de librerías de serialización que puedes aprovechar, como <a href="https://en.wikipedia.org/wiki/Protocol_buffers"><em>búferes de protocolo</em></a><a href="#fn80" class="footnote-ref" id="fnref80" role="doc-noteref"><sup>80</sup></a> de Google, ahí fuera y listas para usar. Se encargarán de todos los detalles por ti, e incluso permitirán que los datos de tus programas en C interoperen con otros lenguajes que soporten los mismos métodos de serialización.</p>
<p>Hágase un favor a sí mismo y a todo el mundo. Serializa tus datos binarios cuando los escribas en un flujo. Esto mantendrá las cosas bien y portátiles, incluso si transfiere archivos de datos de una arquitectura a otra. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="10" id="typedef-creación-de-nuevos-tipos"><span class="header-section-number">10</span> <code>typedef</code>: Creación de nuevos tipos</h1>
<p> Bueno, no tanto crear <em>nuevos</em> tipos como obtener nuevos nombres para tipos existentes. Suena un poco inútil en la superficie, pero realmente podemos utilizar esto para hacer nuestro código más limpio.</p>
<h2 data-number="10.1" id="typedef-en-teoría"><span class="header-section-number">10.1</span> <code>typedef</code> en Teoría</h2>
<p>Básicamente, se toma un tipo existente y se hace un alias para él con <code>typedef</code>.</p>
<p>Así:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> antelope<span class="op">;</span>  <span class="co">// Hacer de «antelope» un alias de «int»</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>antelope x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>       <span class="co">// El tipo «antelope» es el mismo que el tipo «int»</span></span></code></pre></div>
<p>Puede tomar cualquier tipo existente y hacerlo. Usted puede incluso hacer un número de tipos con una lista de comas:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> antelope<span class="op">,</span> bagel<span class="op">,</span> mushroom<span class="op">;</span>  <span class="co">// Estos son todos «int»</span></span></code></pre></div>
<p>Eso es muy útil, ¿verdad? ¿Que puedas escribir «mushroom» en lugar de «bagel»? Debes de estar muy emocionado con esta función.</p>
<p>De acuerdo, Profesor Sarcasmo… llegaremos a algunas aplicaciones más comunes de esto en un momento.</p>
<h3 data-number="10.1.1" id="alcance"><span class="header-section-number">10.1.1</span> Alcance</h3>
<p> <code>typedef</code> sigue las <a href="#scope">reglas de ámbito</a> habituales.</p>
<p>Por esta razón, es bastante común encontrar <code>typedef</code> en el ámbito del archivo («global») para que todas las funciones puedan utilizar los nuevos tipos a voluntad.</p>
<h2 data-number="10.2" id="typedef-en-la-práctica"><span class="header-section-number">10.2</span> <code>typedef</code> en la práctica</h2>
<p>Así que renombrar <code>int</code> a otra cosa no es tan emocionante. Veamos dónde suele aparecer <code>typedef</code>.</p>
<h3 data-number="10.2.1" id="typedef-struct"><span class="header-section-number">10.2.1</span> <code>typedef</code> y <code>struct</code>s</h3>
<p> A veces, una <code>struct</code> «estructura» se <code>typedef</code> «tipifica» con un nuevo nombre para que no tengas que escribir la palabra <code>struct</code> una y otra vez.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> animal <span class="op">{</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> leg_count<span class="op">,</span> speed<span class="op">;</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Nombre Original  Nuevo Nombre</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a><span class="co">//            |         |</span></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a><span class="co">//            v         v</span></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a><span class="co">//      |-----------| |----|</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> animal animal<span class="op">;</span></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> animal y<span class="op">;</span>  <span class="co">// Esto funciona</span></span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a>animal z<span class="op">;</span>         <span class="co">// Esto también funciona porque «animal» es un alias</span></span></code></pre></div>
<p>Personalmente, no me gusta esta práctica. Me gusta la claridad que tiene el código cuando añades la palabra <code>struct</code> al tipo; los programadores saben lo que obtienen. Pero es muy común, así que lo incluyo aquí.</p>
<p>Ahora quiero ejecutar exactamente el mismo ejemplo de una manera que se puede ver comúnmente. Vamos a poner el <code>struct animal</code> <em>en</em> el <code>typedef</code>. Puedes mezclarlo todo así:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="co">//      Nombre Original</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="co">//            |</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a><span class="co">//            v</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="co">//      |-----------|</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> animal <span class="op">{</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> leg_count<span class="op">,</span> speed<span class="op">;</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> animal<span class="op">;</span>                         <span class="co">// &lt;-- Nuevo nombre</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> animal y<span class="op">;</span>  <span class="co">// Esto funciona</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>animal z<span class="op">;</span>         <span class="co">// Esto también funciona porque «animal» es un alias</span></span></code></pre></div>
<p>Es exactamente igual que el ejemplo anterior, pero más conciso.</p>
<p> Pero eso no es todo. Hay otro atajo común, que puedes ver en el código, usando lo que se llaman <em>estructuras anónimas</em><a href="#fn81" class="footnote-ref" id="fnref81" role="doc-noteref"><sup>81</sup></a>. Resulta que en realidad, no necesitas nombrar la estructura en una variedad de lugares, y con <code>typedef</code> es uno de ellos.</p>
<p>Hagamos el mismo ejemplo con una estructura anónima:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="co">//  ¡Estructura anónima! ¡No tiene nombre!</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a><span class="co">//         |</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a><span class="co">//         v</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="co">//      |----|</span></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> leg_count<span class="op">,</span> speed<span class="op">;</span></span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> animal<span class="op">;</span>                         <span class="co">// &lt;-- Nuevo nombre</span></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a><span class="co">//struct animal y;  // ERROR: esto ya no funciona--¡no existe tal estructura!</span></span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a>animal z<span class="op">;</span>           <span class="co">// Esto funciona porque «animal» es un alias</span></span></code></pre></div>
<p>Como otro ejemplo, podríamos encontrar algo como esto:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> point<span class="op">;</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>point p <span class="op">=</span> <span class="op">{.</span>x<span class="op">=</span><span class="dv">20</span><span class="op">,</span> <span class="op">.</span>y<span class="op">=</span><span class="dv">40</span><span class="op">};</span></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">.</span>x<span class="op">,</span> p<span class="op">.</span>y<span class="op">);</span>  <span class="co">// 20, 40</span></span></code></pre></div>
<p> </p>
<h3 data-number="10.2.2" id="typedef-y-otros-tipos"><span class="header-section-number">10.2.2</span> <code>typedef</code> y otros tipos</h3>
<p>No es que usar <code>typedef</code> con un tipo simple como <code>int</code> sea completamente inútil… te ayuda a abstraer los tipos para que sea más fácil cambiarlos después.</p>
<p>Por ejemplo, si tienes <code>float</code> por todo tu código en 100 zillones de sitios, va a ser doloroso cambiarlos todos a <code>double</code> si descubres que tienes que hacerlo más tarde por alguna razón.</p>
<p>Pero si te preparas un poco con:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">float</span> app_float<span class="op">;</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a><span class="co">// y</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>app_float f1<span class="op">,</span> f2<span class="op">,</span> f3<span class="op">;</span></span></code></pre></div>
<p>Si más tarde quieres cambiar a otro tipo, como <code>long double</code>, sólo tienes que cambiar el <code>typedef</code>:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="co">//        voila!</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="co">//      |---------|</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">double</span> app_float<span class="op">;</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a><span class="co">// y no es necesario cambiar esta línea:</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>app_float f1<span class="op">,</span> f2<span class="op">,</span> f3<span class="op">;</span>  <span class="co">// Ahora todos estos son long double</span></span></code></pre></div>
<h3 data-number="10.2.3" id="typedef-y-punteros"><span class="header-section-number">10.2.3</span> <code>typedef</code> y punteros</h3>
<p> Puedes hacer un tipo que sea un puntero.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="op">*</span>intptr<span class="op">;</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>intptr x <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">;</span>  <span class="co">// «intptr» es tipo «int*»</span></span></code></pre></div>
<p>Realmente no me gusta esta práctica. Oculta el hecho de que <code>x</code> es un tipo puntero porque no se ve un <code>*</code> en la declaración.</p>
<p>En mi opinión, es mejor mostrar explícitamente que estás declarando un tipo puntero para que otros desarrolladores puedan verlo claramente y no confundan <code>x</code> con un tipo no puntero.</p>
<p>Pero en el último recuento, digamos, 832.007 personas tenían una opinión diferente. </p>
<h3 data-number="10.2.4" id="typedef-y-mayúsculas"><span class="header-section-number">10.2.4</span> <code>typedef</code> y mayúsculas</h3>
<p>He visto todo tipo de mayúsculas en <code>typedef</code>.</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> my_point<span class="op">;</span>          <span class="co">// lower snake case</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> MyPoint<span class="op">;</span>          <span class="co">// CamelCase</span></span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> Mypoint<span class="op">;</span>          <span class="co">// Leading uppercase</span></span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb167-14"><a href="#cb167-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb167-15"><a href="#cb167-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> MY_POINT<span class="op">;</span>          <span class="co">// UPPER SNAKE CASE</span></span></code></pre></div>
<p>La especificación C11 no dicta un modo u otro, y muestra ejemplos en mayúsculas y minúsculas.</p>
<p>K&amp;R2 utiliza predominantemente las mayúsculas, pero muestra algunos ejemplos en mayúsculas y minúsculas (con <code>_t</code>).</p>
<p>Si utiliza una guía de estilo, cíñase a ella. Si no, hazte con una y cíñete a ella.</p>
<h2 data-number="10.3" id="arrays-y-typedef"><span class="header-section-number">10.3</span> Arrays y <code>typedef</code></h2>
<p> La sintaxis es un poco extraña, y en mi experiencia esto se ve raramente, pero usted puede utilizar <code>typedef</code> en una matriz, de algún número de elementos.</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Hacer del tipo five_inst un array de 5 ints</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> five_ints<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>five_ints x <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span></code></pre></div>
<p>No me gusta porque oculta la naturaleza de la variable array, pero se puede hacer. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="11" id="pointers2"><span class="header-section-number">11</span> Punteros II: Aritmética</h1>
<p> ¡Es hora de entrar más en materia con una serie de nuevos temas sobre punteros! Si no estás al día con los punteros, <a href="#pointers">echa un vistazo a la primera sección de la guía sobre el tema</a>.</p>
<h2 data-number="11.1" id="aritmética-de-punteros"><span class="header-section-number">11.1</span> Aritmética de punteros</h2>
<p>Resulta que se pueden hacer operaciones matemáticas con punteros, sobre todo sumas y restas.</p>
<p>Pero, ¿qué significa hacer eso?</p>
<p>En resumen, si tienes un puntero a un tipo, sumando uno al puntero, te mueves al siguiente elemento de ese tipo, el cual se encuentra, directamente después de él, en memoria.</p>
<p>Es <strong>importante</strong> recordar, que cuando movemos punteros y buscamos en diferentes lugares de la memoria, necesitamos asegurarnos de que <strong>siempre</strong> estamos apuntando a un lugar válido de la memoria, antes de hacer la desreferencia. Si nos vamos por las ramas e intentamos ver qué hay ahí, el comportamiento es indefinido y el resultado habitual es un fallo.</p>
<p>Esto es un poco complicado con <a href="#arraypointerequiv">La equivalencia de Array/Puntero</a> pero vamos a intentarlo de todas formas.</p>
<h3 data-number="11.1.1" id="incrementando-punteros"><span class="header-section-number">11.1.1</span> Incrementando punteros</h3>
<p>En primer lugar, tomemos una matriz de números.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span></code></pre></div>
<p>A continuación, vamos a obtener un puntero al primer elemento de esa matriz:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// O &quot;int *p = a;&quot; funciona igual de bien</span></span></code></pre></div>
<p>A continuación, vamos a imprimir el valor allí por desreferenciación del puntero:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// Imprime 11</span></span></code></pre></div>
<p>Ahora vamos a utilizar la aritmética de punteros para imprimir el siguiente elemento de la matriz, el que está en el índice 1:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p <span class="op">+</span> <span class="dv">1</span><span class="op">));</span>  <span class="co">// Imprime 22!!</span></span></code></pre></div>
<p>¿Qué ha pasado ahí? C sabe que <code>p</code> es un puntero a un <code>int</code>. Así que sabe el tamaño de un <code>int</code><a href="#fn82" class="footnote-ref" id="fnref82" role="doc-noteref"><sup>82</sup></a> y sabe que debe saltarse esa cantidad de bytes para llegar al siguiente <code>int</code> después del primero.</p>
<p>De hecho, el ejemplo anterior podría escribirse de estas dos formas equivalentes:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>        <span class="co">// Imprime 11</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p <span class="op">+</span> <span class="dv">0</span><span class="op">));</span>  <span class="co">// Imprime 11</span></span></code></pre></div>
<p>porque añadiendo <code>0</code> a un puntero se obtiene el mismo puntero.</p>
<p>Pensemos en el resultado. Podemos iterar sobre elementos de un array de esta forma en lugar de usar un array:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// O &quot;int *p = a;&quot; funciona igual de bien</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p <span class="op">+</span> i<span class="op">));</span>  <span class="co">// ¡Igual que p[i]!</span></span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>¡Y eso funciona igual que si utilizáramos la notación array! ¡Oooo! Cada vez más cerca de la equivalencia entre array y puntero. Más sobre esto en este capítulo.</p>
<p>Pero, ¿qué está pasando realmente aquí? ¿Cómo funciona?</p>
<p>¿Recuerdas que la memoria es como un gran array, donde un byte se almacena en cada índice del array?</p>
<p>Y el índice del array en la memoria tiene algunos nombres:</p>
<ul>
<li>Índice en memoria</li>
<li>Localización</li>
<li>Dirección</li>
<li><em>Puntero!</em></li>
</ul>
<p>Así que un puntero es un índice en la memoria, en algún lugar.</p>
<p>Por poner un ejemplo al azar, digamos que un número 3490 se almacenó en la dirección («índice») 23,237,489,202. Si tenemos un puntero <code>int</code> a ese 3490, el valor de ese puntero es 23,237,489,202… porque el puntero es la dirección de memoria. Diferentes palabras para la misma cosa.</p>
<p>Y ahora digamos que tenemos otro número, 4096, almacenado justo después del 3490 en la dirección 23,237,489,210 (8 más alto que el 3490 porque cada <code>int</code> en este ejemplo tiene 8 bytes de longitud).</p>
<p>Si añadimos <code>1</code> a ese puntero, en realidad salta <code>sizeof(int)</code> bytes hasta el siguiente <code>int</code>. Sabe que debe saltar tan lejos porque es un puntero <code>int</code>. Si fuera un puntero <code>float</code>, saltaría <code>sizeof(float)</code> bytes adelante para llegar al siguiente float.</p>
<p>Así que puedes ver el siguiente <code>int</code>, añadiendo <code>1</code> al puntero, el siguiente añadiendo <code>2</code> al puntero, y así sucesivamente.</p>
<h3 data-number="11.1.2" id="cambio-de-punteros"><span class="header-section-number">11.1.2</span> Cambio de punteros</h3>
<p>En la sección anterior vimos cómo podíamos añadir un entero a un puntero. Esta vez, vamos a <em>modificar el puntero en sí</em>.</p>
<p>Puede añadir (o restar) valores enteros directamente a (o desde) cualquier puntero.</p>
<p>Repitamos el ejemplo, pero con un par de cambios. En primer lugar, voy a añadir un <code>999</code> al final de nuestros números para utilizar como un valor centinela. Esto nos permitirá saber dónde está el final de los datos.</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">,</span> <span class="dv">999</span><span class="op">};</span>  <span class="co">// Añade 999 aquí como centinela</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// p señala el 11</span></span></code></pre></div>
<p>Y también tenemos <code>p</code> apuntando al elemento en el índice <code>0</code> de <code>a</code>, es decir <code>11</code>, igual que antes.</p>
<p>Ahora empecemos a <em>incrementar</em> <code>p</code> para que apunte a los siguientes elementos del array. Haremos esto hasta que <code>p</code> apunte al <code>999</code>; es decir, lo haremos hasta que <code>*p == 999</code>:</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(*</span>p <span class="op">!=</span> <span class="dv">999</span><span class="op">)</span> <span class="op">{</span>       <span class="co">// Mientras que la cosa a la que p señala no es 999</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>   <span class="co">// Imprimir</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>    p<span class="op">++;</span>                  <span class="co">// Mueve(Incrementa) p para apuntar al siguiente int</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Bastante loco, ¿verdad?</p>
<p>Cuando le damos una vuelta, primero <code>p</code> apunta a <code>11</code>. Luego incrementamos <code>p</code>, y apunta a <code>22</code>, y luego otra vez, apunta a <code>33</code>. Y así sucesivamente, hasta que apunta a <code>999</code> y salimos.</p>
<h3 data-number="11.1.3" id="restar-punteros"><span class="header-section-number">11.1.3</span> Restar punteros</h3>
<p> También puedes restar un valor de un puntero para llegar a una dirección anterior, igual que antes.</p>
<p>Pero también podemos restar dos punteros para encontrar la diferencia entre ellos, por ejemplo, podemos calcular cuántos <code>int</code>s hay entre dos <code>int*</code>s. El problema es que esto sólo funciona dentro de un array<a href="#fn83" class="footnote-ref" id="fnref83" role="doc-noteref"><sup>83</sup></a>. Si los punteros apuntan a cualquier otra cosa, se obtiene un comportamiento indefinido.</p>
<p>¿Recuerdas que las cadenas son <code>char*</code>s en C? Veamos si podemos usar esto para escribir otra variante de <code>strlen()</code> para calcular la longitud de una cadena que utilice la resta de punteros.</p>
<p>La idea es que si tenemos un puntero al principio de la cadena, podemos encontrar un puntero al final de la cadena buscando el carácter <code>NUL</code>.</p>
<p>Y si tenemos un puntero al principio de la cadena, y hemos calculado el puntero al final de la cadena, podemos restar los dos punteros para obtener la longitud de la cadena.</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb177-1"><a href="#cb177-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb177-2"><a href="#cb177-2"></a></span>
<span id="cb177-3"><a href="#cb177-3"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb177-4"><a href="#cb177-4"></a><span class="op">{</span></span>
<span id="cb177-5"><a href="#cb177-5"></a>    <span class="co">// Empezar a escanear desde el principio de la cadena</span></span>
<span id="cb177-6"><a href="#cb177-6"></a>    <span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb177-7"><a href="#cb177-7"></a></span>
<span id="cb177-8"><a href="#cb177-8"></a>    <span class="co">// Escanear hasta encontrar el carácter NUL</span></span>
<span id="cb177-9"><a href="#cb177-9"></a>    <span class="cf">while</span> <span class="op">(*</span>p <span class="op">!=</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">)</span></span>
<span id="cb177-10"><a href="#cb177-10"></a>        p<span class="op">++;</span></span>
<span id="cb177-11"><a href="#cb177-11"></a></span>
<span id="cb177-12"><a href="#cb177-12"></a>    <span class="co">// Devuelve la diferencia de punteros</span></span>
<span id="cb177-13"><a href="#cb177-13"></a>    <span class="cf">return</span> p <span class="op">-</span> s<span class="op">;</span></span>
<span id="cb177-14"><a href="#cb177-14"></a><span class="op">}</span></span>
<span id="cb177-15"><a href="#cb177-15"></a></span>
<span id="cb177-16"><a href="#cb177-16"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb177-17"><a href="#cb177-17"></a><span class="op">{</span></span>
<span id="cb177-18"><a href="#cb177-18"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> my_strlen<span class="op">(</span><span class="st">&quot;Hello, world!&quot;</span><span class="op">));</span>  <span class="co">// Imprime &quot;13&quot;</span></span>
<span id="cb177-19"><a href="#cb177-19"></a><span class="op">}</span></span></code></pre></div>
<p>Recuerda que sólo puedes utilizar la resta de punteros entre dos punteros que apunten a la misma matriz. </p>
<h2 data-number="11.2" id="arraypointerequiv"><span class="header-section-number">11.2</span> Equivalencia entre matrices e identificadores</h2>
<p> ¡Por fin estamos listos para hablar de esto! Hemos visto un montón de ejemplos de lugares donde hemos entremezclado la notación array, pero vamos a dar la <em>fórmula fundamental de equivalencia array/puntero</em>:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">[</span>b<span class="op">]</span> <span class="op">==</span> <span class="op">*(</span>a <span class="op">+</span> b<span class="op">)</span></span></code></pre></div>
<p>¡Estudia eso! Son equivalentes y pueden utilizarse indistintamente.</p>
<p>He simplificado un poco, porque en mi ejemplo anterior <code>a</code> y <code>b</code> pueden ser ambas expresiones, y podríamos querer algunos paréntesis más para forzar el orden de las operaciones en caso de que las expresiones sean complejas.</p>
<p>La especificación es específica, como siempre, declarando (en C11 §6.5.2.1¶2):</p>
<blockquote>
<p><code>E1[E2]</code> es idéntico a <code>(*((E1)+(E2)))</code></p>
</blockquote>
<p>pero eso es un poco más difícil de entender. Sólo asegúrate de incluir paréntesis si las expresiones son complicadas para que todas tus matemáticas ocurran en el orden correcto.</p>
<p>Esto significa que podemos <em>decidir</em> si vamos a usar la notación array o puntero para cualquier array o puntero (asumiendo que apunta a un elemento de un array).</p>
<p>Usemos un array y un puntero con ambas notaciones, array y puntero:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb179-1"><a href="#cb179-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb179-2"><a href="#cb179-2"></a></span>
<span id="cb179-3"><a href="#cb179-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb179-4"><a href="#cb179-4"></a><span class="op">{</span></span>
<span id="cb179-5"><a href="#cb179-5"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb179-6"><a href="#cb179-6"></a></span>
<span id="cb179-7"><a href="#cb179-7"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> a<span class="op">;</span>  <span class="co">// p apunta al primer elemento de a, 11</span></span>
<span id="cb179-8"><a href="#cb179-8"></a></span>
<span id="cb179-9"><a href="#cb179-9"></a>    <span class="co">// Imprime todos los elementos del array de varias maneras:</span></span>
<span id="cb179-10"><a href="#cb179-10"></a></span>
<span id="cb179-11"><a href="#cb179-11"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb179-12"><a href="#cb179-12"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]);</span>      <span class="co">// Notación de matriz con a</span></span>
<span id="cb179-13"><a href="#cb179-13"></a></span>
<span id="cb179-14"><a href="#cb179-14"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb179-15"><a href="#cb179-15"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">[</span>i<span class="op">]);</span>      <span class="co">// Notación de matriz con p</span></span>
<span id="cb179-16"><a href="#cb179-16"></a></span>
<span id="cb179-17"><a href="#cb179-17"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb179-18"><a href="#cb179-18"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>a <span class="op">+</span> i<span class="op">));</span>  <span class="co">// Notación de puntero con a</span></span>
<span id="cb179-19"><a href="#cb179-19"></a></span>
<span id="cb179-20"><a href="#cb179-20"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb179-21"><a href="#cb179-21"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p <span class="op">+</span> i<span class="op">));</span>  <span class="co">// Notación de puntero con p</span></span>
<span id="cb179-22"><a href="#cb179-22"></a></span>
<span id="cb179-23"><a href="#cb179-23"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb179-24"><a href="#cb179-24"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p<span class="op">++));</span>    <span class="co">// Puntero móvil p</span></span>
<span id="cb179-25"><a href="#cb179-25"></a>        <span class="co">//printf(&quot;%d\n&quot;, *(a++));    // Moviendo la variable de array a--¡ERROR!</span></span>
<span id="cb179-26"><a href="#cb179-26"></a><span class="op">}</span></span></code></pre></div>
<p>Así que puedes ver que en general, si tienes una variable array, puedes usar puntero o noción de array para acceder a los elementos. Lo mismo con una variable puntero.</p>
<p>La única gran diferencia es que puedes <em>modificar</em> un puntero para que apunte a una dirección diferente, pero no puedes hacer eso con una variable array. <!--
6.3.2.1p2 --></p>
<h3 data-number="11.2.1" id="equivalencia-entre-arrays-e-identificadores-en-las-llamadas-a-funciones"><span class="header-section-number">11.2.1</span> Equivalencia entre arrays e identificadores en las llamadas a funciones</h3>
<p>Aquí es donde más te encontrarás con este concepto.</p>
<p>Si usted tiene una función que toma un argumento puntero, por ejemplo:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span></span></code></pre></div>
<p>esto significa que puedes pasar un array o un puntero a esta función y que funcione.</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Antelopes&quot;</span><span class="op">;</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>t <span class="op">=</span> <span class="st">&quot;Wombats&quot;</span><span class="op">;</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> my_strlen<span class="op">(</span>s<span class="op">));</span>  <span class="co">// Funciona!</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> my_strlen<span class="op">(</span>t<span class="op">));</span>  <span class="co">// Tambien funciona!</span></span></code></pre></div>
<p>Y también es la razón por la que estas dos firmas de función son equivalentes:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span>    <span class="co">// Funciona!</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> s<span class="op">[])</span>   <span class="co">// Tambien funciona!</span></span></code></pre></div>
<p></p>
<h2 data-number="11.3" id="punteros-void"><span class="header-section-number">11.3</span> Punteros <code>void</code></h2>
<p> Ya has visto que la palabra clave <code>void</code> se usa con funciones, pero esto es un animal completamente separado y no relacionado.</p>
<p>A veces es útil tener un puntero a una cosa <em>de la que no sabes el tipo</em>.</p>
<p>Lo sé. Ten paciencia conmigo un segundo.</p>
<p>Hay básicamente dos casos de uso para esto.</p>
<p> 1. Una función va a operar sobre algo byte a byte. Por ejemplo, <code>memcpy()</code> copia bytes de memoria de un puntero a otro, pero esos punteros pueden apuntar a cualquier tipo. <code>memcpy()</code> se aprovecha del hecho de que si iteras a través de <code>char*</code>s, estás iterando a través de los bytes de un objeto sin importar el tipo del objeto. Más sobre esto en la subsección <a href="#multibyte-values">Valores Multibyte</a>.</p>
<ol start="2" type="1">
<li>Otra función está llamando a una función que tú le pasaste (un callback), y te está pasando datos. Tú conoces el tipo de los datos, pero la función que te llama no. Así que te pasa <code>void*</code>s—porque no conoce el tipo—y tú los conviertes al tipo que necesitas. Las funciones incorporadas <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-qsort"><code>qsort()</code></a><a href="#fn84" class="footnote-ref" id="fnref84" role="doc-noteref"><sup>84</sup></a> y <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-bsearch"><code>bsearch()</code></a><a href="#fn85" class="footnote-ref" id="fnref85" role="doc-noteref"><sup>85</sup></a> utilizan esta técnica.</li>
</ol>
<p>Veamos un ejemplo, la función incorporada <code>memcpy()</code>:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>memcpy<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>s1<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>s2<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span></code></pre></div>
<p>Esta función copia <code>n</code> bytes a partir de la dirección <code>s2</code> en la memoria a partir de la dirección <code>s1</code>.</p>
<p>Pero, ¡mira! ¡<code>s1</code> y <code>s2</code> son <code>void*</code>s! ¿Por qué? ¿Qué significa esto? Veamos más ejemplos.</p>
<p>Por ejemplo, podríamos copiar una cadena con <code>memcpy()</code> (aunque <code>strcpy()</code> es más apropiado para cadenas):</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb184-1"><a href="#cb184-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb184-2"><a href="#cb184-2"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb184-3"><a href="#cb184-3"></a></span>
<span id="cb184-4"><a href="#cb184-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb184-5"><a href="#cb184-5"></a><span class="op">{</span></span>
<span id="cb184-6"><a href="#cb184-6"></a>    <span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Goats!&quot;</span><span class="op">;</span></span>
<span id="cb184-7"><a href="#cb184-7"></a>    <span class="dt">char</span> t<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb184-8"><a href="#cb184-8"></a></span>
<span id="cb184-9"><a href="#cb184-9"></a>    memcpy<span class="op">(</span>t<span class="op">,</span> s<span class="op">,</span> <span class="dv">7</span><span class="op">);</span>  <span class="co">// Copia 7 bytes - ¡incluyendo el terminador NUL!</span></span>
<span id="cb184-10"><a href="#cb184-10"></a></span>
<span id="cb184-11"><a href="#cb184-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> t<span class="op">);</span>  <span class="co">// &quot;Goats!&quot;</span></span>
<span id="cb184-12"><a href="#cb184-12"></a><span class="op">}</span></span></code></pre></div>
<p>O podemos copiar algunos <code>int</code>s:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb185-1"><a href="#cb185-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb185-2"><a href="#cb185-2"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb185-3"><a href="#cb185-3"></a></span>
<span id="cb185-4"><a href="#cb185-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb185-5"><a href="#cb185-5"></a><span class="op">{</span></span>
<span id="cb185-6"><a href="#cb185-6"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">};</span></span>
<span id="cb185-7"><a href="#cb185-7"></a>    <span class="dt">int</span> b<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb185-8"><a href="#cb185-8"></a></span>
<span id="cb185-9"><a href="#cb185-9"></a>    memcpy<span class="op">(</span>b<span class="op">,</span> a<span class="op">,</span> <span class="dv">3</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span>  <span class="co">// Copiar 3 ints de datos</span></span>
<span id="cb185-10"><a href="#cb185-10"></a></span>
<span id="cb185-11"><a href="#cb185-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]);</span>  <span class="co">// 22</span></span>
<span id="cb185-12"><a href="#cb185-12"></a><span class="op">}</span></span></code></pre></div>
<p>Esto es un poco salvaje… ¿has visto lo que hemos hecho con <code>memcpy()</code>? Copiamos los datos de <code>a</code> a <code>b</code>, pero tuvimos que especificar cuántos <em>bytes</em> copiar, y un <code>int</code> es más de un byte.</p>
<p>Bien, entonces… ¿cuántos bytes ocupa un <code>int</code>? Respuesta: depende del sistema. Pero podemos saber cuántos bytes ocupa cualquier tipo con el operador <code>sizeof</code>.</p>
<p>Así que.. ahí está la respuesta: un <code>int</code> ocupa <code>sizeof(int)</code> bytes de memoria para almacenarse.</p>
<p>Y si tenemos 3 de ellos en nuestro array, como en el ejemplo, todo el espacio usado para los 3 <code>int</code>s debe ser <code>3 * sizeof(int)</code>.</p>
<p>(En el ejemplo de la cadena, habría sido técnicamente más exacto copiar <code>7 * sizeof(char)</code> bytes. Pero los <code>char</code>s son siempre de un byte, por definición, así que se convierte en <code>7 * 1</code>).</p>
<p>Incluso podríamos copiar un <code>float</code> o un <code>struct</code> con <code>memcpy()</code>. (Aunque esto es abusivo—deberíamos usar <code>=</code> para eso):</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> antelope my_antelope<span class="op">;</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> antelope my_clone_antelope<span class="op">;</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>memcpy<span class="op">(&amp;</span>my_clone_antelope<span class="op">,</span> <span class="op">&amp;</span>my_antelope<span class="op">,</span> <span class="kw">sizeof</span> my_antelope<span class="op">);</span></span></code></pre></div>
<p>¡Mira qué versátil es <code>memcpy()</code>! Si tienes un puntero a un origen y un puntero a un destino, y tienes el número de bytes que quieres copiar, puedes copiar <em>cualquier tipo de datos</em>.</p>
<p>Imagina que no tuviéramos <code>void*</code>. Tendríamos que escribir funciones <code>memcpy()</code> especializadas para cada tipo: </p>
<div class="sourceCode" id="cb187"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>memcpy_int<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>memcpy_float<span class="op">(</span><span class="dt">float</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">float</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>memcpy_double<span class="op">(</span><span class="dt">double</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">double</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>memcpy_char<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>memcpy_unsigned_char<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a><span class="co">// etc... blech!</span></span></code></pre></div>
<p>Es mucho mejor usar <code>void*</code> y tener una función que lo haga todo.</p>
<p>Ese es el poder de <code>void*</code>. Puedes escribir funciones que no se preocupan por el tipo y aún así son capaces de hacer cosas con él.</p>
<p>Pero un gran poder conlleva una gran responsabilidad. Tal vez no tan grande en este caso, pero hay algunos límites.</p>
<p> 1. No se puede hacer aritmética de punteros en un <code>void*</code>.</p>
<ol start="2" type="1">
<li><p>No se puede desreferenciar un <code>void*</code>.</p></li>
<li><p>No puedes usar el operador flecha en un <code>void*</code>, ya que también es una dereferencia.</p></li>
<li><p>No puedes usar la notación array en un <code>void*</code>, ya que también es una dereferencia <a href="#fn86" class="footnote-ref" id="fnref86" role="doc-noteref"><sup>86</sup></a>.</p></li>
</ol>
<p>Y si lo piensas, estas reglas tienen sentido. Todas esas operaciones se basan en conocer el tamaño del tipo de dato apuntado, y con <code>void*</code> no sabemos el tamaño del dato apuntado, ¡puede ser cualquier cosa! </p>
<p>Pero espera… si no puedes desreferenciar un <code>void*</code> ¿de qué te puede servir?</p>
<p>Como con <code>memcpy()</code>, te ayuda a escribir funciones genéricas que pueden manejar múltiples tipos de datos. ¡Pero el secreto es que, en el fondo, <em>conviertes el <code>void*</code> a otro tipo antes de usarlo</em>!</p>
<p>Y la conversión es fácil: sólo tienes que asignar a una variable del tipo deseado <a href="#fn87" class="footnote-ref" id="fnref87" role="doc-noteref"><sup>87</sup></a>.</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> a <span class="op">=</span> <span class="ch">&#39;X&#39;</span><span class="op">;</span>  <span class="co">// Un solo carácter</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">;</span>  <span class="co">// p señala a &quot;X&quot;</span></span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>q <span class="op">=</span> p<span class="op">;</span>   <span class="co">// q también señala a &quot;X&quot;</span></span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// ERROR--¡no se puede hacer referencia a void*!</span></span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>q<span class="op">);</span>  <span class="co">// Imprime &quot;X&quot;</span></span></code></pre></div>
<p> Escribamos nuestro propio <code>memcpy()</code> para probarlo. Podemos copiar bytes (<code>char</code>s), y sabemos el número de bytes porque se pasa.</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>my_memcpy<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>src<span class="op">,</span> <span class="dt">int</span> byte_count<span class="op">)</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convertir void*s en char*s</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> src<span class="op">,</span> <span class="op">*</span>d <span class="op">=</span> dest<span class="op">;</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ahora que tenemos char*s, podemos desreferenciarlos y copiarlos</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>byte_count<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>d<span class="op">++</span> <span class="op">=</span> <span class="op">*</span>s<span class="op">++;</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// La mayoría de estas funciones devuelven el destino, por si acaso</span></span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// que sea útil para el que llama.</span></span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dest<span class="op">;</span></span>
<span id="cb189-14"><a href="#cb189-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Justo al principio, copiamos los <code>void*</code>s en <code>char*</code>s para poder usarlos como <code>char*</code>s. Así de fácil.</p>
<p>Luego un poco de diversión en un bucle while, donde decrementamos <code>byte_count</code> hasta que se convierte en false (<code>0</code>). Recuerda que con el post-decremento, se calcula el valor de la expresión (para que <code>while</code> lo use) y <em>entonces</em> se decrementa la variable.</p>
<p>Y algo de diversión en la copia, donde asignamos <code>*d = *s</code> para copiar el byte, pero lo hacemos con post-incremento para que tanto <code>d</code> como <code>s</code> se muevan al siguiente byte después de hacer la asignación.</p>
<p>Por último, la mayoría de las funciones de memoria y cadena devuelven una copia de un puntero a la cadena de destino por si el que llama quiere utilizarla.</p>
<p>Ahora que hemos hecho esto, sólo quiero señalar rápidamente que podemos utilizar esta técnica para iterar sobre los bytes de <em>cualquier</em> objeto en C, <code>float</code>s, <code>struct</code>s, ¡o cualquier cosa! </p>
<p> <span id="qsort-example">Vamos</span> a ejecutar un ejemplo más del mundo real con la rutina incorporada <code>qsort()</code> que puede ordenar <em>cualquier cosa</em> gracias a la magia de los <code>void*</code>s.</p>
<p>(En el siguiente ejemplo, puede ignorar la palabra <code>const</code>, que aún no hemos tratado).</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb190-1"><a href="#cb190-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb190-2"><a href="#cb190-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb190-3"><a href="#cb190-3"></a></span>
<span id="cb190-4"><a href="#cb190-4"></a><span class="co">// El tipo de estructura que vamos a ordenar</span></span>
<span id="cb190-5"><a href="#cb190-5"></a><span class="kw">struct</span> animal <span class="op">{</span></span>
<span id="cb190-6"><a href="#cb190-6"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb190-7"><a href="#cb190-7"></a>    <span class="dt">int</span> leg_count<span class="op">;</span></span>
<span id="cb190-8"><a href="#cb190-8"></a><span class="op">};</span></span>
<span id="cb190-9"><a href="#cb190-9"></a></span>
<span id="cb190-10"><a href="#cb190-10"></a><span class="co">// Esta es una función de comparación llamada por qsort() para ayudarle a determinar</span></span>
<span id="cb190-11"><a href="#cb190-11"></a><span class="co">// qué ordenar exactamente. La usaremos para ordenar un array de struct</span></span>
<span id="cb190-12"><a href="#cb190-12"></a><span class="co">// animales por leg_count.</span></span>
<span id="cb190-13"><a href="#cb190-13"></a><span class="dt">int</span> compar<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>elem1<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>elem2<span class="op">)</span></span>
<span id="cb190-14"><a href="#cb190-14"></a><span class="op">{</span></span>
<span id="cb190-15"><a href="#cb190-15"></a>    <span class="co">// Sabemos que estamos ordenando struct animals, así que hagamos ambos</span></span>
<span id="cb190-16"><a href="#cb190-16"></a>    <span class="co">// argumentos punteros a struct animals</span></span>
<span id="cb190-17"><a href="#cb190-17"></a>    <span class="dt">const</span> <span class="kw">struct</span> animal <span class="op">*</span>animal1 <span class="op">=</span> elem1<span class="op">;</span></span>
<span id="cb190-18"><a href="#cb190-18"></a>    <span class="dt">const</span> <span class="kw">struct</span> animal <span class="op">*</span>animal2 <span class="op">=</span> elem2<span class="op">;</span></span>
<span id="cb190-19"><a href="#cb190-19"></a></span>
<span id="cb190-20"><a href="#cb190-20"></a>    <span class="co">// Devolver &lt;0 =0 o &gt;0 dependiendo de lo que queramos ordenar.</span></span>
<span id="cb190-21"><a href="#cb190-21"></a></span>
<span id="cb190-22"><a href="#cb190-22"></a>    <span class="co">// Vamos a ordenar ascendentemente por leg_count, por lo que</span></span>
<span id="cb190-23"><a href="#cb190-23"></a>    <span class="co">//devolveremos la diferencia en los leg_counts</span></span>
<span id="cb190-24"><a href="#cb190-24"></a>    <span class="cf">if</span> <span class="op">(</span>animal1<span class="op">-&gt;</span>leg_count <span class="op">&gt;</span> animal2<span class="op">-&gt;</span>leg_count<span class="op">)</span></span>
<span id="cb190-25"><a href="#cb190-25"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb190-26"><a href="#cb190-26"></a>    </span>
<span id="cb190-27"><a href="#cb190-27"></a>    <span class="cf">if</span> <span class="op">(</span>animal1<span class="op">-&gt;</span>leg_count <span class="op">&lt;</span> animal2<span class="op">-&gt;</span>leg_count<span class="op">)</span></span>
<span id="cb190-28"><a href="#cb190-28"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb190-29"><a href="#cb190-29"></a></span>
<span id="cb190-30"><a href="#cb190-30"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-31"><a href="#cb190-31"></a><span class="op">}</span></span>
<span id="cb190-32"><a href="#cb190-32"></a></span>
<span id="cb190-33"><a href="#cb190-33"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb190-34"><a href="#cb190-34"></a><span class="op">{</span></span>
<span id="cb190-35"><a href="#cb190-35"></a>    <span class="co">// Construyamos un array de 4 struct animals con diferentes</span></span>
<span id="cb190-36"><a href="#cb190-36"></a>    <span class="co">// características. Este array está desordenado por leg_count, pero</span></span>
<span id="cb190-37"><a href="#cb190-37"></a>    <span class="co">// lo ordenaremos en un segundo.</span></span>
<span id="cb190-38"><a href="#cb190-38"></a>    <span class="kw">struct</span> animal a<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb190-39"><a href="#cb190-39"></a>        <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Dog&quot;</span><span class="op">,</span> <span class="op">.</span>leg_count<span class="op">=</span><span class="dv">4</span><span class="op">},</span></span>
<span id="cb190-40"><a href="#cb190-40"></a>        <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Monkey&quot;</span><span class="op">,</span> <span class="op">.</span>leg_count<span class="op">=</span><span class="dv">2</span><span class="op">},</span></span>
<span id="cb190-41"><a href="#cb190-41"></a>        <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Antelope&quot;</span><span class="op">,</span> <span class="op">.</span>leg_count<span class="op">=</span><span class="dv">4</span><span class="op">},</span></span>
<span id="cb190-42"><a href="#cb190-42"></a>        <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Snake&quot;</span><span class="op">,</span> <span class="op">.</span>leg_count<span class="op">=</span><span class="dv">0</span><span class="op">}</span></span>
<span id="cb190-43"><a href="#cb190-43"></a>    <span class="op">};</span></span>
<span id="cb190-44"><a href="#cb190-44"></a></span>
<span id="cb190-45"><a href="#cb190-45"></a>    <span class="co">// Llama a qsort() para ordenar el array. qsort() necesita saber exactamente</span></span>
<span id="cb190-46"><a href="#cb190-46"></a>    <span class="co">// qué ordenar estos datos, y lo haremos dentro de la función compar()</span></span>
<span id="cb190-47"><a href="#cb190-47"></a>    <span class="co">//</span></span>
<span id="cb190-48"><a href="#cb190-48"></a>    <span class="co">// Esta llamada dice: qsort array a, que tiene 4 elementos, y</span></span>
<span id="cb190-49"><a href="#cb190-49"></a>    <span class="co">// cada elemento es sizeof(struct animal) bytes grande, y esta es la función</span></span>
<span id="cb190-50"><a href="#cb190-50"></a>    <span class="co">// que comparará dos elementos cualesquiera.</span></span>
<span id="cb190-51"><a href="#cb190-51"></a>    qsort<span class="op">(</span>a<span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> animal<span class="op">),</span> compar<span class="op">);</span></span>
<span id="cb190-52"><a href="#cb190-52"></a></span>
<span id="cb190-53"><a href="#cb190-53"></a>    <span class="co">// Imprímelos todos</span></span>
<span id="cb190-54"><a href="#cb190-54"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb190-55"><a href="#cb190-55"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">].</span>leg_count<span class="op">,</span> a<span class="op">[</span>i<span class="op">].</span>name<span class="op">);</span></span>
<span id="cb190-56"><a href="#cb190-56"></a>    <span class="op">}</span></span>
<span id="cb190-57"><a href="#cb190-57"></a><span class="op">}</span></span></code></pre></div>
<p>Mientras le des a <code>qsort()</code> una función que pueda comparar dos elementos que tengas en tu array a ordenar, puede ordenar cualquier cosa. Y lo hace sin necesidad de tener los tipos de los elementos codificados en cualquier lugar. <code>qsort()</code> simplemente reordena bloques de bytes basándose en los resultados de la función <code>compar()</code> que le pasaste. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="12" id="asignación-manual-de-memoria"><span class="header-section-number">12</span> Asignación manual de memoria</h1>
<p> Esta es una de las grandes áreas en las que C probablemente diverge de los lenguajes que ya conoces: <em>gestión manual de memoria</em>.</p>
<p>Otros lenguajes usan el conteo de referencias, la recolección de basura u otros medios para determinar cuándo asignar nueva memoria para algunos datos–y desasignarla cuando ninguna variable hace referencia a ella.</p>
<p>Y eso está bien. Está bien poder despreocuparse de ello, simplemente, eliminar todas las referencias a un elemento y confiar en que en algún momento se liberará la memoria asociada a él.</p>
<p>Pero C no es así, del todo.</p>
<p> Por supuesto, en C, algunas variables se asignan y se liberan automáticamente, cuando entran y salen del ámbito. Llamamos a estas variables automáticas. Son las típicas variables «locales» de ámbito de bloque. No hay problema. </p>
<p>Pero, ¿y si quieres que algo persista más tiempo que un bloque concreto? Aquí es donde entra en juego la gestión manual de la memoria.</p>
<p>Puedes decirle explícitamente a C que te asigne un número determinado de bytes que podrás utilizar a tu antojo. Y estos bytes permanecerán asignados hasta que liberes <em>explícitamente</em> esa memoria<a href="#fn88" class="footnote-ref" id="fnref88" role="doc-noteref"><sup>88</sup></a>.</p>
<p>Es importante que liberes la memoria que hayas utilizado. Si no lo haces, lo llamamos una <em>fuga de memoria</em> y tu proceso continuará reservando esa memoria hasta que termine.</p>
<p>Si la asignaste manualmente, tienes que liberarla manualmente cuando termines de usarla.</p>
<p>¿Cómo lo hacemos? Vamos a aprender un par de nuevas funciones, y hacer uso del operador <code>sizeof</code> para ayudarnos a saber cuántos bytes asignar.</p>
<p> En el lenguaje común de C, los desarrolladores dicen que las variables locales automáticas se asignan «en la pila» y que la memoria asignada manualmente está «en el montón (heap)». La especificación no habla de ninguna de estas cosas, pero todos los desarrolladores de C, sabrán de qué estás hablando si las mencionas. </p>
<p>Todas las funciones que vamos a aprender en este capítulo se encuentran en <code>&lt;stdlib.h&gt;</code>.</p>
<h2 data-number="12.1" id="asignación-y-desasignación-malloc-y-free."><span class="header-section-number">12.1</span> Asignación y desasignación, <code>malloc()</code> y <code>free()</code>.</h2>
<p> La función <code>malloc()</code> acepta un número de bytes para asignar, y devuelve un puntero void a ese bloque de memoria recién asignado.</p>
<p>Como es un <code>void*</code>, puedes asignarlo al tipo de puntero que quieras… normalmente se corresponderá de alguna manera con el número de bytes que estás asignando.</p>
<p> Entonces… ¿cuántos bytes debo asignar? Podemos usar <code>sizeof</code> para ayudarnos con eso. Si queremos asignar espacio suficiente para un único <code>int</code>, podemos usar <code>sizeof(int)</code> y pasárselo a <code>malloc()</code>. </p>
<p> Después de que hayamos terminado con alguna memoria asignada, podemos llamar a <code>free()</code> para indicar que hemos terminado con esa memoria y que puede ser utilizada para otra cosa. Como argumento, pasas el mismo puntero que obtuviste de <code>malloc()</code> (o una copia del mismo). Es un comportamiento indefinido usar una región de memoria después de haberla liberado (<code>free()</code>).</p>
<p>Intentémoslo. Asignaremos suficiente memoria para un <code>int</code>, luego almacenaremos algo allí, y lo imprimiremos.</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Asignar espacio para un único int (sizeof(int) bytes-worth):</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">12</span><span class="op">;</span>  <span class="co">// Almacenar algo allí</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// Imprímelo: 12</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>free<span class="op">(</span>p<span class="op">);</span>  <span class="co">// Todo hecho con esa memoria</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a><span class="co">//*p = 3490;  // ERROR: ¡comportamiento indefinido! ¡Usar después de free()!</span></span></code></pre></div>
<p></p>
<p>En ese ejemplo artificioso, realmente no hay ningún beneficio. Nosotros podríamos haber usado un <code>int</code> automático y habría funcionado. Pero veremos cómo la capacidad de asignar memoria de esta manera tiene sus ventajas, especialmente con estructuras de datos más complejas.</p>
<p> Otra cosa que verás comúnmente aprovecha el hecho de que <code>sizeof</code> puede darte el tamaño del tipo de resultado de cualquier expresión constante. Así que podrías poner un nombre de variable ahí también, y usar eso. Aquí hay un ejemplo de eso, igual que el anterior:</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// *p es un int, igual que sizeof(int)</span></span></code></pre></div>
<p> </p>
<h2 data-number="12.2" id="comprobación-de-errores"><span class="header-section-number">12.2</span> Comprobación de errores</h2>
<p> Todas las funciones de asignación devuelven un puntero al nuevo tramo de memoria asignado, o <code>NULL</code> si la memoria no puede ser asignada por alguna razón.</p>
<p>Algunos sistemas operativos como Linux pueden configurarse de forma que <code>malloc()</code> nunca devuelva <code>NULL</code>, incluso si se ha quedado sin memoria. Pero a pesar de esto, siempre debes codificarlo con protecciones en mente.</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>x<span class="op">;</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Error al asignar 10 ints</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Haga algo aquí para manejarlo</span></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Este es un patrón común que verás, donde hacemos la asignación y la condición en la misma línea:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>x<span class="op">;</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">((</span>x <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> <span class="dv">10</span><span class="op">))</span> <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Error al asignar 10 ints</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// haga algo aquí para manejarlo</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h2 data-number="12.3" id="asignación-de-espacio-para-una-matriz"><span class="header-section-number">12.3</span> Asignación de espacio para una matriz</h2>
<p> Ya hemos visto cómo asignar espacio a una sola cosa; ¿qué pasa ahora con un montón de ellas en una matriz?</p>
<p>En C, un array es un montón de la misma cosa, en un tramo contiguo de memoria(espalda con espalda).</p>
<p>Podemos asignar un tramo contiguo de memoria, ya hemos visto cómo hacerlo. Si quisiéramos 3490 bytes de memoria, podríamos simplemente pedirlos:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> malloc<span class="op">(</span><span class="dv">3490</span><span class="op">);</span>  <span class="co">// Voila</span></span></code></pre></div>
<p>Y, de hecho, es una matriz de 3490 <code>char</code>s (también conocida como cadena), ya que cada <code>char</code> es 1 byte. En otras palabras, <code>sizeof(char)</code> es <code>1</code>.</p>
<p>Nota: no se ha hecho ninguna inicialización en la memoria recién asignada—está llena de basura. Límpiela con <code>memset()</code> si quiere, o vea <code>calloc()</code>, más abajo.</p>
<p>Pero podemos simplemente multiplicar el tamaño de la cosa que queremos por el número de elementos que queremos, y luego acceder a ellos usando la notación de puntero o de array.</p>
<p>Ejemplo</p>
<p></p>
<div class="sourceCode" id="cb196"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb196-1"><a href="#cb196-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb196-2"><a href="#cb196-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb196-3"><a href="#cb196-3"></a></span>
<span id="cb196-4"><a href="#cb196-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb196-5"><a href="#cb196-5"></a><span class="op">{</span></span>
<span id="cb196-6"><a href="#cb196-6"></a>    <span class="co">// Asignar espacio para 10 ints</span></span>
<span id="cb196-7"><a href="#cb196-7"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb196-8"><a href="#cb196-8"></a></span>
<span id="cb196-9"><a href="#cb196-9"></a>    <span class="co">// Asígneles los valores 0-45:</span></span>
<span id="cb196-10"><a href="#cb196-10"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb196-11"><a href="#cb196-11"></a>        p<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb196-12"><a href="#cb196-12"></a></span>
<span id="cb196-13"><a href="#cb196-13"></a>    <span class="co">// Imprimir todos los valores 0, 5, 10, 15, ..., 40, 45</span></span>
<span id="cb196-14"><a href="#cb196-14"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb196-15"><a href="#cb196-15"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb196-16"><a href="#cb196-16"></a></span>
<span id="cb196-17"><a href="#cb196-17"></a>    <span class="co">// Liberar el espacio</span></span>
<span id="cb196-18"><a href="#cb196-18"></a>    free<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb196-19"><a href="#cb196-19"></a><span class="op">}</span></span></code></pre></div>
<p>La clave está en la línea <code>malloc()</code>. Si sabemos que cada <code>int</code> necesita <code>sizeof(int)</code> bytes para contenerlo, y sabemos que queremos 10 de ellos, podemos simplemente asignar exactamente esa cantidad de bytes con:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> <span class="dv">10</span></span></code></pre></div>
<p>Y este truco funciona para todos los tipos. Basta con pasarlo a <code>sizeof</code> y multiplicarlo por el tamaño del array. </p>
<h2 data-number="12.4" id="una-alternativa-calloc."><span class="header-section-number">12.4</span> Una alternativa: <code>calloc()</code>.</h2>
<p> Esta es otra función de asignación que funciona de forma similar a <code>malloc()</code>, con dos diferencias clave:</p>
<ul>
<li>En lugar de un único argumento, pasas el tamaño de un elemento, y el número de elementos que deseas asignar. Es como si estuviera hecho para asignar arrays.</li>
<li>Borra la memoria a cero.</li>
</ul>
<p>Todavía se usa <code>free()</code> para liberar la memoria obtenida mediante <code>calloc()</code>.</p>
<p>Aquí tienes una comparación entre <code>calloc()</code> y <code>malloc()</code>.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Asigna espacio para 10 ints con calloc(), inicializado a 0:</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> calloc<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Asigna espacio para 10 ints con malloc(), inicializado a 0:</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>q <span class="op">=</span> malloc<span class="op">(</span><span class="dv">10</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>memset<span class="op">(</span>q<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">10</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span>   <span class="co">// Pone en 0</span></span></code></pre></div>
<p>De nuevo, el resultado es el mismo para ambos excepto que <code>malloc()</code> no pone a cero la memoria por defecto. </p>
<h2 data-number="12.5" id="cambio-del-tamaño-asignado-con-realloc."><span class="header-section-number">12.5</span> Cambio del tamaño asignado con <code>realloc()</code>.</h2>
<p> Si ya has asignado 10 <code>int</code>s, pero más tarde decides que necesitas 20, ¿qué puedes hacer?</p>
<p>Una opción es asignar nuevo espacio y luego <code>memcpy()</code> en la memoria… pero resulta que a veces no necesitas mover nada. Y hay una función que es lo suficientemente inteligente como para hacer lo correcto en todas las circunstancias: <code>realloc()</code>.</p>
<p>Toma un puntero a memoria previamente ocupada (por <code>malloc()</code> o <code>calloc()</code>) y un nuevo tamaño para la región de memoria.</p>
<p>Entonces crece o decrece esa memoria, y devuelve un puntero a ella. A veces puede devolver el mismo puntero (si los datos no han tenido que ser copiados en otro lugar), o puede devolver uno diferente (si los datos han tenido que ser copiados).</p>
<p>Asegúrese de que cuando llama a <code>realloc()</code>, especifica el número de <em>bytes</em> a asignar, ¡y no sólo el número de elementos del array! Esto es:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>num_floats <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>np <span class="op">=</span> realloc<span class="op">(</span>p<span class="op">,</span> num_floats<span class="op">);</span>  <span class="co">// INCORRECTO: ¡se necesitan bytes, no número de elementos!</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a>np <span class="op">=</span> realloc<span class="op">(</span>p<span class="op">,</span> num_floats <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">float</span><span class="op">));</span>  <span class="co">// ¡Mejor!</span></span></code></pre></div>
<p>Vamos a asignar un array de 20 <code>float</code>s, y luego cambiamos de idea y lo convertimos en un array de 40.</p>
<p>Vamos a asignar el valor de retorno de <code>realloc()</code> a otro puntero para asegurarnos de que no es <code>NULL</code>. Si no lo es, podemos reasignarlo a nuestro puntero original. (Si simplemente asignáramos el valor de retorno directamente al puntero original, perderíamos ese puntero si la función devolviera <code>NULL</code> y no tendríamos forma de recuperarlo).</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb200-1"><a href="#cb200-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb200-2"><a href="#cb200-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb200-3"><a href="#cb200-3"></a></span>
<span id="cb200-4"><a href="#cb200-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb200-5"><a href="#cb200-5"></a><span class="op">{</span></span>
<span id="cb200-6"><a href="#cb200-6"></a>    <span class="co">// Asignar espacio para 20 floats</span></span>
<span id="cb200-7"><a href="#cb200-7"></a>    <span class="dt">float</span> <span class="op">*</span>p <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>p <span class="op">*</span> <span class="dv">20</span><span class="op">);</span>  <span class="co">// sizeof *p igual que sizeof(float)</span></span>
<span id="cb200-8"><a href="#cb200-8"></a></span>
<span id="cb200-9"><a href="#cb200-9"></a>    <span class="co">// Asígneles valores fraccionarios 0-1:</span></span>
<span id="cb200-10"><a href="#cb200-10"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb200-11"><a href="#cb200-11"></a>        p<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i <span class="op">/</span> <span class="fl">20.0</span><span class="op">;</span></span>
<span id="cb200-12"><a href="#cb200-12"></a></span>
<span id="cb200-13"><a href="#cb200-13"></a>    <span class="co">// Pero, ¡espera! Hagamos de esto un array de 40 elementos</span></span>
<span id="cb200-14"><a href="#cb200-14"></a>    <span class="dt">float</span> <span class="op">*</span>new_p <span class="op">=</span> realloc<span class="op">(</span>p<span class="op">,</span> <span class="kw">sizeof</span> <span class="op">*</span>p <span class="op">*</span> <span class="dv">40</span><span class="op">);</span></span>
<span id="cb200-15"><a href="#cb200-15"></a></span>
<span id="cb200-16"><a href="#cb200-16"></a>    <span class="co">// Comprueba si hemos reasignado correctamente</span></span>
<span id="cb200-17"><a href="#cb200-17"></a>    <span class="cf">if</span> <span class="op">(</span>new_p <span class="op">==</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb200-18"><a href="#cb200-18"></a>        printf<span class="op">(</span><span class="st">&quot;Error reallocing</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb200-19"><a href="#cb200-19"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb200-20"><a href="#cb200-20"></a>    <span class="op">}</span></span>
<span id="cb200-21"><a href="#cb200-21"></a></span>
<span id="cb200-22"><a href="#cb200-22"></a>    <span class="co">// Si lo hiciéramos, podemos simplemente reasignar p</span></span>
<span id="cb200-23"><a href="#cb200-23"></a>    p <span class="op">=</span> new_p<span class="op">;</span></span>
<span id="cb200-24"><a href="#cb200-24"></a></span>
<span id="cb200-25"><a href="#cb200-25"></a>    <span class="co">// Y asigna a los nuevos elementos valores en el rango 1.0-2.0</span></span>
<span id="cb200-26"><a href="#cb200-26"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">20</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb200-27"><a href="#cb200-27"></a>        p<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> <span class="op">(</span>i <span class="op">-</span> <span class="dv">20</span><span class="op">)</span> <span class="op">/</span> <span class="fl">20.0</span><span class="op">;</span></span>
<span id="cb200-28"><a href="#cb200-28"></a></span>
<span id="cb200-29"><a href="#cb200-29"></a>    <span class="co">// Imprime todos los valores 0-2 en los 40 elementos:</span></span>
<span id="cb200-30"><a href="#cb200-30"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb200-31"><a href="#cb200-31"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb200-32"><a href="#cb200-32"></a></span>
<span id="cb200-33"><a href="#cb200-33"></a>    <span class="co">// Liberar el espacio</span></span>
<span id="cb200-34"><a href="#cb200-34"></a>    free<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb200-35"><a href="#cb200-35"></a><span class="op">}</span></span></code></pre></div>
<p>Fíjate en cómo tomamos el valor de retorno de <code>realloc()</code> y lo reasignamos a la misma variable puntero <code>p</code> que pasamos. Esto es bastante común.</p>
<p>Además, si la línea 7 te parece rara, con ese <code>sizeof *p</code> ahí, recuerda que <code>sizeof</code> funciona con el tamaño del tipo de la expresión. Y el tipo de <code>*p</code> es <code>float</code>, así que esa línea es equivalente a <code>sizeof(float)</code>. </p>
<h3 data-number="12.5.1" id="lectura-de-líneas-de-longitud-arbitraria"><span class="header-section-number">12.5.1</span> Lectura de líneas de longitud arbitraria</h3>
<p>Quiero demostrar dos cosas con este ejemplo completo.</p>
<ol type="1">
<li>El uso de <code>realloc()</code> para hacer crecer un buffer a medida que leemos más datos.</li>
<li>El Uso de <code>realloc()</code> para reducir el buffer al tamaño perfecto después de completar la lectura.</li>
</ol>
<p>Lo que vemos aquí es un bucle que llama a <code>fgetc()</code> una y otra vez para añadir a un buffer, hasta que vemos que el último carácter es una nueva línea.</p>
<p>Una vez que encuentra la nueva línea, encoge el buffer al tamaño adecuado y lo devuelve.</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb201-1"><a href="#cb201-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb201-2"><a href="#cb201-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb201-3"><a href="#cb201-3"></a></span>
<span id="cb201-4"><a href="#cb201-4"></a><span class="co">// Leer una línea de tamaño arbitrario de un fichero</span></span>
<span id="cb201-5"><a href="#cb201-5"></a><span class="co">//</span></span>
<span id="cb201-6"><a href="#cb201-6"></a><span class="co">// Devuelve un puntero a la línea.</span></span>
<span id="cb201-7"><a href="#cb201-7"></a><span class="co">// Devuelve NULL en EOF o error.</span></span>
<span id="cb201-8"><a href="#cb201-8"></a><span class="co">//</span></span>
<span id="cb201-9"><a href="#cb201-9"></a><span class="co">// Es responsabilidad del que llama liberar() este puntero cuando termine de usarlo.</span></span>
<span id="cb201-10"><a href="#cb201-10"></a><span class="co">//</span></span>
<span id="cb201-11"><a href="#cb201-11"></a><span class="co">// Tenga en cuenta que esto elimina la nueva línea del resultado. Si necesita</span></span>
<span id="cb201-12"><a href="#cb201-12"></a><span class="co">// de él, probablemente sea mejor cambiar esto, a un do-while.</span></span>
<span id="cb201-13"><a href="#cb201-13"></a></span>
<span id="cb201-14"><a href="#cb201-14"></a><span class="dt">char</span> <span class="op">*</span>readline<span class="op">(</span><span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">)</span></span>
<span id="cb201-15"><a href="#cb201-15"></a><span class="op">{</span></span>
<span id="cb201-16"><a href="#cb201-16"></a>    <span class="dt">int</span> offset <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Indice del siguiente char en el buffer</span></span>
<span id="cb201-17"><a href="#cb201-17"></a>    <span class="dt">int</span> bufsize <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// Preferiblemente con un tamaño inicial que sea potencia de 2 </span></span>
<span id="cb201-18"><a href="#cb201-18"></a>    <span class="dt">char</span> <span class="op">*</span>buf<span class="op">;</span> <span class="co">// El buffer</span></span>
<span id="cb201-19"><a href="#cb201-19"></a>    <span class="dt">int</span> c<span class="op">;</span> <span class="co">// El carácter que hemos leído</span></span>
<span id="cb201-20"><a href="#cb201-20"></a></span>
<span id="cb201-21"><a href="#cb201-21"></a>    buf <span class="op">=</span> malloc<span class="op">(</span>bufsize<span class="op">);</span>  <span class="co">// Asignar búfer inicial</span></span>
<span id="cb201-22"><a href="#cb201-22"></a></span>
<span id="cb201-23"><a href="#cb201-23"></a>    <span class="cf">if</span> <span class="op">(</span>buf <span class="op">==</span> NULL<span class="op">)</span>   <span class="co">// Comprobación de errores</span></span>
<span id="cb201-24"><a href="#cb201-24"></a>        <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb201-25"><a href="#cb201-25"></a></span>
<span id="cb201-26"><a href="#cb201-26"></a>    <span class="co">// Bucle principal--leer hasta nueva línea o EOF</span></span>
<span id="cb201-27"><a href="#cb201-27"></a>    <span class="cf">while</span> <span class="op">(</span>c <span class="op">=</span> fgetc<span class="op">(</span>fp<span class="op">),</span> c <span class="op">!=</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">!=</span> EOF<span class="op">)</span> <span class="op">{</span></span>
<span id="cb201-28"><a href="#cb201-28"></a></span>
<span id="cb201-29"><a href="#cb201-29"></a>        <span class="co">// Comprueba si nos hemos quedado sin espacio en el buffer contabilidad</span></span>
<span id="cb201-30"><a href="#cb201-30"></a>        <span class="co">// por el byte extra para el terminador NUL</span></span>
<span id="cb201-31"><a href="#cb201-31"></a>        <span class="cf">if</span> <span class="op">(</span>offset <span class="op">==</span> bufsize <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// -1 para el terminador NUL</span></span>
<span id="cb201-32"><a href="#cb201-32"></a>            bufsize <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span>  <span class="co">// 2x el espacio</span></span>
<span id="cb201-33"><a href="#cb201-33"></a></span>
<span id="cb201-34"><a href="#cb201-34"></a>            <span class="dt">char</span> <span class="op">*</span>new_buf <span class="op">=</span> realloc<span class="op">(</span>buf<span class="op">,</span> bufsize<span class="op">);</span></span>
<span id="cb201-35"><a href="#cb201-35"></a></span>
<span id="cb201-36"><a href="#cb201-36"></a>            <span class="cf">if</span> <span class="op">(</span>new_buf <span class="op">==</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb201-37"><a href="#cb201-37"></a>                free<span class="op">(</span>buf<span class="op">);</span>   <span class="co">// En caso de error, libera y paga su fianza.</span></span>
<span id="cb201-38"><a href="#cb201-38"></a>                <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb201-39"><a href="#cb201-39"></a>            <span class="op">}</span></span>
<span id="cb201-40"><a href="#cb201-40"></a></span>
<span id="cb201-41"><a href="#cb201-41"></a>            buf <span class="op">=</span> new_buf<span class="op">;</span>  <span class="co">// Reasignación correcta</span></span>
<span id="cb201-42"><a href="#cb201-42"></a>        <span class="op">}</span></span>
<span id="cb201-43"><a href="#cb201-43"></a></span>
<span id="cb201-44"><a href="#cb201-44"></a>        buf<span class="op">[</span>offset<span class="op">++]</span> <span class="op">=</span> c<span class="op">;</span>  <span class="co">// Añade el byte al buffer</span></span>
<span id="cb201-45"><a href="#cb201-45"></a>    <span class="op">}</span></span>
<span id="cb201-46"><a href="#cb201-46"></a></span>
<span id="cb201-47"><a href="#cb201-47"></a>    <span class="co">// Llegamos a la nueva línea o a EOF...</span></span>
<span id="cb201-48"><a href="#cb201-48"></a></span>
<span id="cb201-49"><a href="#cb201-49"></a>    <span class="co">// Si es EOF y no leemos bytes, liberamos el buffer y</span></span>
<span id="cb201-50"><a href="#cb201-50"></a>    <span class="co">// devuelve NULL para indicar que estamos en EOF:</span></span>
<span id="cb201-51"><a href="#cb201-51"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> EOF <span class="op">&amp;&amp;</span> offset <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb201-52"><a href="#cb201-52"></a>        free<span class="op">(</span>buf<span class="op">);</span></span>
<span id="cb201-53"><a href="#cb201-53"></a>        <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb201-54"><a href="#cb201-54"></a>    <span class="op">}</span></span>
<span id="cb201-55"><a href="#cb201-55"></a></span>
<span id="cb201-56"><a href="#cb201-56"></a>    <span class="co">// Ajustar</span></span>
<span id="cb201-57"><a href="#cb201-57"></a>    <span class="cf">if</span> <span class="op">(</span>offset <span class="op">&lt;</span> bufsize <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// Si nos falta para el final</span></span>
<span id="cb201-58"><a href="#cb201-58"></a>        <span class="dt">char</span> <span class="op">*</span>new_buf <span class="op">=</span> realloc<span class="op">(</span>buf<span class="op">,</span> offset <span class="op">+</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// +1 por terminación NUL</span></span>
<span id="cb201-59"><a href="#cb201-59"></a></span>
<span id="cb201-60"><a href="#cb201-60"></a>        <span class="co">// Si tiene éxito, apunta buf a new_buf;</span></span>
<span id="cb201-61"><a href="#cb201-61"></a>        <span class="co">// de lo contrario dejaremos buf donde está</span></span>
<span id="cb201-62"><a href="#cb201-62"></a>        <span class="cf">if</span> <span class="op">(</span>new_buf <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb201-63"><a href="#cb201-63"></a>            buf <span class="op">=</span> new_buf<span class="op">;</span></span>
<span id="cb201-64"><a href="#cb201-64"></a>    <span class="op">}</span></span>
<span id="cb201-65"><a href="#cb201-65"></a></span>
<span id="cb201-66"><a href="#cb201-66"></a>    <span class="co">// Añadir el terminador NUL</span></span>
<span id="cb201-67"><a href="#cb201-67"></a>    buf<span class="op">[</span>offset<span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb201-68"><a href="#cb201-68"></a></span>
<span id="cb201-69"><a href="#cb201-69"></a>    <span class="cf">return</span> buf<span class="op">;</span></span>
<span id="cb201-70"><a href="#cb201-70"></a><span class="op">}</span></span>
<span id="cb201-71"><a href="#cb201-71"></a></span>
<span id="cb201-72"><a href="#cb201-72"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb201-73"><a href="#cb201-73"></a><span class="op">{</span></span>
<span id="cb201-74"><a href="#cb201-74"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;foo.txt&quot;</span><span class="op">,</span> <span class="st">&quot;r&quot;</span><span class="op">);</span></span>
<span id="cb201-75"><a href="#cb201-75"></a></span>
<span id="cb201-76"><a href="#cb201-76"></a>    <span class="dt">char</span> <span class="op">*</span>line<span class="op">;</span></span>
<span id="cb201-77"><a href="#cb201-77"></a></span>
<span id="cb201-78"><a href="#cb201-78"></a>    <span class="cf">while</span> <span class="op">((</span>line <span class="op">=</span> readline<span class="op">(</span>fp<span class="op">))</span> <span class="op">!=</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb201-79"><a href="#cb201-79"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> line<span class="op">);</span></span>
<span id="cb201-80"><a href="#cb201-80"></a>        free<span class="op">(</span>line<span class="op">);</span></span>
<span id="cb201-81"><a href="#cb201-81"></a>    <span class="op">}</span></span>
<span id="cb201-82"><a href="#cb201-82"></a></span>
<span id="cb201-83"><a href="#cb201-83"></a>    fclose<span class="op">(</span>fp<span class="op">);</span></span>
<span id="cb201-84"><a href="#cb201-84"></a><span class="op">}</span></span></code></pre></div>
<p>Cuando la memoria crece de esta manera, es común (aunque no es una ley) doblar el espacio necesario en cada paso para minimizar el número de <code>realloc()</code>s que ocurren.</p>
<p>Por último, tenga en cuenta que <code>readline()</code> devuelve un puntero a un buffer <code>malloc()</code>. Como tal, es responsabilidad de quien lo llama liberar explícitamente esa memoria cuando termine de usarla.</p>
<h3 data-number="12.5.2" id="realloc-con-null."><span class="header-section-number">12.5.2</span> <code>realloc()</code> con <code>NULL</code>.</h3>
<p> ¡Hora del Trivial! Estas dos líneas son equivalentes:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> malloc<span class="op">(</span><span class="dv">3490</span><span class="op">);</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> realloc<span class="op">(</span>NULL<span class="op">,</span> <span class="dv">3490</span><span class="op">);</span></span></code></pre></div>
<p>Esto podría ser conveniente si se tiene algún tipo de bucle de asignación y no se quiere poner en un caso especial el primer <code>malloc()</code>.</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> length <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(!</span>done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Asigna 10 ints más:</span></span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a>    length <span class="op">+=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> realloc<span class="op">(</span>p<span class="op">,</span> <span class="kw">sizeof</span> <span class="op">*</span>p <span class="op">*</span> length<span class="op">);</span></span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Hacer cosas increíbles</span></span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>En ese ejemplo, no necesitábamos un <code>malloc()</code> inicial ya que <code>p</code> era <code>NULL</code> para empezar. </p>
<h2 data-number="12.6" id="asignaciones-alineadas"><span class="header-section-number">12.6</span> Asignaciones alineadas</h2>
<p> Probablemente no vas a necesitar usar esto.</p>
<p>Y no quiero meterme demasiado en la maleza hablando de ello ahora mismo, pero hay una cosa llamada <em>alineación de memoria</em>, que tiene que ver con que la dirección de memoria (valor del puntero) sea múltiplo de un cierto número.</p>
<p>Por ejemplo, un sistema puede requerir que los valores de 16 bits comiencen en direcciones de memoria que sean múltiplos de 2. O que los valores de 64 bits comiencen en direcciones de memoria que sean múltiplos de 2, 4 u 8, por ejemplo. Depende de la CPU.</p>
<p>Algunos sistemas requieren este tipo de alineación para un acceso rápido a la memoria, o algunos incluso para el acceso a la memoria en absoluto.</p>
<p>Ahora, si usas <code>malloc()</code>, <code>calloc()</code>, o <code>realloc()</code>, C te dará un trozo de memoria bien alineado para cualquier valor, incluso <code>struct</code>s. Funciona en todos los casos.</p>
<p>Pero puede haber ocasiones en las que sepas que algunos datos pueden ser alineados en un límite más pequeño, o deben ser alineados en uno más grande por alguna razón. Imagino que esto es más común en la programación de sistemas embebidos.</p>
<p> En esos casos, puede especificar una alineación con <code>aligned_alloc()</code>.</p>
<p>La alineación es una potencia entera de dos mayor que cero, así que <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, etc. y se la das a <code>aligned_alloc()</code> antes del número de bytes que te interesan.</p>
<p>La otra restricción es que el número de bytes que asignes tiene que ser múltiplo de la alineación. Pero esto puede estar cambiando. Véase <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/summary.htm#dr_460">C Informe de defectos 460</a><a href="#fn89" class="footnote-ref" id="fnref89" role="doc-noteref"><sup>89</sup></a></p>
<p>Hagamos un ejemplo, asignando en un límite de 64 bytes:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb204-1"><a href="#cb204-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb204-2"><a href="#cb204-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb204-3"><a href="#cb204-3"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb204-4"><a href="#cb204-4"></a></span>
<span id="cb204-5"><a href="#cb204-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb204-6"><a href="#cb204-6"></a><span class="op">{</span></span>
<span id="cb204-7"><a href="#cb204-7"></a>    <span class="co">// Asignar 256 bytes alineados en un límite de 64 bytes</span></span>
<span id="cb204-8"><a href="#cb204-8"></a>    <span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> aligned_alloc<span class="op">(</span><span class="dv">64</span><span class="op">,</span> <span class="dv">256</span><span class="op">);</span>  <span class="co">// 256 == 64 * 4</span></span>
<span id="cb204-9"><a href="#cb204-9"></a></span>
<span id="cb204-10"><a href="#cb204-10"></a>    <span class="co">// Copia una cadena e imprímela</span></span>
<span id="cb204-11"><a href="#cb204-11"></a>    strcpy<span class="op">(</span>p<span class="op">,</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">);</span></span>
<span id="cb204-12"><a href="#cb204-12"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">);</span></span>
<span id="cb204-13"><a href="#cb204-13"></a></span>
<span id="cb204-14"><a href="#cb204-14"></a>    <span class="co">// Liberar el espacio</span></span>
<span id="cb204-15"><a href="#cb204-15"></a>    free<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb204-16"><a href="#cb204-16"></a><span class="op">}</span></span></code></pre></div>
<p>Quiero hacer un comentario sobre <code>realloc()</code> y <code>aligned_alloc()</code>. <code>realloc()</code> no tiene ninguna garantía de alineación, así que si necesitas obtener espacio reasignado alineado, tendrás que hacerlo por las malas con <code>memcpy()</code>. </p>
<p>Aquí tienes una función no estándar <code>aligned_realloc()</code>, por si la necesitas:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>aligned_realloc<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>ptr<span class="op">,</span> <span class="dt">size_t</span> old_size<span class="op">,</span> <span class="dt">size_t</span> alignment<span class="op">,</span> <span class="dt">size_t</span> size<span class="op">)</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>new_ptr <span class="op">=</span> aligned_alloc<span class="op">(</span>alignment<span class="op">,</span> size<span class="op">);</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>new_ptr <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> copy_size <span class="op">=</span> old_size <span class="op">&lt;</span> size<span class="op">?</span> old_size<span class="op">:</span> size<span class="op">;</span>  <span class="co">// obtener min</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ptr <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb205-11"><a href="#cb205-11" aria-hidden="true" tabindex="-1"></a>        memcpy<span class="op">(</span>new_ptr<span class="op">,</span> ptr<span class="op">,</span> copy_size<span class="op">);</span></span>
<span id="cb205-12"><a href="#cb205-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-13"><a href="#cb205-13" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb205-14"><a href="#cb205-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-15"><a href="#cb205-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_ptr<span class="op">;</span></span>
<span id="cb205-16"><a href="#cb205-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Tenga en cuenta que <em>siempre</em> copia datos, lo que lleva tiempo, mientras que <code>realloc()</code> real lo evitará si puede. Así que esto es poco eficiente. Evita tener que reasignar datos alineados a medida. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="13" id="scope"><span class="header-section-number">13</span> Alcance</h1>
<p> El alcance se refiere a, en qué contextos son visibles las variables.</p>
<h2 data-number="13.1" id="alcance-del-bloque"><span class="header-section-number">13.1</span> Alcance del bloque</h2>
<p> Este es el ámbito de casi todas las variables que definen los desarrolladores. Incluye lo que en otros lenguajes se denomina «ámbito de función», es decir, las variables que se declaran dentro de funciones.</p>
<p>La regla básica es que si has declarado una variable en un bloque delimitado por llaves, el ámbito de esa variable es ese bloque.</p>
<p>Si hay un bloque dentro de otro bloque, las variables declaradas en el bloque <em>interior</em> son locales a ese bloque y no pueden verse en el ámbito exterior.</p>
<p>Una vez que el ámbito de una variable termina, ya no se puede hacer referencia a esa variable, y se puede considerar que su valor se ha ido <a href="https://en.wikipedia.org/wiki/Bit_%20bucket">al gran cubo de bits</a><a href="#fn90" class="footnote-ref" id="fnref90" role="doc-noteref"><sup>90</sup></a> en el cielo.</p>
<p>Un ejemplo con ámbito anidado:</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb206-1"><a href="#cb206-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb206-2"><a href="#cb206-2"></a></span>
<span id="cb206-3"><a href="#cb206-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb206-4"><a href="#cb206-4"></a><span class="op">{</span></span>
<span id="cb206-5"><a href="#cb206-5"></a>    <span class="dt">int</span> a <span class="op">=</span> <span class="dv">12</span><span class="op">;</span>         <span class="co">// Local al bloque exterior, pero visible en el bloque interior</span></span>
<span id="cb206-6"><a href="#cb206-6"></a></span>
<span id="cb206-7"><a href="#cb206-7"></a>    <span class="cf">if</span>  <span class="op">(</span>a <span class="op">==</span> <span class="dv">12</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb206-8"><a href="#cb206-8"></a>        <span class="dt">int</span> b <span class="op">=</span> <span class="dv">99</span><span class="op">;</span>     <span class="co">// Local al bloque interior, no visible en el bloque exterior</span></span>
<span id="cb206-9"><a href="#cb206-9"></a></span>
<span id="cb206-10"><a href="#cb206-10"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">,</span> b<span class="op">);</span>  <span class="co">// OK: &quot;12 99&quot;</span></span>
<span id="cb206-11"><a href="#cb206-11"></a>    <span class="op">}</span></span>
<span id="cb206-12"><a href="#cb206-12"></a></span>
<span id="cb206-13"><a href="#cb206-13"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// OK, todavía estamos en el ámbito de a</span></span>
<span id="cb206-14"><a href="#cb206-14"></a></span>
<span id="cb206-15"><a href="#cb206-15"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> b<span class="op">);</span>  <span class="co">// ILEGAL, fuera del ámbito de b</span></span>
<span id="cb206-16"><a href="#cb206-16"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="13.1.1" id="dónde-definir-las-variables"><span class="header-section-number">13.1.1</span> Dónde definir las variables</h3>
<p>Otro dato curioso es que se pueden definir variables en cualquier parte del bloque, dentro de lo razonable: tienen el ámbito de ese bloque, pero no se pueden utilizar antes de definirlas.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb207-1"><a href="#cb207-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb207-2"><a href="#cb207-2"></a></span>
<span id="cb207-3"><a href="#cb207-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb207-4"><a href="#cb207-4"></a><span class="op">{</span></span>
<span id="cb207-5"><a href="#cb207-5"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb207-6"><a href="#cb207-6"></a></span>
<span id="cb207-7"><a href="#cb207-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>     <span class="co">// OK: &quot;0&quot;</span></span>
<span id="cb207-8"><a href="#cb207-8"></a></span>
<span id="cb207-9"><a href="#cb207-9"></a>    <span class="co">//printf(&quot;%d\n&quot;, j);   // ILEGAL--no se puede usar j antes de que esté definido</span></span>
<span id="cb207-10"><a href="#cb207-10"></a></span>
<span id="cb207-11"><a href="#cb207-11"></a>    <span class="dt">int</span> j <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb207-12"><a href="#cb207-12"></a></span>
<span id="cb207-13"><a href="#cb207-13"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span>   <span class="co">// OK: &quot;0 5&quot;</span></span>
<span id="cb207-14"><a href="#cb207-14"></a><span class="op">}</span></span></code></pre></div>
<p>Históricamente, C exigía que todas las variables estuvieran definidas antes de cualquier código del bloque, pero esto ya no es así en el estándar C99.</p>
<h3 data-number="13.1.2" id="ocultación-de-variables"><span class="header-section-number">13.1.2</span> Ocultación de variables</h3>
<p> Si tienes una variable con el mismo nombre en un ámbito interno y en un ámbito externo, la del ámbito interno tiene preferencia mientras estés ejecutando en el ámbito interno. Es decir, <em>oculta</em> a la del ámbito externo durante todo su tiempo de vida.</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb208-1"><a href="#cb208-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb208-2"><a href="#cb208-2"></a></span>
<span id="cb208-3"><a href="#cb208-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb208-4"><a href="#cb208-4"></a><span class="op">{</span></span>
<span id="cb208-5"><a href="#cb208-5"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb208-6"><a href="#cb208-6"></a></span>
<span id="cb208-7"><a href="#cb208-7"></a>    <span class="op">{</span></span>
<span id="cb208-8"><a href="#cb208-8"></a>        <span class="dt">int</span> i <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb208-9"><a href="#cb208-9"></a></span>
<span id="cb208-10"><a href="#cb208-10"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>  <span class="co">// Ámbito interno i, 20 (el externo i está oculto)</span></span>
<span id="cb208-11"><a href="#cb208-11"></a>    <span class="op">}</span></span>
<span id="cb208-12"><a href="#cb208-12"></a></span>
<span id="cb208-13"><a href="#cb208-13"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>  <span class="co">// Ámbito exterior i, 10</span></span>
<span id="cb208-14"><a href="#cb208-14"></a><span class="op">}</span></span></code></pre></div>
<p>Te habrás dado cuenta de que en ese ejemplo acabo de lanzar un bloque en la línea 7, ¡ni siquiera una sentencia <code>for</code> o <code>if</code> para iniciarlo! Esto es perfectamente legal. A veces un desarrollador querrá agrupar un montón de variables locales para un cálculo rápido y hará esto, pero es raro de ver. </p>
<h2 data-number="13.2" id="alcance-de-fichero-archivo"><span class="header-section-number">13.2</span> Alcance de fichero / Archivo</h2>
<p> Si define una variable fuera de un bloque, esa variable tiene <em>ámbito de fichero</em>. Es visible en todas las funciones del archivo que vienen después de ella, y compartida entre ellas. (Una excepción es si un bloque define una variable del mismo nombre, ocultaría la que tiene ámbito de archivo).</p>
<p>Es lo más parecido a lo que se consideraría ámbito «global» en otro idioma.</p>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb209-1"><a href="#cb209-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb209-2"><a href="#cb209-2"></a></span>
<span id="cb209-3"><a href="#cb209-3"></a><span class="dt">int</span> shared <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>    <span class="co">// ¡Alcance del fichero!</span></span>
<span id="cb209-4"><a href="#cb209-4"></a>                    <span class="co">// ¡Visible a todo el archivo después de esto!</span></span>
<span id="cb209-5"><a href="#cb209-5"></a></span>
<span id="cb209-6"><a href="#cb209-6"></a><span class="dt">void</span> func1<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb209-7"><a href="#cb209-7"></a><span class="op">{</span></span>
<span id="cb209-8"><a href="#cb209-8"></a>    shared <span class="op">+=</span> <span class="dv">100</span><span class="op">;</span>  <span class="co">// Ahora shared tiene 110</span></span>
<span id="cb209-9"><a href="#cb209-9"></a><span class="op">}</span></span>
<span id="cb209-10"><a href="#cb209-10"></a></span>
<span id="cb209-11"><a href="#cb209-11"></a><span class="dt">void</span> func2<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb209-12"><a href="#cb209-12"></a><span class="op">{</span></span>
<span id="cb209-13"><a href="#cb209-13"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> shared<span class="op">);</span>  <span class="co">// Imprime &quot;110&quot;</span></span>
<span id="cb209-14"><a href="#cb209-14"></a><span class="op">}</span></span>
<span id="cb209-15"><a href="#cb209-15"></a></span>
<span id="cb209-16"><a href="#cb209-16"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb209-17"><a href="#cb209-17"></a><span class="op">{</span></span>
<span id="cb209-18"><a href="#cb209-18"></a>    func1<span class="op">();</span></span>
<span id="cb209-19"><a href="#cb209-19"></a>    func2<span class="op">();</span></span>
<span id="cb209-20"><a href="#cb209-20"></a><span class="op">}</span></span></code></pre></div>
<p>Ten en cuenta que si <code>shared</code> se declarara al final del fichero, no compilaría. Tiene que ser declarado <em>antes</em> de que cualquier función lo use.</p>
<p>Hay otras formas de modificar elementos en el ámbito del fichero, concretamente con <a href="#static">static</a> y <a href="#extern">extern</a>, pero hablaremos de ellas más adelante. </p>
<h2 data-number="13.3" id="ambito-del-bucle-for"><span class="header-section-number">13.3</span> Ambito del bucle <code>for</code></h2>
<p> Realmente no sé cómo llamar a esto, ya que C11 §6.8.5.3¶1 no le da un nombre apropiado. También lo hemos hecho ya varias veces en esta guía. Es cuando declaras una variable dentro de la primera cláusula de un bucle <code>for</code>:</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>  <span class="co">// ILEGAL--i sólo está en el ámbito del bucle for</span></span></code></pre></div>
<p>En ese ejemplo, el tiempo de vida de <code>i</code> comienza en el momento en que se define, y continúa durante la duración del bucle.</p>
<p>Si el cuerpo del bucle está encerrado en un bloque, las variables definidas en el bucle <code>for</code> son visibles desde ese ámbito interno.</p>
<p>A menos, por supuesto, que ese ámbito interno las oculte. Este ejemplo loco imprime <code>999</code> cinco veces:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb211-1"><a href="#cb211-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb211-2"><a href="#cb211-2"></a></span>
<span id="cb211-3"><a href="#cb211-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb211-4"><a href="#cb211-4"></a><span class="op">{</span></span>
<span id="cb211-5"><a href="#cb211-5"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb211-6"><a href="#cb211-6"></a>        <span class="dt">int</span> i <span class="op">=</span> <span class="dv">999</span><span class="op">;</span>  <span class="co">// Oculta la i en el ámbito del bucle for</span></span>
<span id="cb211-7"><a href="#cb211-7"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb211-8"><a href="#cb211-8"></a>    <span class="op">}</span></span>
<span id="cb211-9"><a href="#cb211-9"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h2 data-number="13.4" id="nota-sobre-el-alcance-de-las-funciones"><span class="header-section-number">13.4</span> Nota sobre el alcance de las funciones</h2>
<p> La especificación C hace referencia a <em>function scope</em> (alcance de funciones), pero se utiliza exclusivamente con <em>labels</em> (etiquetas), algo que aún no hemos discutido. Otro día hablaremos de ello. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="14" id="tipos-ii-muchos-más-tipos"><span class="header-section-number">14</span> Tipos II: ¡Muchos más tipos!</h1>
<p>Estamos acostumbrados a los tipos <code>char</code>, <code>int</code> y <code>float</code>, pero ha llegado el momento de pasar al siguiente nivel y ver qué más tenemos en el departamento de tipos.</p>
<h2 data-number="14.1" id="enteros-con-y-sin-signo"><span class="header-section-number">14.1</span> Enteros con y sin signo</h2>
<p> Hasta ahora hemos utilizado <code>int</code> como un tipo <em>signed (signado)</em>, es decir, un valor que puede ser negativo o positivo. Pero C también tiene tipos enteros <em>unsigned (sin signo)</em> que sólo pueden contener números positivos.</p>
<p>Estos tipos van precedidos de la palabra clave <code>unsigned</code>.</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">;</span> <span class="co">// con signo</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a><span class="dt">signed</span> <span class="dt">int</span> a<span class="op">;</span> <span class="co">// con signo</span></span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a><span class="dt">signed</span> a<span class="op">;</span> <span class="co">// con signo, «abreviatura» de «int» o «signed int», poco frecuente</span></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">int</span> b<span class="op">;</span> <span class="co">// sin signo</span></span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> c<span class="op">;</span> <span class="co">// unsigned, abreviatura de «unsigned int».</span></span></code></pre></div>
<p>¿Por qué? ¿Por qué decidiste que sólo querías contener números positivos?</p>
<p>Respuesta: puedes obtener números más grandes en una variable sin signo que en una con signo.</p>
<p>Pero, ¿por qué?</p>
<p>Puedes pensar que los números enteros están representados por un cierto número de <em>bits</em><a href="#fn91" class="footnote-ref" id="fnref91" role="doc-noteref"><sup>91</sup></a>. En mi ordenador, un <code>int</code> se representa con 64 bits.</p>
<p>Y cada permutación de bits que son <code>1</code> o <code>0</code> representa un número. Podemos decidir cómo repartir estos números.</p>
<p>Con los números con signo, utilizamos (aproximadamente) la mitad de las permutaciones para representar números negativos, y la otra mitad para representar números positivos.</p>
<p>Con números sin signo, usamos <em>todas</em> las permutaciones para representar números positivos.</p>
<p>En mi ordenador con <code>int</code>s de 64 bits que utiliza el <a href="https://en.wikipedia.org/wiki/Two%27s_complement">complemento a dos</a><a href="#fn92" class="footnote-ref" id="fnref92" role="doc-noteref"><sup>92</sup></a> para representar números sin signo, tengo los siguientes límites en el rango de enteros:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: right;">Mínimo</th>
<th style="text-align: right;">Máximo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: right;"><code>-9,223,372,036,854,775,808</code></td>
<td style="text-align: right;"><code>9,223,372,036,854,775,807</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned int</code></td>
<td style="text-align: right;"><code>0</code></td>
<td style="text-align: right;"><code>18,446,744,073,709,551,615</code></td>
</tr>
</tbody>
</table>
<p>Fíjate en que el mayor <code>unsigned int</code> positivo es aproximadamente el doble de grande que el mayor <code>int</code> positivo. Así que puedes tener cierta flexibilidad. </p>
<h2 data-number="14.2" id="tipos-de-caracteres"><span class="header-section-number">14.2</span> Tipos de caracteres</h2>
<p> ¿Recuerdas <code>char</code>? ¿El tipo que podemos utilizar para contener un único carácter?</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c <span class="op">=</span> <span class="ch">&#39;B&#39;</span><span class="op">;</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">);</span>  <span class="co">// &quot;B&quot;</span></span></code></pre></div>
<p>Tengo una sorpresa para ti: en realidad es un número entero.</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c <span class="op">=</span> <span class="ch">&#39;B&#39;</span><span class="op">;</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Cambia esto de %c a %d:</span></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">);</span>  <span class="co">// 66 (!!)</span></span></code></pre></div>
<p>En el fondo, <code>char</code> no es más que un pequeño <code>int</code>, es decir, un entero que utiliza un único byte de espacio, limitando su rango a…</p>
<p>Aquí la especificación C se pone un poco rara. Nos asegura que un <code>char</code> es un único byte, es decir, <code>sizeof(char) == 1</code>. Pero entonces en C11 §3.6¶3 se sale de su camino para decir:</p>
<blockquote>
<p>Un byte está compuesto por una secuencia contigua de bits, cuyo número está definido por la implementación.</p>
</blockquote>
<p>Espera… ¿qué? Algunos de ustedes pueden estar acostumbrados a la noción de que un byte es de 8 bits, ¿verdad? Quiero decir, eso es lo que es, ¿verdad? Y la respuesta es: «Casi seguro»<a href="#fn93" class="footnote-ref" id="fnref93" role="doc-noteref"><sup>93</sup></a>. Pero C es un lenguaje antiguo, y las máquinas de antes tenían, digamos, una opinión más <em>relajada</em> sobre cuántos bits había en un byte. Y a lo largo de los años, C ha conservado esta flexibilidad.</p>
<p>Pero asumiendo que tus bytes en C son de 8 bits, como lo son en prácticamente todas las máquinas del mundo que verás, el rango de un <code>char</code> es…</p>
<p> —Así que antes de que pueda decírtelo, resulta que <code>char</code>s puede ser con o sin signo dependiendo de tu compilador. A menos que lo especifiques explícitamente.</p>
<p>En muchos casos, sólo tener <code>char</code>s está bien porque no te importa el signo de los datos. Pero si necesitas <code>char</code>s con signo o sin signo, <em>debes</em> ser específico:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> a<span class="op">;</span> <span class="co">// Puede ser con o sin signo</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a><span class="dt">signed</span> <span class="dt">char</span> b<span class="op">;</span> <span class="co">// Definitivamente con signo</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> c<span class="op">;</span> <span class="co">// Definitivamente sin signo</span></span></code></pre></div>
<p>OK, ahora, finalmente, podemos averiguar el rango de números si asumimos que un <code>char</code> es de 8 bits y su sistema utiliza la virtualmente universal representación de complemento a dos para con signo y sin signo<a href="#fn94" class="footnote-ref" id="fnref94" role="doc-noteref"><sup>94</sup></a>.</p>
<p>Así que, asumiendo esas limitaciones, por fin podemos calcular nuestros rangos:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo <code>char</code></th>
<th style="text-align: right;">Mínimo</th>
<th style="text-align: right;">Máximo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>signed char</code></td>
<td style="text-align: right;"><code>-128</code></td>
<td style="text-align: right;"><code>127</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned char</code></td>
<td style="text-align: right;"><code>0</code></td>
<td style="text-align: right;"><code>255</code></td>
</tr>
</tbody>
</table>
<p>Y los rangos para <code>char</code> están definidos por la implementación. </p>
<p>A ver si lo entiendo. <code>char</code> es en realidad un número, así que ¿podemos hacer matemáticas con él?</p>
<p>Sí. Sólo recuerda mantener las cosas dentro del rango de un <code>char</code>. //Nota del traductor, esto es <strong>extremadamente importante</strong>, no lo olvides</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb216-1"><a href="#cb216-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb216-2"><a href="#cb216-2"></a></span>
<span id="cb216-3"><a href="#cb216-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb216-4"><a href="#cb216-4"></a><span class="op">{</span></span>
<span id="cb216-5"><a href="#cb216-5"></a>    <span class="dt">char</span> a <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> b <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb216-6"><a href="#cb216-6"></a></span>
<span id="cb216-7"><a href="#cb216-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a <span class="op">+</span> b<span class="op">);</span>  <span class="co">// 30!</span></span>
<span id="cb216-8"><a href="#cb216-8"></a><span class="op">}</span></span></code></pre></div>
<p> ¿Qué ocurre con los caracteres constantes entre comillas simples, como <code>'B'</code>? ¿Cómo puede eso tener un valor numérico?</p>
<p>La especificación también es imprecisa en este caso, ya que C no está diseñado para ejecutarse en un único tipo de sistema subyacente.</p>
<p>Pero asumamos por el momento que su juego de caracteres está basado en <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a><a href="#fn95" class="footnote-ref" id="fnref95" role="doc-noteref"><sup>95</sup></a>para al menos los primeros 128 caracteres. En ese caso, la constante de carácter se convertirá en un <code>char</code> cuyo valor es el mismo que el valor ASCII del carácter.</p>
<p>Eso ha sido un trabalenguas. Pongamos un ejemplo:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb217-1"><a href="#cb217-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb217-2"><a href="#cb217-2"></a></span>
<span id="cb217-3"><a href="#cb217-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb217-4"><a href="#cb217-4"></a><span class="op">{</span></span>
<span id="cb217-5"><a href="#cb217-5"></a>    <span class="dt">char</span> a <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb217-6"><a href="#cb217-6"></a>    <span class="dt">char</span> b <span class="op">=</span> <span class="ch">&#39;B&#39;</span><span class="op">;</span>  <span class="co">// Valor en ASCII 66</span></span>
<span id="cb217-7"><a href="#cb217-7"></a></span>
<span id="cb217-8"><a href="#cb217-8"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a <span class="op">+</span> b<span class="op">);</span>  <span class="co">// 76!</span></span>
<span id="cb217-9"><a href="#cb217-9"></a><span class="op">}</span></span></code></pre></div>
<p>Esto depende de su entorno de ejecución y del <a href="https://en.wikipedia.org/wiki/%20List_of%20information_system_character_sets">juego de caracteres utilizado</a><a href="#fn96" class="footnote-ref" id="fnref96" role="doc-noteref"><sup>96</sup></a>. Uno de los conjuntos de caracteres más populares hoy en día es <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a><a href="#fn97" class="footnote-ref" id="fnref97" role="doc-noteref"><sup>97</sup></a> (que es un superconjunto de ASCII), por lo que para tus 0-9, A-Z, a-z y signos de puntuación básicos, casi seguro que obtendrás los valores ASCII.</p>
<p> </p>
<h2 data-number="14.3" id="más-tipos-de-enteros-short-long-long-long"><span class="header-section-number">14.3</span> Más tipos de enteros: <code>short</code>, <code>long</code>, <code>long long</code></h2>
<p>Hasta ahora hemos estado utilizando generalmente dos tipos enteros:</p>
<ul>
<li><code>char</code></li>
<li><code>int</code></li>
</ul>
<p>y recientemente hemos aprendido sobre las variantes sin signo de los tipos enteros. Y aprendimos que <code>char</code> era secretamente un pequeño <code>int</code> disfrazado. Así que sabemos que los <code>int</code>s pueden venir en múltiples tamaños de bit.</p>
<p>Pero hay un par de tipos enteros más que deberíamos ver, y los valores <em>mínimo</em> <em>minímo</em> y <em>máximo</em> que pueden contener.</p>
<p>Sí, he dicho «mínimo» dos veces. La especificación dice que estos tipos contendrán números de <em>al menos</em> estos tamaños, así que tu implementación puede ser diferente. El fichero de cabecera <code>&lt;limits.h&gt;</code> define macros que contienen los valores enteros mínimo y máximo; confíe en ello para estar seguro, y <em>nunca codifique o asuma estos valores</em>. Estos tipos adicionales son <code>short int</code>, <code>long int</code> y <code>long long int</code>. Normalmente, cuando se utilizan estos tipos, los desarrolladores de C omiten la parte <code>int</code> (por ejemplo, <code>long long</code>), y el compilador no tiene ningún problema.</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Estas dos líneas son equivalentes:</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> x<span class="op">;</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Y estos también:</span></span>
<span id="cb218-6"><a href="#cb218-6" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb218-7"><a href="#cb218-7" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> x<span class="op">;</span></span></code></pre></div>
<p>Veamos los tipos y tamaños de datos enteros en orden ascendente, agrupados por signatura.</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: right;">Bytes mínimos</th>
<th style="text-align: right;">Valor mínimo</th>
<th style="text-align: right;">Valor máximo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>char</code></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">-127 or 0</td>
<td style="text-align: right;">127 or 255<a href="#fn98" class="footnote-ref" id="fnref98" role="doc-noteref"><sup>98</sup></a>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>signed char</code></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">-127</td>
<td style="text-align: right;">127</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>short</code></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">-32767</td>
<td style="text-align: right;">32767</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">-32767</td>
<td style="text-align: right;">32767</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">-2147483647</td>
<td style="text-align: right;">2147483647</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>long long</code></td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">-9223372036854775807</td>
<td style="text-align: right;">9223372036854775807</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned char</code></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">255</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned short</code></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">65535</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned int</code></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">65535</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned long</code></td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">4294967295</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned long long</code></td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">18446744073709551615</td>
</tr>
</tbody>
</table>
<p>No existe el tipo <code>long long long</code>. No puedes seguir añadiendo <code>long</code>s así. No seas tonto.</p>
<blockquote>
<p>Los aficionados a los complementos a dos habrán notado algo raro en esos números. ¿Por qué, por ejemplo, el <code>signed char</code> se detiene en -127 en lugar de -128? Recuerde: estos son sólo los mínimos requeridos por la especificación. Algunas representaciones numéricas (como <a href="https://en.wikipedia.org/wiki/Signed_number_representations#Signed_magnitude_representation">signo y magnitud</a><a href="#fn99" class="footnote-ref" id="fnref99" role="doc-noteref"><sup>99</sup></a>) tienen un máximo de ±127.</p>
</blockquote>
<p>Ejecutemos la misma tabla en mi sistema de 64 bits y complemento a dos y veamos qué sale:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: right;">Mis Bytes</th>
<th style="text-align: right;">Valor mínimo</th>
<th style="text-align: right;">Valor máximo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>char</code></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">-128</td>
<td style="text-align: right;">127<a href="#fn100" class="footnote-ref" id="fnref100" role="doc-noteref"><sup>100</sup></a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>signed char</code></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">-128</td>
<td style="text-align: right;">127</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>short</code></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">-32768</td>
<td style="text-align: right;">32767</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">-2147483648</td>
<td style="text-align: right;">2147483647</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">-9223372036854775808</td>
<td style="text-align: right;">9223372036854775807</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>long long</code></td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">-9223372036854775808</td>
<td style="text-align: right;">9223372036854775807</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned char</code></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">255</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned short</code></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">65535</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned int</code></td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">4294967295</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned long</code></td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">18446744073709551615</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned long long</code></td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">18446744073709551615</td>
</tr>
</tbody>
</table>
<p>Eso es un poco más sensato, pero podemos ver cómo mi sistema tiene límites mayores que los mínimos de la especificación.</p>
<p><span id="limits-macros">Entonces, ¿qué son las macros en <code>&lt;limits.h&gt;</code>?</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: left;">Macro mínima</th>
<th style="text-align: left;">Macro máxima</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>char</code></td>
<td style="text-align: left;"><code>CHAR_MIN</code></td>
<td style="text-align: left;"><code>CHAR_MAX</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>signed char</code></td>
<td style="text-align: left;"><code>SCHAR_MIN</code></td>
<td style="text-align: left;"><code>SCHAR_MAX</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>short</code></td>
<td style="text-align: left;"><code>SHRT_MIN</code></td>
<td style="text-align: left;"><code>SHRT_MAX</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>INT_MIN</code></td>
<td style="text-align: left;"><code>INT_MAX</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>LONG_MIN</code></td>
<td style="text-align: left;"><code>LONG_MAX</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>long long</code></td>
<td style="text-align: left;"><code>LLONG_MIN</code></td>
<td style="text-align: left;"><code>LLONG_MAX</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned char</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>UCHAR_MAX</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned short</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>USHRT_MAX</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned int</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>UINT_MAX</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned long</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>ULONG_MAX</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned long long</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>ULLONG_MAX</code></td>
</tr>
</tbody>
</table>
<p>Fíjate que hay una forma oculta de determinar si un sistema utiliza <code>char</code>s con signo o sin signo. Si <code>CHAR_MAX == UCHAR_MAX</code>, debe ser sin signo.</p>
<p>Fíjate también en que no hay macro mínima para las variantes «sin signo»: son simplemente «0». </p>
<h2 data-number="14.4" id="más-float-double-y-long-double."><span class="header-section-number">14.4</span> Más Float: <code>double</code> y <code>long double</code>.</h2>
<p>Veamos qué dice la especificación sobre los números de coma flotante en §5.2.4.2.2¶1-2:</p>
<blockquote>
<p>Los siguientes parámetros se utilizan para definir el modelo para cada tipo de punto flotante:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Parametro</th>
<th style="text-align: left;">Definición</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(s\)</span></td>
<td style="text-align: left;">signo (<span class="math inline">\(\pm1\)</span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(b\)</span></td>
<td style="text-align: left;">base o radix de la representación del exponente (un entero <span class="math inline">\(&gt; 1\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(e\)</span></td>
<td style="text-align: left;">exponente (un número entero entre un mínimo <span class="math inline">\(e_{min}\)</span> y un máximo <span class="math inline">\(e_{max}\)</span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(p\)</span></td>
<td style="text-align: left;">precisión (el número de dígitos de base-<span class="math inline">\(b\)</span> en el significando)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(f_k\)</span></td>
<td style="text-align: left;">enteros no negativos menores que <span class="math inline">\(b\)</span> (los dígitos significantes)</td>
</tr>
</tbody>
</table>
<p>Un <em>número de punto flotante</em> (<span class="math inline">\(x\)</span>) se define mediante el siguiente modelo:</p>
<blockquote>
<p><span class="math inline">\(x=sb^e\sum\limits_{k=1}^p f_kb^{-k},\)</span>    <span class="math inline">\(e_{min}\le e\le e_{max}\)</span></p>
</blockquote>
</blockquote>
<p>Espero que eso te lo haya aclarado.</p>
<p>De acuerdo. Retrocedamos un poco y veamos qué es práctico.</p>
<p>Nota: nos referimos a un montón de macros en esta sección. Se pueden encontrar en la cabecera <code>&lt;float.h&gt;</code>.</p>
<p>Los números en coma flotante se codifican en una secuencia específica de bits (<a href="https://en.wikipedia.org/wiki/IEEE_754">Formato IEEE-754</a><a href="#fn101" class="footnote-ref" id="fnref101" role="doc-noteref"><sup>101</sup></a> es tremendamente popular) en bytes.</p>
<p>Profundizando un poco más, el número se representa básicamente como el <em>significando</em> (que es la parte numérica–los dígitos significativos propiamente dichos, también llamados a veces la <em>mantisa</em>) y el <em>exponente</em>, que es a qué potencia elevar los dígitos. Recordemos que un exponente negativo puede hacer que un número sea más pequeño.</p>
<p>Imaginemos que usamos <span class="math inline">\(10\)</span> como número a elevar por un exponente. Podríamos representar los siguientes números utilizando un significando de <span class="math inline">\(12345\)</span>, y exponentes de <span class="math inline">\(-3\)</span>, <span class="math inline">\(4\)</span>, y <span class="math inline">\(0\)</span> para codificar los siguientes valores en coma flotante:</p>
<p><span class="math inline">\(12345\times10^{-3}=12.345\)</span></p>
<p><span class="math inline">\(12345\times10^4=123450000\)</span></p>
<p><span class="math inline">\(12345\times10^0=12345\)</span></p>
<p>Para todos esos números, el significante sigue siendo el mismo. La única diferencia es el exponente.</p>
<p>En tu máquina, la base para el exponente es probablemente <span class="math inline">\(2\)</span>, no <span class="math inline">\(10\)</span>, ya que a los ordenadores les gusta el binario. Puedes comprobarlo imprimiendo la macro <code>FLT_RADIX</code>.</p>
<p>Así que tenemos un número que está representado por un número de bytes, codificados de alguna manera. Como hay un número limitado de patrones de bits, se puede representar un número limitado de números en coma flotante.</p>
<p>Pero más concretamente, sólo se puede representar con precisión un cierto número de dígitos decimales significativos.</p>
<p>¿Cómo conseguir más? Utilizando tipos de datos más grandes.</p>
<p>Y tenemos un par de ellos. Ya conocemos <code>float</code>, pero para más precisión tenemos <code>double</code>. Y para aún más precisión, tenemos <code>long double</code> (no relacionado con <code>long int</code> excepto por el nombre).</p>
<p>La especificación no especifica cuántos bytes de almacenamiento debe ocupar cada tipo, pero en mi sistema podemos ver los incrementos de tamaño relativos:</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: right;"><code>sizeof</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>float</code></td>
<td style="text-align: right;">4</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>double</code></td>
<td style="text-align: right;">8</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long double</code></td>
<td style="text-align: right;">16</td>
</tr>
</tbody>
</table>
<p>Así que cada uno de los tipos (en mi sistema) utiliza esos bits adicionales para obtener más precisión.</p>
<p>¿Pero de cuánta precisión estamos hablando? ¿Cuántos números decimales pueden ser representados por estos valores?</p>
<p>Bueno, C nos proporciona un montón de macros en <code>&lt;float.h&gt;</code> para ayudarnos a averiguarlo.</p>
<p>La cosa se complica un poco si estás usando un sistema de base-2 (binario) para almacenar los números (que es prácticamente todo el mundo en el planeta, probablemente incluyéndote a ti), pero ten paciencia conmigo mientras lo resolvemos. </p>
<h3 data-number="14.4.1" id="cuántas-cifras-decimales"><span class="header-section-number">14.4.1</span> ¿Cuántas cifras decimales?</h3>
<p> La pregunta del millón es: «¿Cuántos dígitos decimales significativos puedo almacenar en un determinado tipo de coma flotante para que me salga el mismo número decimal al imprimirlo?».</p>
<p>El número de dígitos decimales que puedes almacenar en un tipo de coma flotante y obtener con seguridad el mismo número al imprimirlo viene dado por estas macros:</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: right;">Dígitos decimales que puede almacenar</th>
<th style="text-align: right;">Mínimo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>float</code></td>
<td style="text-align: right;"><code>FLT_DIG</code></td>
<td style="text-align: right;">6</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>double</code></td>
<td style="text-align: right;"><code>DBL_DIG</code></td>
<td style="text-align: right;">10</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long double</code></td>
<td style="text-align: right;"><code>LDBL_DIG</code></td>
<td style="text-align: right;">10</td>
</tr>
</tbody>
</table>
<p> </p>
<p>En mi sistema, <code>FLT_DIG</code> es 6, así que puedo estar seguro de que si imprimo un <code>float</code> de 6 dígitos, obtendré lo mismo de vuelta. (Podrían ser más dígitos—algunos números volverán correctamente con más dígitos. Pero sin duda me devolverá 6).</p>
<p>Por ejemplo, imprimiendo <code>float</code>s siguiendo este patrón de dígitos crecientes, aparentemente llegamos a 8 dígitos antes de que algo vaya mal, pero después de eso volvemos a 7 dígitos correctos.</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>0.12345</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>0.123456</span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>0.1234567</span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a>0.12345678</span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>0.123456791  &lt;-- Las cosas empiezan a ir mal</span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>0.1234567910</span></code></pre></div>
<p>Hagamos otra demostración. En este código tendremos dos <code>float</code>s que contendrán números que tienen <code>FLT_DIG</code> dígitos decimales significativos<a href="#fn102" class="footnote-ref" id="fnref102" role="doc-noteref"><sup>102</sup></a>. Luego los sumamos, para lo que deberían ser 12 dígitos decimales significativos. Pero eso es más de lo que podemos almacenar en un <code>float</code> y recuperar correctamente como una cadena—así que vemos que cuando lo imprimimos, las cosas empiezan a ir mal después del 7º dígito significativo.</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb220-1"><a href="#cb220-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb220-2"><a href="#cb220-2"></a><span class="pp">#include </span><span class="im">&lt;float.h&gt;</span></span>
<span id="cb220-3"><a href="#cb220-3"></a></span>
<span id="cb220-4"><a href="#cb220-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb220-5"><a href="#cb220-5"></a><span class="op">{</span></span>
<span id="cb220-6"><a href="#cb220-6"></a>    <span class="co">// Ambos números tienen 6 dígitos significativos, por lo que pueden ser</span></span>
<span id="cb220-7"><a href="#cb220-7"></a>    <span class="co">// almacenados con precisión en un float:</span></span>
<span id="cb220-8"><a href="#cb220-8"></a></span>
<span id="cb220-9"><a href="#cb220-9"></a>    <span class="dt">float</span> f <span class="op">=</span> <span class="fl">3.14159</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb220-10"><a href="#cb220-10"></a>    <span class="dt">float</span> g <span class="op">=</span> <span class="dv">0</span><span class="er">.00000265358f</span><span class="op">;</span></span>
<span id="cb220-11"><a href="#cb220-11"></a></span>
<span id="cb220-12"><a href="#cb220-12"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%.5f\n</span><span class="st">&quot;</span><span class="op">,</span> f<span class="op">);</span>   <span class="co">// 3.14159       -- Correcto!</span></span>
<span id="cb220-13"><a href="#cb220-13"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%.11f\n</span><span class="st">&quot;</span><span class="op">,</span> g<span class="op">);</span>  <span class="co">// 0.00000265358 -- Correcto!</span></span>
<span id="cb220-14"><a href="#cb220-14"></a></span>
<span id="cb220-15"><a href="#cb220-15"></a>    <span class="co">// Ahora súmalos</span></span>
<span id="cb220-16"><a href="#cb220-16"></a>    f <span class="op">+=</span> g<span class="op">;</span>                <span class="co">// 3.14159265358 es lo que f _debería_ ser</span></span>
<span id="cb220-17"><a href="#cb220-17"></a></span>
<span id="cb220-18"><a href="#cb220-18"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%.11f\n</span><span class="st">&quot;</span><span class="op">,</span> f<span class="op">);</span>  <span class="co">// 3.14159274101 -- ¡Mal!</span></span>
<span id="cb220-19"><a href="#cb220-19"></a><span class="op">}</span></span></code></pre></div>
<p>(El código anterior tiene una <code>f</code> después de las constantes numéricas—esto indica que la constante es de tipo <code>float</code>, en oposición al valor por defecto de <code>double</code>. Más sobre esto más adelante).</p>
<p>Recuerde que <code>FLT_DIG</code> es el número seguro de dígitos que puede almacenar en un <code>float</code> y recuperar correctamente.</p>
<p>A veces puedes sacar uno o dos más. Pero otras veces sólo recuperarás dígitos <code>FLT_DIG</code>. Lo más seguro: si almacenas cualquier número de dígitos hasta e incluyendo <code>FLT_DIG</code> en un <code>float</code>, seguro que los recuperas correctamente.</p>
<p>Así que ésa es la historia de <code>FLT_DIG</code>. Fin. </p>
<p>…¿O no?</p>
<h3 data-number="14.4.2" id="conversión-a-decimal-y-viceversa"><span class="header-section-number">14.4.2</span> Conversión a decimal y viceversa</h3>
<p>Pero almacenar un número de base 10 en un número de coma flotante y recuperarlo es sólo la mitad de la historia.</p>
<p>Resulta que los números de coma flotante pueden codificar números que requieren más decimales para imprimirse completamente. Lo que ocurre es que tu número decimal grande puede no corresponder a uno de esos números.</p>
<p>Es decir, cuando miras los números de coma flotante de uno a otro, hay un hueco. Si intentas codificar un número decimal en ese hueco, usará el número de coma flotante más cercano. Por eso sólo puedes codificar <code>FLT_DIG</code> para un <code>float</code>.</p>
<p>¿Pero qué pasa con los números de coma flotante que <em>no</em> están en el hueco? ¿Cuántos lugares necesita para imprimirlos con precisión?</p>
<p>Otra forma de formular esta pregunta es, para cualquier número en coma flotante, ¿cuántos dígitos decimales tengo que conservar si quiero volver a convertir el número decimal en un número idéntico en coma flotante? Es decir, ¿cuántos dígitos tengo que imprimir en base 10 para recuperar <strong>todos</strong> los dígitos en base 2 del número original?</p>
<p>A veces pueden ser sólo unos pocos. Pero para estar seguro, querrás convertir a decimal con un cierto número seguro de decimales. Ese número está codificado en las siguientes macros:</p>
<p> </p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>Macro</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>FLT_DECIMAL_DIG</code></td>
<td>Número de dígitos decimales codificados en un <code>float</code>.</td>
</tr>
<tr class="even">
<td><code>DBL_DECIMAL_DIG</code></td>
<td>Número de dígitos decimales codificados en un <code>double</code>.</td>
</tr>
<tr class="odd">
<td><code>LDBL_DECIMAL_DIG</code></td>
<td>Número de dígitos decimales codificados en un <code>long double</code>.</td>
</tr>
<tr class="even">
<td><code>DECIMAL_DIG</code></td>
<td>Igual que la codificación más amplia, <code>LDBL_DECIMAL_DIG</code>.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Veamos un ejemplo en el que <code>DBL_DIG</code> es 15 (por lo que es todo lo que podemos tener en una constante), pero <code>DBL_DECIMAL_DIG</code> es 17 (por lo que tenemos que convertir a 17 números decimales para conservar todos los bits del <code>double</code> original).</p>
<p>Asignemos el número de 15 dígitos significativos <code>0.123456789012345</code> a <code>x</code>, y asignemos el número de 1 dígito significativo <code>0.0000000000000006</code> a <code>y</code>.</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>x es exactamente: 0.12345678901234500    Impreso con 17 decimales</span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>y es exactamente: 0.00000000000000060</span></code></pre></div>
<p>Pero sumémoslos. Esto debería dar <code>0.1234567890123456</code>, pero es más que <code>DBL_DIG</code>, así que podrían pasar cosas raras… veamos:</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>x + y no es del todo correcto: 0.12345678901234559    ¡Debería terminar en 4560!</span></code></pre></div>
<p>Eso nos pasa por imprimir más que <code>DBL_DIG</code>, ¿no? Pero fíjate… ¡ese número de arriba es exactamente representable tal cual!</p>
<p>Si asignamos <code>0.12345678901234559</code> (17 dígitos) a <code>z</code> y lo imprimimos, obtenemos:</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a>z es exactamente: 0.12345678901234559   ¡17 dígitos correctos! ¡Más que DBL_DIG!</span></code></pre></div>
<p>Si hubiéramos truncado <code>z</code> a 15 dígitos, no habría sido el mismo número. Por eso, para conservar todos los bits de un <code>doble</code>, necesitamos <code>DBL_DECIMAL_DIG</code> y no sólo el menor <code>DBL_DIG</code>.</p>
<p></p>
<p>Dicho esto, está claro que cuando estamos jugando con números decimales en general, no es seguro imprimir más de <code>FLT_DIG</code>, <code>DBL_DIG</code>, o <code>LDBL_DIG</code> dígitos para ser sensato en relación con los números originales de base 10 y cualquier matemática posterior.</p>
<p>Pero cuando convierta de <code>float</code> a una representación decimal y <em>de vuelta</em> a <code>float</code>, use definitivamente <code>FLT_DECIMAL_DIG</code> para hacerlo, de forma que todos los bits se conserven exactamente. </p>
<p></p>
<h2 data-number="14.5" id="tipos-numéricos-constantes"><span class="header-section-number">14.5</span> Tipos numéricos constantes</h2>
<p>Cuando escribes un número constante, como <code>1234</code>, tiene un tipo. Pero, ¿de qué tipo es? Veamos cómo decide C qué tipo es la constante, y cómo forzarle a elegir un tipo específico.</p>
<h3 data-number="14.5.1" id="hexadecimal-y-octal"><span class="header-section-number">14.5.1</span> Hexadecimal y octal</h3>
<p>Además de los viejos decimales como los que cocía la abuela, C también admite constantes de diferentes bases.</p>
<p></p>
<p>Si encabeza un número con <code>0x</code>, se lee como un número hexadecimal:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="bn">0x1A2B</span><span class="op">;</span>   <span class="co">// Hexadecimal</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b <span class="op">=</span> <span class="bn">0x1a2b</span><span class="op">;</span>   <span class="co">// Las mayúsculas y minúsculas</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>                  <span class="co">// no importan para los dígitos hexadecimales</span></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%x</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// Imprime un número hexadecimal, «1a2b»</span></span></code></pre></div>
<p></p>
<p> Si precede un número con un <code>0</code>, se lee como un número octal:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="bn">012</span><span class="op">;</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%o\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// Imprime un número octal, «12»</span></span></code></pre></div>
<p>Esto es especialmente problemático para los programadores principiantes que tratan de rellenar los números decimales a la izquierda con «0» para alinear las cosas bien y bonito, cambiando inadvertidamente la base del número:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">11111</span><span class="op">;</span>  <span class="co">// Decimal 11111</span></span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="bn">00111</span><span class="op">;</span>  <span class="co">// Decimal 73 (Octal 111)</span></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> z <span class="op">=</span> <span class="bn">01111</span><span class="op">;</span>  <span class="co">// Decimal 585 (Octal 1111)</span></span></code></pre></div>
<p></p>
<h4 data-number="14.5.1.1" id="nota-sobre-el-binario"><span class="header-section-number">14.5.1.1</span> Nota sobre el binario</h4>
<p></p>
<p>Una extensión no oficial<a href="#fn103" class="footnote-ref" id="fnref103" role="doc-noteref"><sup>103</sup></a> en muchos compiladores de C permite representar un número binario con un prefijo <code>0b</code>:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="bn">0b101010</span><span class="op">;</span>    <span class="co">// Número binario 101010</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>   <span class="co">// Imprime 42 en decimal</span></span></code></pre></div>
<p>No existe un especificador de formato <code>printf()</code> para imprimir un número binario. Hay que hacerlo carácter a carácter con operadores bit a bit.</p>
<p></p>
<h3 data-number="14.5.2" id="constantes-enteras"><span class="header-section-number">14.5.2</span> Constantes enteras</h3>
<p></p>
<p>Puedes forzar que un entero constante sea de un tipo determinado añadiéndole un sufijo que indique el tipo.</p>
<p>Haremos algunas asignaciones para demostrarlo, pero la mayoría de los desarrolladores omiten los sufijos a menos que sea necesario para ser precisos. El compilador es bastante bueno asegurándose de que los tipos son compatibles.</p>
<p> </p>
<div class="sourceCode" id="cb228"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>           x <span class="op">=</span> <span class="dv">1234</span><span class="op">;</span></span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">int</span>      x <span class="op">=</span> <span class="dv">1234</span><span class="bu">L</span><span class="op">;</span></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1234</span><span class="bu">LL</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">int</span>           x <span class="op">=</span> <span class="dv">1234</span><span class="bu">U</span><span class="op">;</span></span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>      x <span class="op">=</span> <span class="dv">1234</span><span class="bu">UL</span><span class="op">;</span></span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1234</span><span class="bu">ULL</span><span class="op">;</span></span></code></pre></div>
<p>El sufijo puede ser mayúscula o minúscula. Y la <code>U</code> y la <code>L</code> o <code>LL</code> pueden aparecer indistintamente en primer lugar.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: left;">Sufijo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;">Sin sufijo</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>long int</code></td>
<td style="text-align: left;"><code>L</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long long int</code></td>
<td style="text-align: left;"><code>LL</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned int</code></td>
<td style="text-align: left;"><code>U</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>unsigned long int</code></td>
<td style="text-align: left;"><code>UL</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unsigned long long int</code></td>
<td style="text-align: left;"><code>ULL</code></td>
</tr>
</tbody>
</table>
<p>En la tabla mencioné que «sin sufijo» significa <code>int</code>… pero en realidad es más complejo que eso.</p>
<p>Entonces, ¿qué sucede cuando usted tiene un número sin sufijo como:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">1234</span><span class="op">;</span></span></code></pre></div>
<p>¿Qué tipo es?</p>
<p>Lo que C hace generalmente es elegir el tipo más pequeño a partir de <code>int</code> que pueda contener el valor.</p>
<p>Pero específicamente, eso depende de la base del número (decimal, hexadecimal, o octal).</p>
<p>La especificación tiene una gran tabla que indica qué tipo se utiliza para cada valor no fijo. De hecho, voy a copiarla íntegramente aquí.</p>
<p>C11 §6.4.4.1¶5 dice: «El tipo de una constante entera es el primero de la lista correspondiente en la que se puede representar su valor».</p>
<p>Y luego pasa a mostrar esta tabla:</p>
<table style="width:94%;">
<colgroup>
<col style="width: 23%" />
<col style="width: 34%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Sufijo</th>
<th style="text-align: left;">Constante decimal</th>
<th style="text-align: left;">Constante/ Octal o Hexadecimal</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Sin sufijo</td>
<td style="text-align: left;"><code>int</code><br />
<code>long int</code></td>
<td style="text-align: left;"><code>int</code><br />
<code>unsigned int</code><br />
<code>long int</code><br />
<code>unsigned long int</code><br />
<code>long long int</code><br />
<code>unsigned long long int</code><br />
</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>u</code> o <code>U</code></td>
<td style="text-align: left;"><code>unsigned int</code><br />
<code>unsigned long int</code><br />
<code>unsigned long long int</code></td>
<td style="text-align: left;"><code>unsigned int</code><br />
<code>unsigned long int</code><br />
<code>unsigned long long int</code><br />
</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>l</code> o <code>L</code></td>
<td style="text-align: left;"><code>long int</code><br />
<code>long long int</code></td>
<td style="text-align: left;"><code>long int</code><br />
<code>unsigned long int</code><br />
<code>long long int</code><br />
<code>unsigned long long int</code><br />
</td>
</tr>
<tr class="even">
<td style="text-align: left;">Ambos <code>u</code> o <code>U</code><br />
y <code>l</code> o <code>L</code></td>
<td style="text-align: left;"><code>unsigned long int</code><br />
<code>unsigned long long int</code></td>
<td style="text-align: left;"><code>unsigned long int</code><br />
<code>unsigned long long int</code><br />
</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ll</code> o <code>LL</code></td>
<td style="text-align: left;"><code>long long int</code></td>
<td style="text-align: left;"><code>long long int</code><br />
<code>unsigned long long int</code><br />
</td>
</tr>
<tr class="even">
<td style="text-align: left;">Ambos <code>u</code> o <code>U</code><br />
y <code>ll</code> o <code>LL</code></td>
<td style="text-align: left;"><code>unsigned long long int</code></td>
<td style="text-align: left;"><code>unsigned long long int</code></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Lo que esto quiere decir es que, por ejemplo, si especificas un número como <code>123456789U</code>, primero C verá si puede ser <code>unsigned int</code>. Si no cabe ahí, probará con <code>unsigned long int</code>. Y luego <code>unsigned long long int</code>. Usará el tipo más pequeño que pueda contener el número. </p>
<p></p>
<h3 data-number="14.5.3" id="constantes-en-coma-flotante"><span class="header-section-number">14.5.3</span> Constantes en coma flotante</h3>
<p></p>
<p>Uno pensaría que una constante en coma flotante como <code>1.23</code> tendría un tipo por defecto <code>float</code>, ¿verdad?</p>
<p>¡Sorpresa! ¡Resulta que los números de coma flotante sin sufijo son del tipo <code>double</code>! ¡Feliz cumpleaños atrasado!</p>
<p> </p>
<p>Puede forzar que sea de tipo <code>float</code> añadiendo una <code>f</code> (o <code>F</code>—no distingue mayúsculas de minúsculas). Puedes forzar que sea del tipo <code>long double</code> añadiendo <code>l</code> (o <code>L</code>).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo</th>
<th style="text-align: left;">Sufijo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>float</code></td>
<td style="text-align: left;"><code>F</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>double</code></td>
<td style="text-align: left;">None</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long double</code></td>
<td style="text-align: left;"><code>L</code></td>
</tr>
</tbody>
</table>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x       <span class="op">=</span> <span class="fl">3.14</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x      <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">double</span> x <span class="op">=</span> <span class="fl">3.14</span><span class="bu">L</span><span class="op">;</span></span></code></pre></div>
<p> </p>
<p>Todo este tiempo, sin embargo, hemos estado haciendo esto, ¿verdad?</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span></code></pre></div>
<p>¿No es la izquierda un <code>float</code> y la derecha un <code>double</code>? Sí. Pero C es bastante bueno con las conversiones numéricas automáticas, así que es más común tener una constante de coma flotante fijada que no fijada. Más adelante hablaremos de ello.</p>
<p></p>
<h4 data-number="14.5.3.1" id="notación-científica"><span class="header-section-number">14.5.3.1</span> Notación científica</h4>
<p></p>
<p>¿Recuerdas que antes hablamos de cómo se puede representar un número en coma flotante mediante un significando, una base y un exponente?</p>
<p>Bueno, hay una forma común de escribir un número de este tipo, que se muestra aquí seguido de su equivalente más reconocible, que es lo que obtienes cuando ejecutas las matemáticas:</p>
<p><span class="math inline">\(1.2345\times10^3 = 1234.5\)</span></p>
<p>Escribir números de la forma <span class="math inline">\(s\times b^e\)</span> se denomina <a href="https://en.wikipedia.org/wiki/%20Scientific_notation"><em>notación_científica</em></a><a href="#fn104" class="footnote-ref" id="fnref104" role="doc-noteref"><sup>104</sup></a>. En C, se escriben utilizando la «notación E», por lo que son equivalentes:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Notación científica</th>
<th style="text-align: left;">Notación E</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(1.2345\times10^{-3}=0.0012345\)</span></td>
<td style="text-align: left;"><code>1.2345e-3</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(1.2345\times10^8=123450000\)</span></td>
<td style="text-align: left;"><code>1.2345e+8</code></td>
</tr>
</tbody>
</table>
<p>Puede imprimir un número en esta notación con <code>%e</code>:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%e\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="fl">123456.0</span><span class="op">);</span>  <span class="co">// Impresiones 1,234560e+05</span></span></code></pre></div>
<p>Un par de datos curiosos sobre la notación científica:</p>
<ul>
<li><p>No tienes que escribirlos con un solo dígito antes del punto decimal. Cualquier número de cifras puede ir delante.</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x <span class="op">=</span> <span class="fl">123.456e+3</span><span class="op">;</span>  <span class="co">// 123456</span></span></code></pre></div></li>
</ul>
<p>Sin embargo, al imprimirlo, cambiará el exponente para que haya sólo un dígito delante del punto decimal.</p>
<ul>
<li><p>El más se puede dejar fuera del exponente, ya que es por defecto, pero esto es poco común en la práctica por lo que he visto.</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="fl">1.2345e10</span> <span class="op">==</span> <span class="fl">1.2345e+10</span></span></code></pre></div></li>
<li><p>Puede aplicar los sufijos <code>F</code> o <code>L</code> a las constantes de anotación E:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="fl">1.2345e10</span><span class="bu">F</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a><span class="fl">1.2345e10</span><span class="bu">L</span></span></code></pre></div></li>
</ul>
<p></p>
<h4 data-number="14.5.3.2" id="constantes-hexadecimales-en-coma-flotante"><span class="header-section-number">14.5.3.2</span> Constantes hexadecimales en coma flotante</h4>
<p></p>
<p>Pero espera, ¡todavía hay que flotar más!</p>
<p>Resulta que también existen constantes hexadecimales de coma flotante.</p>
<p>Funcionan de forma similar a los números decimales en coma flotante, pero empiezan por «0x», igual que los números enteros.</p>
<p>El truco es que <em>debes</em> especificar un exponente, y este exponente produce una potencia de 2. Es decir: <span class="math inline">\(2^x\)</span>.</p>
<p>Y entonces se usa una <code>p</code> en lugar de una <code>e</code> al escribir el número:</p>
<p>Así que <code>0xa.1p3</code> es <span class="math inline">\(10.0625\times2^3 == 80.5\)</span>.</p>
<p>Cuando usamos constantes hexadecimales en coma flotante, Podemos imprimir notación científica hexadecimal con <code>%a</code>:</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x <span class="op">=</span> <span class="fl">0xa.1p3</span><span class="op">;</span></span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%a\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 0x1.42p+6</span></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 80.500000</span></span></code></pre></div>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="15" id="tipos-iii-conversiones"><span class="header-section-number">15</span> Tipos III: Conversiones</h1>
<p></p>
<p>En este capítulo, queremos hablar de la conversión de un tipo a otro. C tiene una variedad de formas de hacer esto, y algunas pueden ser un poco diferentes a las que estás acostumbrado en otros lenguajes.</p>
<p>Antes de hablar de cómo hacer que las conversiones ocurran, hablemos de cómo funcionan cuando <em>ocurren</em>.</p>
<h2 data-number="15.1" id="conversiones-de-cadenas"><span class="header-section-number">15.1</span> Conversiones de cadenas</h2>
<p></p>
<p>A diferencia de muchos lenguajes, C no realiza las conversiones de cadena a número (y viceversa) de una forma tan ágil como lo hace con las conversiones numéricas.</p>
<p>Para ello, tendremos que llamar a funciones que hagan el trabajo sucio.</p>
<h3 data-number="15.1.1" id="valor-numérico-a-cadena"><span class="header-section-number">15.1.1</span> Valor numérico a cadena</h3>
<p>Cuando queremos convertir un número en una cadena, podemos utilizar <code>sprintf()</code> (se pronuncia <em>SPRINT-f</em>) o <code>snprintf()</code> (<em>s-n-print-f</em>)<a href="#fn105" class="footnote-ref" id="fnref105" role="doc-noteref"><sup>105</sup></a>.</p>
<p>Básicamente funcionan como <code>printf()</code>, excepto que dan salida a una cadena en su lugar, y puedes imprimir esa cadena más tarde, o lo que sea.</p>
<p>Por ejemplo, convirtiendo parte del valor π en una cadena:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb237-1"><a href="#cb237-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb237-2"><a href="#cb237-2"></a></span>
<span id="cb237-3"><a href="#cb237-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb237-4"><a href="#cb237-4"></a><span class="op">{</span></span>
<span id="cb237-5"><a href="#cb237-5"></a>    <span class="dt">char</span> s<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb237-6"><a href="#cb237-6"></a>    <span class="dt">float</span> f <span class="op">=</span> <span class="fl">3.14159</span><span class="op">;</span></span>
<span id="cb237-7"><a href="#cb237-7"></a></span>
<span id="cb237-8"><a href="#cb237-8"></a>    <span class="co">// Convertir «f» en cadena, almacenando en «s», escribiendo como máximo 10 caracteres</span></span>
<span id="cb237-9"><a href="#cb237-9"></a>    <span class="co">// incluido el terminador NUL</span></span>
<span id="cb237-10"><a href="#cb237-10"></a></span>
<span id="cb237-11"><a href="#cb237-11"></a>    snprintf<span class="op">(</span>s<span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="st">&quot;</span><span class="sc">%f</span><span class="st">&quot;</span><span class="op">,</span> f<span class="op">);</span></span>
<span id="cb237-12"><a href="#cb237-12"></a></span>
<span id="cb237-13"><a href="#cb237-13"></a>    printf<span class="op">(</span><span class="st">&quot;String value: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>  <span class="co">// Valor de la cadena: 3.141590</span></span>
<span id="cb237-14"><a href="#cb237-14"></a><span class="op">}</span></span></code></pre></div>
<p>Así que puedes usar <code>%d</code> o <code>%u</code> como estás acostumbrado para los enteros.</p>
<h3 data-number="15.1.2" id="cadena-a-valor-numérico"><span class="header-section-number">15.1.2</span> Cadena a valor numérico</h3>
<p>Hay un par de familias de funciones para hacer esto en C. Las llamaremos la familia <code>atoi</code> (pronunciado <em>a-to-i</em>) y la familia <code>strtol</code> (<em>string-to-long</em>).</p>
<p>Para la conversión básica de una cadena a un número, pruebe las funciones <code>atoi</code> de <code>&lt;stdlib.h&gt;</code>. Éstas tienen malas características de gestión de errores (incluyendo un comportamiento indefinido si pasas una cadena incorrecta), así que úsalas con cuidado.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Función</th>
<th style="text-align: left;">Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>atoi</code></td>
<td style="text-align: left;">Cadena a <code>int</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>atof</code></td>
<td style="text-align: left;">Cadena a <code>float</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>atol</code></td>
<td style="text-align: left;">Cadena a <code>long int</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>atoll</code></td>
<td style="text-align: left;">Cadena a <code>long long int</code></td>
</tr>
</tbody>
</table>
<p>Aunque la especificación no lo menciona, la <code>a</code> al principio de la función significa <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a><a href="#fn106" class="footnote-ref" id="fnref106" role="doc-noteref"><sup>106</sup></a>, así que en realidad <code>atoi()</code> es «ASCII a entero» (Ascii To Integer, pero decirlo hoy en día es un poco ASCII-céntrico.</p>
<p>He aquí un ejemplo de conversión de una cadena a un <code>float</code>:</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb238-1"><a href="#cb238-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb238-2"><a href="#cb238-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb238-3"><a href="#cb238-3"></a></span>
<span id="cb238-4"><a href="#cb238-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb238-5"><a href="#cb238-5"></a><span class="op">{</span></span>
<span id="cb238-6"><a href="#cb238-6"></a>    <span class="dt">char</span> <span class="op">*</span>pi <span class="op">=</span> <span class="st">&quot;3.14159&quot;</span><span class="op">;</span></span>
<span id="cb238-7"><a href="#cb238-7"></a>    <span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb238-8"><a href="#cb238-8"></a></span>
<span id="cb238-9"><a href="#cb238-9"></a>    f <span class="op">=</span> atof<span class="op">(</span>pi<span class="op">);</span></span>
<span id="cb238-10"><a href="#cb238-10"></a></span>
<span id="cb238-11"><a href="#cb238-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> f<span class="op">);</span></span>
<span id="cb238-12"><a href="#cb238-12"></a><span class="op">}</span></span></code></pre></div>
<p>Pero, como he dicho, obtenemos un comportamiento indefinido de cosas raras como esta:</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> atoi<span class="op">(</span><span class="st">&quot;what&quot;</span><span class="op">);</span>  <span class="co">// «Qué» no es un número que haya oído nunca</span></span></code></pre></div>
<p>(Cuando ejecuto eso, obtengo <code>0</code> de vuelta, pero realmente no deberías contar con eso de ninguna manera. Podrías obtener algo completamente diferente).</p>
<p>Para obtener mejores características de manejo de errores, echemos un vistazo a todas esas funciones <code>strtol</code>, también en <code>&lt;stdlib.h&gt;</code>. No sólo eso, ¡también convierten a más tipos y más bases!</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Función</th>
<th style="text-align: left;">Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>strtol</code></td>
<td style="text-align: left;">Cadena a <code>long int</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>strtoll</code></td>
<td style="text-align: left;">Cadena a <code>long long int</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>strtoul</code></td>
<td style="text-align: left;">Cadena a <code>unsigned long int</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>strtoull</code></td>
<td style="text-align: left;">Cadena a <code>unsigned long long int</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>strtof</code></td>
<td style="text-align: left;">Cadena a <code>float</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>strtod</code></td>
<td style="text-align: left;">Cadena a <code>double</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>strtold</code></td>
<td style="text-align: left;">Cadena a <code>long double</code></td>
</tr>
</tbody>
</table>
<p>Todas estas funciones siguen un patrón de uso similar y constituyen la primera experiencia de mucha gente con punteros a punteros. Pero no te preocupes, es más fácil de lo que parece.</p>
<p>Hagamos un ejemplo en el que convertimos una cadena a un <code>unsigned long</code>, descartando la información de error (es decir, la información sobre caracteres erróneos en la cadena de entrada):</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb240-1"><a href="#cb240-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb240-2"><a href="#cb240-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb240-3"><a href="#cb240-3"></a></span>
<span id="cb240-4"><a href="#cb240-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb240-5"><a href="#cb240-5"></a><span class="op">{</span></span>
<span id="cb240-6"><a href="#cb240-6"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;3490&quot;</span><span class="op">;</span></span>
<span id="cb240-7"><a href="#cb240-7"></a></span>
<span id="cb240-8"><a href="#cb240-8"></a>    <span class="co">// Convierte la cadena s, a un número en base 10, a un unsigned long int.</span></span>
<span id="cb240-9"><a href="#cb240-9"></a>    <span class="co">// NULL significa que no nos interesa conocer ninguna información de error.</span></span>
<span id="cb240-10"><a href="#cb240-10"></a></span>
<span id="cb240-11"><a href="#cb240-11"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> x <span class="op">=</span> strtoul<span class="op">(</span>s<span class="op">,</span> NULL<span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb240-12"><a href="#cb240-12"></a></span>
<span id="cb240-13"><a href="#cb240-13"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%lu\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 3490</span></span>
<span id="cb240-14"><a href="#cb240-14"></a><span class="op">}</span></span></code></pre></div>
<p>Fíjate en un par de cosas. Aunque no nos dignamos a capturar ninguna información sobre caracteres de error en la cadena, <code>strtoul()</code> no nos dará un comportamiento indefinido; simplemente devolverá <code>0</code>.</p>
<p>Además, especificamos que se trataba de un número decimal (base 10).</p>
<p>¿Significa esto que podemos convertir números de bases diferentes? Por supuesto. ¡Hagámoslo en binario!</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb241-1"><a href="#cb241-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb241-2"><a href="#cb241-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb241-3"><a href="#cb241-3"></a></span>
<span id="cb241-4"><a href="#cb241-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb241-5"><a href="#cb241-5"></a><span class="op">{</span></span>
<span id="cb241-6"><a href="#cb241-6"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;101010&quot;</span><span class="op">;</span>  <span class="co">// ¿Qué significa este número?</span></span>
<span id="cb241-7"><a href="#cb241-7"></a></span>
<span id="cb241-8"><a href="#cb241-8"></a>    <span class="co">// Convierte la cadena s, un número en base 2, a un unsigned long int.</span></span>
<span id="cb241-9"><a href="#cb241-9"></a></span>
<span id="cb241-10"><a href="#cb241-10"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> x <span class="op">=</span> strtoul<span class="op">(</span>s<span class="op">,</span> NULL<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb241-11"><a href="#cb241-11"></a></span>
<span id="cb241-12"><a href="#cb241-12"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%lu\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 42</span></span>
<span id="cb241-13"><a href="#cb241-13"></a><span class="op">}</span></span></code></pre></div>
<p>Vale, eso es muy divertido, pero ¿qué es eso de «NULL»? ¿Para qué sirve?</p>
<p>Nos ayuda a averiguar si se ha producido un error al procesar la cadena. Es un puntero a un puntero a un <code>char</code>, que suena espeluznante, pero no lo es una vez que te haces a la idea.</p>
<p>Hagamos un ejemplo en el que introducimos un número deliberadamente malo, y veremos cómo <code>strtol()</code> nos permite saber dónde está el primer dígito inválido.</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb242-1"><a href="#cb242-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb242-2"><a href="#cb242-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb242-3"><a href="#cb242-3"></a></span>
<span id="cb242-4"><a href="#cb242-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb242-5"><a href="#cb242-5"></a><span class="op">{</span></span>
<span id="cb242-6"><a href="#cb242-6"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;34x90&quot;</span><span class="op">;</span>  <span class="co">// ¡«x» no es un dígito válido en base 10!</span></span>
<span id="cb242-7"><a href="#cb242-7"></a>    <span class="dt">char</span> <span class="op">*</span>badchar<span class="op">;</span></span>
<span id="cb242-8"><a href="#cb242-8"></a></span>
<span id="cb242-9"><a href="#cb242-9"></a>    <span class="co">// Convierte la cadena s, un número en base 10, a un unsigned long int.</span></span>
<span id="cb242-10"><a href="#cb242-10"></a></span>
<span id="cb242-11"><a href="#cb242-11"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> x <span class="op">=</span> strtoul<span class="op">(</span>s<span class="op">,</span> <span class="op">&amp;</span>badchar<span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb242-12"><a href="#cb242-12"></a></span>
<span id="cb242-13"><a href="#cb242-13"></a>    <span class="co">// Intenta convertir tanto como sea posible, así que llega hasta aquí:</span></span>
<span id="cb242-14"><a href="#cb242-14"></a></span>
<span id="cb242-15"><a href="#cb242-15"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%lu\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 34</span></span>
<span id="cb242-16"><a href="#cb242-16"></a></span>
<span id="cb242-17"><a href="#cb242-17"></a>    <span class="co">// Pero podemos ver el carácter malo porque badchar</span></span>
<span id="cb242-18"><a href="#cb242-18"></a>    <span class="co">// lo señala.</span></span>
<span id="cb242-19"><a href="#cb242-19"></a></span>
<span id="cb242-20"><a href="#cb242-20"></a>    printf<span class="op">(</span><span class="st">&quot;Carácter no válido: </span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>badchar<span class="op">);</span>  <span class="co">// &quot;x&quot;</span></span>
<span id="cb242-21"><a href="#cb242-21"></a><span class="op">}</span></span></code></pre></div>
<p>Así que tenemos a <code>strtoul()</code> modificando lo que <code>badchar</code> señala para mostrarnos dónde han ido mal las cosas<a href="#fn107" class="footnote-ref" id="fnref107" role="doc-noteref"><sup>107</sup></a>.</p>
<p>Pero, ¿y si no pasa nada? En ese caso, <code>badchar</code> apuntará al terminador <code>NUL</code> al final de la cadena. Así que podemos comprobarlo:</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb243-1"><a href="#cb243-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb243-2"><a href="#cb243-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb243-3"><a href="#cb243-3"></a></span>
<span id="cb243-4"><a href="#cb243-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb243-5"><a href="#cb243-5"></a><span class="op">{</span></span>
<span id="cb243-6"><a href="#cb243-6"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;3490&quot;</span><span class="op">;</span>  <span class="co">// ¡«x» no es un dígito válido en base 10!</span></span>
<span id="cb243-7"><a href="#cb243-7"></a>    <span class="dt">char</span> <span class="op">*</span>badchar<span class="op">;</span></span>
<span id="cb243-8"><a href="#cb243-8"></a></span>
<span id="cb243-9"><a href="#cb243-9"></a>    <span class="co">// Convierte la cadena s, un número en base 10, a un unsigned long int.</span></span>
<span id="cb243-10"><a href="#cb243-10"></a></span>
<span id="cb243-11"><a href="#cb243-11"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> x <span class="op">=</span> strtoul<span class="op">(</span>s<span class="op">,</span> <span class="op">&amp;</span>badchar<span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb243-12"><a href="#cb243-12"></a></span>
<span id="cb243-13"><a href="#cb243-13"></a>    <span class="co">// Comprueba si todo ha ido bien</span></span>
<span id="cb243-14"><a href="#cb243-14"></a></span>
<span id="cb243-15"><a href="#cb243-15"></a>    <span class="cf">if</span> <span class="op">(*</span>badchar <span class="op">==</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb243-16"><a href="#cb243-16"></a>        printf<span class="op">(</span><span class="st">&quot;Éxito! </span><span class="sc">%lu\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb243-17"><a href="#cb243-17"></a>    <span class="op">}</span> <span class="cf">else</span>  <span class="op">{</span></span>
<span id="cb243-18"><a href="#cb243-18"></a>        printf<span class="op">(</span><span class="st">&quot;Conversión parcial: </span><span class="sc">%lu\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb243-19"><a href="#cb243-19"></a>        printf<span class="op">(</span><span class="st">&quot;Carácter no válido: </span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>badchar<span class="op">);</span></span>
<span id="cb243-20"><a href="#cb243-20"></a>    <span class="op">}</span></span>
<span id="cb243-21"><a href="#cb243-21"></a><span class="op">}</span></span></code></pre></div>
<p>Ahí lo tienes. Las funciones estilo <code>atoi()</code> son buenas en un apuro controlado, pero las funciones estilo <code>strtol()</code> le dan mucho más control sobre el manejo de errores y la base de la entrada.</p>
<p></p>
<h2 data-number="15.2" id="conversiones-char"><span class="header-section-number">15.2</span> Conversiones <code>char</code></h2>
<p></p>
<p>¿Qué pasa si tienes un solo carácter con un dígito, como <code>'5'</code>? ¿Es lo mismo que el valor «5»?</p>
<p>Probemos a ver.</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="ch">&#39;5&#39;</span><span class="op">);</span></span></code></pre></div>
<p>En mi sistema UTF-8, esto se imprime:</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>5 53</span></code></pre></div>
<p>Así que… no. ¿Y 53? ¿Qué es eso? Es el punto de código UTF-8 (y ASCII) para el símbolo de carácter <code>'5'</code><a href="#fn108" class="footnote-ref" id="fnref108" role="doc-noteref"><sup>108</sup></a>.</p>
<p>Entonces, ¿cómo convertimos el carácter <code>'5'</code> (que aparentemente tiene valor 53) en el valor <code>5</code>?</p>
<p>Con un ingenioso truco, ¡así es cómo!</p>
<p>El estándar C garantiza que estos caracteres tendrán puntos de código que están en secuencia y en este orden:</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>0  1  2  3  4  5  6  7  8  9</span></code></pre></div>
<p>Reflexiona un segundo… ¿cómo podemos utilizar eso? Spoilers por delante…</p>
<p>Echemos un vistazo a los caracteres y sus puntos de código en UTF-8:</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>0  1  2  3  4  5  6  7  8  9</span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a>48 49 50 51 52 53 54 55 56 57</span></code></pre></div>
<p>Ahí ves que <code>'5'</code> es <code>53</code>, tal como nos salía. Y «0» es «48».</p>
<p>Así que podemos restar «0» de cualquier dígito para obtener su valor numérico:</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c <span class="op">=</span> <span class="ch">&#39;6&#39;</span><span class="op">;</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> c<span class="op">;</span>  <span class="co">// x tiene el valor 54, el punto de código para &#39;6&#39;</span></span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> c <span class="op">-</span> <span class="ch">&#39;0&#39;</span><span class="op">;</span> <span class="co">// y tiene valor 6, tal como queremos</span></span></code></pre></div>
<p>Y también podemos convertir en el otro sentido, simplemente añadiendo el valor.</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c <span class="op">=</span> x <span class="op">+</span> <span class="ch">&#39;0&#39;</span><span class="op">;</span>  <span class="co">// c tiene valor 54</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">);</span>  <span class="co">// Imprime 54</span></span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">);</span>  <span class="co">// imprime 6 con %c</span></span></code></pre></div>
<p>Puede que pienses que es una forma rara de hacer esta conversión, y para los estándares de hoy en día, ciertamente lo es. Pero en los viejos tiempos, cuando los ordenadores se hacían literalmente de madera, éste era el método para hacer esta conversión. Y no estaba roto, así que C nunca lo arregló.</p>
<p></p>
<h2 data-number="15.3" id="conversiones-numéricas"><span class="header-section-number">15.3</span> Conversiones numéricas</h2>
<p></p>
<h3 data-number="15.3.1" id="booleano"><span class="header-section-number">15.3.1</span> Booleano</h3>
<p></p>
<p>Si convierte un cero en <code>bool</code>, el resultado es <code>0</code>. En caso contrario es <code>1</code>.</p>
<h3 data-number="15.3.2" id="conversión-de-números-enteros-en-números-enteros"><span class="header-section-number">15.3.2</span> Conversión de números enteros en números enteros</h3>
<p></p>
<p>Si un tipo entero se convierte a sin signo y no cabe en él, el resultado sin signo se envuelve al estilo cuentakilómetros hasta que quepa en el sin signo<a href="#fn109" class="footnote-ref" id="fnref109" role="doc-noteref"><sup>109</sup></a>.</p>
<p>Si un tipo entero se convierte a un número con signo y no cabe, ¡el resultado está definido por la implementación! Ocurrirá algo documentado, pero tendrás que buscarlo<a href="#fn110" class="footnote-ref" id="fnref110" role="doc-noteref"><sup>110</sup></a></p>
<h3 data-number="15.3.3" id="conversiones-de-enteros-y-coma-flotante"><span class="header-section-number">15.3.3</span> Conversiones de enteros y coma flotante</h3>
<p></p>
<p>Si un tipo de coma flotante se convierte a un tipo entero, la parte fraccionaria se descarta con prejuicio<a href="#fn111" class="footnote-ref" id="fnref111" role="doc-noteref"><sup>111</sup></a>.</p>
<p>Pero–y aquí está el truco—si el número es demasiado grande para caber en el entero, se obtiene un comportamiento indefinido. Así que no lo hagas.</p>
<p>Pasando de entero o punto flotante a punto flotante, C hace el mejor esfuerzo para encontrar el número de punto flotante más cercano al entero que pueda.</p>
<p>De nuevo, sin embargo, si el valor original no puede ser representado, es un comportamiento indefinido.</p>
<p> </p>
<h2 data-number="15.4" id="conversiones-implícitas"><span class="header-section-number">15.4</span> Conversiones implícitas</h2>
<p></p>
<p>Se trata de conversiones que el compilador realiza automáticamente cuando se mezclan y combinan tipos.</p>
<h3 data-number="15.4.1" id="integer-promotions"><span class="header-section-number">15.4.1</span> Promociones de enteros</h3>
<p>En varios sitios, si un <code>int</code> puede usarse para representar un valor de <code>chart</code> o <code>short</code> (con o sin signo), ese valor es <em>promovido</em> a <code>int</code>. Si no cabe en un <code>int</code>, se promociona a <code>unsigned int</code>.</p>
<p>Así es como podemos hacer algo como esto:</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span></span></code></pre></div>
<p>En ese caso, <code>x</code> e <code>y</code> son promovidos a <code>int</code> por C antes de que se realice la operación matemática.</p>
<p>Las promociones a enteros tienen lugar durante las conversiones aritméticas habituales, con funciones variádicas<a href="#fn112" class="footnote-ref" id="fnref112" role="doc-noteref"><sup>112</sup></a>, operadores unarios <code>+</code> y <code>-</code>, o al pasar valores a funciones sin prototipos<a href="#fn113" class="footnote-ref" id="fnref113" role="doc-noteref"><sup>113</sup></a>.</p>
<h3 data-number="15.4.2" id="usual-arithmetic-conversions"><span class="header-section-number">15.4.2</span> Las conversiones aritméticas habituales</h3>
<p>Se trata de conversiones automáticas que C realiza en torno a las operaciones numéricas que se le solicitan. (por cierto, así es como se llaman, en C11 §6.3.1.8.) Tenga en cuenta que en esta sección sólo hablaremos de tipos numéricos; las cadenas vendrán más adelante.</p>
<p>Estas conversiones responden a preguntas sobre lo que ocurre cuando se mezclan tipos, como en este caso:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">3</span> <span class="op">+</span> <span class="fl">1.2</span><span class="op">;</span> <span class="co">// Mezcla int y double</span></span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// 4.2 se convierte en int</span></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// 4 se almacena en x</span></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> y <span class="op">=</span> <span class="dv">12</span> <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Mezcla de float e int</span></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// 24 se convierte a float</span></span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// 24.0 se almacena en y</span></span></code></pre></div>
<p>¿Se convierten en <code>int</code>s? ¿Se convierten en <code>float</code>s? ¿Cómo funciona?</p>
<p>He aquí los pasos, parafraseados para facilitar su comprensión.</p>
<ol type="1">
<li><p>Si una cosa en la expresión es de tipo flotante, convierte las otras cosas a ese tipo flotante.</p></li>
<li><p>De lo contrario, si ambos tipos son enteros, realice las promociones de enteros en cada uno, luego haga los tipos de operandos tan grandes como sea necesario para mantener el valor más grande común. A veces esto implica cambiar con signo a sin signo.</p></li>
</ol>
<p>Si quiere conocer los detalles, consulte C11 §6.3.1.8. Pero probablemente no lo necesites.</p>
<p>En general, recuerde que los tipos int se convierten en tipos float si hay un tipo de coma flotante en cualquier lugar, y el compilador hace un esfuerzo para asegurarse de que los tipos enteros mixtos no se desborden.</p>
<p>Finalmente, si conviertes de un tipo de coma flotante a otro, el compilador intentará hacer una conversión exacta. Si no puede, hará la mejor aproximación posible. Si el número es demasiado grande para caber en el tipo al que se está convirtiendo, <em>boom</em>: ¡comportamiento indefinido!</p>
<h3 data-number="15.4.3" id="void"><span class="header-section-number">15.4.3</span> <code>void*</code></h3>
<p>El tipo <code>void*</code> es interesante porque puede convertirse desde o hacia cualquier tipo de puntero.</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span> <span class="co">// &amp;x es de tipo int*, pero lo almacenamos en un void*</span></span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>q <span class="op">=</span> p<span class="op">;</span> <span class="co">// p es void*, pero lo almacenamos en un int*</span></span></code></pre></div>
<p></p>
<h2 data-number="15.5" id="conversiones-explícitas"><span class="header-section-number">15.5</span> Conversiones explícitas</h2>
<p></p>
<p>Se trata de conversiones de tipo a tipo que debes solicitar; el compilador no lo hará por ti.</p>
<p>Puedes convertir de un tipo a otro asignando un tipo a otro con un <code>=</code>.</p>
<p>También puedes convertir explícitamente con un <em>cast</em>.</p>
<p></p>
<h3 data-number="15.5.1" id="casting"><span class="header-section-number">15.5.1</span> Casting</h3>
<p></p>
<p>Puedes cambiar explícitamente el tipo de una expresión poniendo un nuevo tipo entre paréntesis delante de ella. Algunos desarrolladores de C fruncen el ceño ante esta práctica a menos que sea absolutamente necesario, pero es probable que te encuentres con algún código C que contenga estos paréntesis.</p>
<p>Hagamos un ejemplo en el que queremos convertir un <code>int</code> en un <code>long</code> para poder almacenarlo en un <code>long</code>.</p>
<p>Nota: este ejemplo es artificial y la conversión en este caso es completamente innecesaria porque la expresión <code>x + 12</code> se cambiaría automáticamente a <code>long int</code> para coincidir con el tipo más amplio de <code>y</code>.</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">int</span> y <span class="op">=</span> <span class="op">(</span><span class="dt">long</span> <span class="dt">int</span><span class="op">)</span>x <span class="op">+</span> <span class="dv">12</span><span class="op">;</span></span></code></pre></div>
<p>En ese ejemplo, aunque <code>x</code> era antes de tipo <code>int</code>, la expresión <code>(long int)x</code> es de tipo <code>long int</code>. Decimos: «Castamos <code>x</code> a <code>long int</code>».</p>
<p>Más comúnmente, se puede ver una conversión para convertir un <code>void*</code> a un tipo de puntero específico para que pueda ser dereferenciado.</p>
<p>Una llamada de retorno de la función incorporada <code>qsort()</code> puede mostrar este comportamiento ya que tiene <code>void*</code>s pasados a ella:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> compar<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>elem1<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>elem2<span class="op">)</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*((</span><span class="dt">const</span> <span class="dt">int</span><span class="op">*)</span>elem2<span class="op">)</span> <span class="op">&gt;</span> <span class="op">*((</span><span class="dt">const</span> <span class="dt">int</span><span class="op">*)</span>elem1<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*((</span><span class="dt">const</span> <span class="dt">int</span><span class="op">*)</span>elem2<span class="op">)</span> <span class="op">&lt;</span> <span class="op">*((</span><span class="dt">const</span> <span class="dt">int</span><span class="op">*)</span>elem1<span class="op">))</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Pero también podría escribirlo claramente con un encargo:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> compar<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>elem1<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>elem2<span class="op">)</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">int</span> <span class="op">*</span>e1 <span class="op">=</span> elem1<span class="op">;</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">int</span> <span class="op">*</span>e2 <span class="op">=</span> elem2<span class="op">;</span></span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>e2 <span class="op">-</span> <span class="op">*</span>e1<span class="op">;</span></span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Uno de los lugares en los que verás más comúnmente las conversiones es para evitar una advertencia al imprimir valores de puntero con el raramente usado <code>%p</code> que se pone quisquilloso con cualquier cosa que no sea un <code>void*</code>:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%p\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">);</span></span></code></pre></div>
<p>genera esta advertencia:</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a>warning: format ‘%p’ expects argument of type ‘void *’, but argument</span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>         2 has type ‘int *’</span></code></pre></div>
<p>Puedes arreglarlo con una escayola:</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%p\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>p<span class="op">);</span></span></code></pre></div>
<p>Otro lugar es con cambios explícitos de puntero, si no quieres usar un <code>void*</code> intermedio, pero estos también son bastante infrecuentes:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>c <span class="op">=</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*)</span>p<span class="op">;</span></span></code></pre></div>
<p>Un tercer lugar donde suele ser necesario es con las funciones de conversión de caracteres en <a href="https://beej.us/guide/bgclr/html/split/ctype.html"><code>&lt;ctype.h&gt;</code></a><a href="#fn114" class="footnote-ref" id="fnref114" role="doc-noteref"><sup>114</sup></a> donde debe convertir los valores con signo dudoso a <code>unsigned char</code> para evitar comportamientos indefinidos.</p>
<p>Una vez más, en la práctica rara vez se <em>necesita</em> el reparto. Si te encuentras casteando, puede que haya otra forma de hacer lo mismo, o puede que estés casteando innecesariamente.</p>
<p>O puede que sea necesario. Personalmente, intento evitarlo, pero no tengo miedo de utilizarlo si es necesario. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="16" id="tipos-iv-calificadores-y-especificadores"><span class="header-section-number">16</span> Tipos IV: Calificadores y especificadores</h1>
<p>Ahora que tenemos algunos tipos más en nuestro haber, resulta que podemos dar a estos tipos algunos atributos adicionales que controlan su comportamiento. Estos son los <em>calificadores de tipo</em> y los <em>especificadores de clase de almacenamiento</em>.</p>
<h2 data-number="16.1" id="calificadores-de-tipo"><span class="header-section-number">16.1</span> Calificadores de tipo</h2>
<p></p>
<p>Esto le permitirá declarar valores constantes, y también dar al compilador pistas de optimización que puede utilizar.</p>
<h3 data-number="16.1.1" id="const"><span class="header-section-number">16.1.1</span> <code>const</code></h3>
<p></p>
<p>Es el calificador de tipo más común. Significa que la variable es constante y que cualquier intento de modificarla, provocará el enfado del compilador.</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">4</span><span class="op">;</span>  <span class="co">// COMPILADOR EMITE SONIDOS DE BOCINAZOS</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// no se puede asignar a una constante</span></span></code></pre></div>
<p>No se puede modificar un valor <code>const</code>.</p>
<p>A menudo se ve <code>const</code> en las listas de parámetros de las funciones:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">const</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x <span class="op">+</span> <span class="dv">30</span><span class="op">);</span>  <span class="co">// OK, no modifica «x»</span></span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="16.1.1.1" id="const-y-punteros"><span class="header-section-number">16.1.1.1</span> <code>const</code> y punteros</h4>
<p></p>
<p>Esto se pone un poco raro, porque hay dos usos que tienen dos significados cuando se trata de punteros.</p>
<p>Por un lado, podemos hacer que no se pueda cambiar la cosa a la que apunta el puntero. Esto se hace poniendo <code>const</code> delante del nombre del tipo (antes del asterisco) en la declaración del tipo.</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">};</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> x<span class="op">;</span> </span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>  <span class="co">// Podemos modificar p, no hay problema</span></span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-6"><a href="#cb262-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">30</span><span class="op">;</span> <span class="co">// ¡Error del compilador! No se puede cambiar a qué apunta</span></span></code></pre></div>
<p>De forma un tanto confusa, estas dos cosas son equivalentes:</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span> <span class="co">// No se puede modificar a qué apunta p</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="dt">const</span> <span class="op">*</span>p<span class="op">;</span> <span class="co">// No se puede modificar a qué apunta p,</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>              <span class="co">// igual que en la línea anterior</span></span></code></pre></div>
<p>Genial, así que no podemos cambiar la cosa a la que apunta el puntero, pero podemos cambiar el propio puntero. ¿Qué pasa si queremos lo contrario? ¿Queremos poder cambiar aquello a lo que apunta el puntero, pero <em>no</em> el puntero en sí?</p>
<p>Basta con mover el <code>const</code> después del asterisco en la declaración:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p<span class="op">;</span> <span class="co">// No podemos modificar «p» con aritmética de punteros</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span> <span class="co">// ¡Error del compilador!</span></span></code></pre></div>
<p>Pero podemos modificar lo que señalan:</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>   <span class="co">// Pon «x» a 20, no hay problema</span></span></code></pre></div>
<p>También puedes hacer que ambas cosas sean <code>const</code>:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p<span class="op">;</span>  <span class="co">// ¡No se puede modificar p o *p!</span></span></code></pre></div>
<p>Por último, si tienes varios niveles de indirección, debes <code>const</code> los niveles apropiados. Sólo porque un puntero sea <code>const</code>, no significa que el puntero al que apunta también deba serlo. Puedes establecerlos explícitamente como en los siguientes ejemplos:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">**</span>p<span class="op">;</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>     <span class="co">// OK!</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>p<span class="op">)++;</span>  <span class="co">// OK!</span></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">**</span><span class="dt">const</span> p<span class="op">;</span></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>     <span class="co">// Error!</span></span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>p<span class="op">)++;</span>  <span class="co">// OK!</span></span>
<span id="cb267-8"><a href="#cb267-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-9"><a href="#cb267-9" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span><span class="dt">const</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb267-10"><a href="#cb267-10" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>     <span class="co">// OK!</span></span>
<span id="cb267-11"><a href="#cb267-11" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>p<span class="op">)++;</span>  <span class="co">// Error!</span></span>
<span id="cb267-12"><a href="#cb267-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-13"><a href="#cb267-13" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span><span class="dt">const</span> <span class="op">*</span><span class="dt">const</span> p<span class="op">;</span></span>
<span id="cb267-14"><a href="#cb267-14" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>     <span class="co">// Error!</span></span>
<span id="cb267-15"><a href="#cb267-15" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>p<span class="op">)++;</span>  <span class="co">// Error!</span></span></code></pre></div>
<p></p>
<h4 data-number="16.1.1.2" id="const-corrección"><span class="header-section-number">16.1.1.2</span> <code>const</code> Corrección</h4>
<p></p>
<p>Una cosa más que tengo que mencionar es que el compilador advertirá en algo como esto:</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span></code></pre></div>
<p>diciendo algo así como:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a>initialization discards &#39;const&#39; qualifier from pointer type target</span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a>// la inicialización descarta el calificador &#39;const&#39; del objetivo de tipo puntero</span></code></pre></div>
<p>¿Qué ocurre ahí?</p>
<p>Bueno, tenemos que mirar los tipos a cada lado de la asignación:</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a><span class="co">//    ^       ^</span></span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a><span class="co">//    |       |</span></span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a><span class="co">//  int*    const int*</span></span></code></pre></div>
<p>El compilador nos está avisando de que el valor de la derecha de la asignación es <code>const</code>, pero el de la izquierda no. Y el compilador nos está avisando de que está descartando la «const-idad» de la expresión de la derecha.</p>
<p>Es decir, <em>podemos</em> seguir intentando hacer lo siguiente, pero es incorrecto. El compilador avisará, y es un comportamiento indefinido:</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">40</span><span class="op">;</span>  <span class="co">// Comportamiento indefinido--¡quizás modifica «x», quizás no!</span></span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 40, si tienes suerte</span></span></code></pre></div>
<p> </p>
<h3 data-number="16.1.2" id="restrict"><span class="header-section-number">16.1.2</span> <code>restrict</code></h3>
<p></p>
<p>TLDR: nunca tienes que usar esto y puedes ignorarlo cada vez que lo veas. Si lo usas correctamente, es probable que obtengas alguna ganancia de rendimiento. Si lo usas incorrectamente, obtendrás un comportamiento indefinido.</p>
<p><code>restrict</code> es una sugerencia al compilador de que una determinada parte de la memoria sólo será accedida por un puntero y nunca por otro. (Es decir, no habrá aliasing del objeto concreto al que apunta el puntero <code>restrict</code>). Si un desarrollador declara que un puntero es <code>restrict</code> y luego accede al objeto al que apunta de otra manera (por ejemplo, a través de otro puntero), el comportamiento es indefinido.</p>
<p>Básicamente le estás diciendo a C, «Hey—te garantizo que este único puntero es la única forma en la que accedo a esta memoria, y si miento, puedes sacarme un comportamiento indefinido».</p>
<p>Y C usa esa información para realizar ciertas optimizaciones. Por ejemplo, si estás desreferenciando el puntero <code>restrict</code> repetidamente en un bucle, C podría decidir almacenar en caché el resultado en un registro y sólo almacenar el resultado final una vez que el bucle haya terminado. Si cualquier otro puntero hiciera referencia a esa misma memoria y accediera a ella en el bucle, los resultados no serían exactos.</p>
<p>(Nótese que <code>restrict</code> no tiene efecto si nunca se escribe en el objeto apuntado. Se trata de optimizaciones en torno a las escrituras en memoria).</p>
<p>Escribamos una función para intercambiar dos variables, y usaremos la palabra clave <code>restrict</code> para asegurar a C que nunca pasaremos punteros a la misma cosa. Y luego intentemos pasar punteros a la misma cosa.</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb272-1"><a href="#cb272-1"></a><span class="dt">void</span> swap<span class="op">(</span><span class="dt">int</span> <span class="op">*</span><span class="dt">restrict</span> a<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span><span class="dt">restrict</span> b<span class="op">)</span></span>
<span id="cb272-2"><a href="#cb272-2"></a><span class="op">{</span></span>
<span id="cb272-3"><a href="#cb272-3"></a>    <span class="dt">int</span> t<span class="op">;</span></span>
<span id="cb272-4"><a href="#cb272-4"></a></span>
<span id="cb272-5"><a href="#cb272-5"></a>    t <span class="op">=</span> <span class="op">*</span>a<span class="op">;</span></span>
<span id="cb272-6"><a href="#cb272-6"></a>    <span class="op">*</span>a <span class="op">=</span> <span class="op">*</span>b<span class="op">;</span></span>
<span id="cb272-7"><a href="#cb272-7"></a>    <span class="op">*</span>b <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb272-8"><a href="#cb272-8"></a><span class="op">}</span></span>
<span id="cb272-9"><a href="#cb272-9"></a></span>
<span id="cb272-10"><a href="#cb272-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb272-11"><a href="#cb272-11"></a><span class="op">{</span></span>
<span id="cb272-12"><a href="#cb272-12"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb272-13"><a href="#cb272-13"></a></span>
<span id="cb272-14"><a href="#cb272-14"></a>    swap<span class="op">(&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span> <span class="co">// ¡Bien! «a» y “b”, arriba, apuntan a cosas diferentes</span></span>
<span id="cb272-15"><a href="#cb272-15"></a></span>
<span id="cb272-16"><a href="#cb272-16"></a>    swap<span class="op">(&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">);</span> <span class="co">// ¡Comportamiento indefinido! «a» y “b” apuntan a lo mismo</span></span>
<span id="cb272-17"><a href="#cb272-17"></a><span class="op">}</span></span></code></pre></div>
<p>Si elimináramos las palabras clave <code>restrict</code>, ambas llamadas funcionarían de forma segura. Pero entonces el compilador podría no ser capaz de optimizar.</p>
<p><code>restrict</code> tiene ámbito de bloque, es decir, la restricción sólo dura el ámbito en el que se usa. Si está en una lista de parámetros de una función, está en el ámbito de bloque de esa función.</p>
<p>Si el puntero restringido apunta a un array, sólo se aplica a los objetos individuales del array. Otros punteros pueden leer y escribir desde el array siempre que no lean o escriban ninguno de los mismos elementos que el restringido.</p>
<p>Si está fuera de cualquier función en el ámbito del fichero, la restricción cubre todo el programa.</p>
<p>Es probable que veas esto en funciones de biblioteca como <code>printf()</code>:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> printf<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span> <span class="dt">restrict</span> format<span class="op">,</span> <span class="op">...);</span></span></code></pre></div>
<p>De nuevo, esto sólo indica al compilador que dentro de la función <code>printf()</code> sólo habrá un puntero que haga referencia a cualquier parte de la cadena <code>format</code>.</p>
<p>Una última nota: si por alguna razón estás usando la notación de array en el parámetro de tu función en lugar de la notación de puntero, puedes usar <code>restrict</code> así:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span> p<span class="op">[</span><span class="dt">restrict</span><span class="op">])</span> <span class="co">// Sin tamaño</span></span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span> p<span class="op">[</span><span class="dt">restrict</span> <span class="dv">10</span><span class="op">])</span> <span class="co">// O con un tamaño</span></span></code></pre></div>
<p>Pero la notación de puntero sería más común.</p>
<p></p>
<h3 data-number="16.1.3" id="volatile"><span class="header-section-number">16.1.3</span> <code>volatile</code></h3>
<p></p>
<p>Es poco probable que veas o necesites esto a menos que estés tratando con hardware directamente.</p>
<p><code>volatile</code> indica al compilador que un valor puede cambiar a sus espaldas y que debe buscarlo cada vez.</p>
<p>Un ejemplo podría ser cuando el compilador está buscando en la memoria una dirección que se actualiza continuamente entre bastidores, por ejemplo, algún tipo de temporizador de hardware.</p>
<p>Si el compilador decide optimizar eso y almacenar el valor en un registro durante un tiempo prolongado, el valor en memoria se actualizará y no se reflejará en el registro.</p>
<p>Al declarar algo <code>volátil</code>, le estás diciendo al compilador: «Oye, la cosa a la que esto apunta puede cambiar en cualquier momento por razones ajenas a este código de programa».</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a><span class="dt">volatile</span> <span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span></span></code></pre></div>
<h3 data-number="16.1.4" id="atomic"><span class="header-section-number">16.1.4</span> <code>_Atomic</code></h3>
<p>Esta es una característica opcional de C de la que hablaremos en <a href="#chapter-atomics">el capítulo Atómica</a>.</p>
<p> </p>
<h2 data-number="16.2" id="especificadores-de-clase-de-almacenamiento"><span class="header-section-number">16.2</span> Especificadores de clase de almacenamiento</h2>
<p></p>
<p>Los especificadores de clase de almacenamiento son similares a los cuantificadores de tipo. Proporcionan al compilador más información sobre el tipo de una variable.</p>
<h3 data-number="16.2.1" id="auto"><span class="header-section-number">16.2.1</span> <code>auto</code></h3>
<p></p>
<p>Apenas se ve esta palabra clave, ya que <code>auto</code> es el valor por defecto para las variables de ámbito de bloque. Está implícita.</p>
<p>Son los mismos:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">;</span> <span class="co">// auto es el valor por defecto...</span></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="dt">int</span> a<span class="op">;</span> <span class="co">// Esto es redundante</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>La palabra clave <code>auto</code> indica que este objeto tiene <em>duración de almacenamiento automática</em>. Es decir, existe en el ámbito en el que se define, y se desasigna automáticamente cuando se sale del ámbito.</p>
<p>Un inconveniente de las variables automáticas es que su valor es indeterminado hasta que se inicializan explícitamente. Decimos que están llenas de datos «aleatorios» o «basura», aunque ninguna de las dos cosas me hace feliz. En cualquier caso, no sabrás lo que contiene a menos que la inicialices.</p>
<p></p>
<p>Inicialice siempre todas las variables automáticas antes de utilizarlas.</p>
<h3 data-number="16.2.2" id="static"><span class="header-section-number">16.2.2</span> <code>static</code></h3>
<p></p>
<p>Esta palabra clave tiene dos significados, dependiendo de si la variable es de ámbito de fichero o de ámbito de bloque.</p>
<p>Empecemos con el ámbito de bloque.</p>
<h4 data-number="16.2.2.1" id="static-en-alcance-del-bloque"><span class="header-section-number">16.2.2.1</span> <code>static</code> en Alcance del bloque</h4>
<p></p>
<p>En este caso, básicamente estamos diciendo: «Sólo quiero que exista una única instancia de esta variable, compartida entre llamadas».</p>
<p>Es decir, su valor persistirá entre llamadas.</p>
<p>Una variable <code>static</code> en ámbito de bloque con un inicializador sólo se inicializará una vez al iniciar el programa, no cada vez que se llame a la función.</p>
<p>Hagamos un ejemplo:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb277-1"><a href="#cb277-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb277-2"><a href="#cb277-2"></a></span>
<span id="cb277-3"><a href="#cb277-3"></a><span class="dt">void</span> counter<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb277-4"><a href="#cb277-4"></a><span class="op">{</span></span>
<span id="cb277-5"><a href="#cb277-5"></a>    <span class="dt">static</span> <span class="dt">int</span> count <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// Se inicializa una vez</span></span>
<span id="cb277-6"><a href="#cb277-6"></a></span>
<span id="cb277-7"><a href="#cb277-7"></a>    printf<span class="op">(</span><span class="st">&quot;Se ha llamado </span><span class="sc">%d</span><span class="st"> vez(es)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> count<span class="op">);</span></span>
<span id="cb277-8"><a href="#cb277-8"></a></span>
<span id="cb277-9"><a href="#cb277-9"></a>    count<span class="op">++;</span></span>
<span id="cb277-10"><a href="#cb277-10"></a><span class="op">}</span></span>
<span id="cb277-11"><a href="#cb277-11"></a></span>
<span id="cb277-12"><a href="#cb277-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb277-13"><a href="#cb277-13"></a><span class="op">{</span></span>
<span id="cb277-14"><a href="#cb277-14"></a>    counter<span class="op">();</span> <span class="co">// «Se ha llamado 1 vez(es)»</span></span>
<span id="cb277-15"><a href="#cb277-15"></a>    counter<span class="op">();</span> <span class="co">// «Se ha llamado 2 vez(es)»</span></span>
<span id="cb277-16"><a href="#cb277-16"></a>    counter<span class="op">();</span> <span class="co">// «Se ha llamado 3 vez(es)»</span></span>
<span id="cb277-17"><a href="#cb277-17"></a>    counter<span class="op">();</span> <span class="co">// «Se ha llamado 4 vez(es)»</span></span>
<span id="cb277-18"><a href="#cb277-18"></a><span class="op">}</span></span></code></pre></div>
<p>¿Ves cómo el valor de <code>count</code> persiste entre llamadas?</p>
<p>Una cosa a tener en cuenta es que las variables de ámbito de bloque <code>static</code> se inicializan a <code>0</code> por defecto.</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> foo<span class="op">;</span> <span class="co">// El valor inicial por defecto es `0`...</span></span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> foo <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Así que la asignación `0` es redundante</span></span></code></pre></div>
<p>Por último, ten en cuenta que si escribes programas multihilo, tienes que asegurarte de no dejar que varios hilos pisoteen la misma variable.</p>
<p></p>
<h4 data-number="16.2.2.2" id="static-en-alcance-del-archivo"><span class="header-section-number">16.2.2.2</span> <code>static</code> en Alcance del archivo</h4>
<p></p>
<p>Cuando se sale del ámbito del fichero, fuera de cualquier bloque, el significado cambia bastante.</p>
<p>Las variables en el ámbito del fichero ya persisten entre llamadas a funciones, así que ese comportamiento ya existe.</p>
<p>En cambio, lo que <code>static</code> significa en este contexto es que esta variable no es visible fuera de este archivo fuente en particular. Algo así como «global», pero sólo en este archivo.</p>
<p>Más sobre esto en la sección sobre construir con múltiples ficheros fuente. </p>
<h3 data-number="16.2.3" id="extern"><span class="header-section-number">16.2.3</span> <code>extern</code></h3>
<p></p>
<p>El especificador de clase de almacenamiento <code>extern</code> nos da una forma de referirnos a objetos en otros ficheros fuente.</p>
<p>Digamos, por ejemplo, que el fichero <code>bar.c</code> tiene lo siguiente en su totalidad:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb279-1"><a href="#cb279-1"></a><span class="co">// bar.c</span></span>
<span id="cb279-2"><a href="#cb279-2"></a></span>
<span id="cb279-3"><a href="#cb279-3"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">37</span><span class="op">;</span></span></code></pre></div>
<p>Sólo eso. Declarando un nuevo <code>int a</code> en el ámbito del fichero.</p>
<p>¿Pero qué pasaría si tuviéramos otro fichero fuente, <code>foo.c</code>, y quisiéramos referirnos a <code>a</code> que está en <code>bar.c</code>?</p>
<p>Es fácil con la palabra clave <code>extern</code>:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb280-1"><a href="#cb280-1"></a><span class="co">// foo.c</span></span>
<span id="cb280-2"><a href="#cb280-2"></a></span>
<span id="cb280-3"><a href="#cb280-3"></a><span class="kw">extern</span> <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb280-4"><a href="#cb280-4"></a></span>
<span id="cb280-5"><a href="#cb280-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb280-6"><a href="#cb280-6"></a><span class="op">{</span></span>
<span id="cb280-7"><a href="#cb280-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// 37, ¡desde bar.c!</span></span>
<span id="cb280-8"><a href="#cb280-8"></a></span>
<span id="cb280-9"><a href="#cb280-9"></a>    a <span class="op">=</span> <span class="dv">99</span><span class="op">;</span></span>
<span id="cb280-10"><a href="#cb280-10"></a></span>
<span id="cb280-11"><a href="#cb280-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// La misma «a» de bar.c, pero ahora es 99</span></span>
<span id="cb280-12"><a href="#cb280-12"></a><span class="op">}</span></span></code></pre></div>
<p>También podríamos haber hecho el <code>extern int a</code> en el ámbito del bloque, y aún así se habría referido al <code>a</code> en <code>bar.c</code>:</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb281-1"><a href="#cb281-1"></a><span class="co">// foo.c</span></span>
<span id="cb281-2"><a href="#cb281-2"></a></span>
<span id="cb281-3"><a href="#cb281-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb281-4"><a href="#cb281-4"></a><span class="op">{</span></span>
<span id="cb281-5"><a href="#cb281-5"></a>    <span class="kw">extern</span> <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb281-6"><a href="#cb281-6"></a></span>
<span id="cb281-7"><a href="#cb281-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// 37, ¡desde bar.c!</span></span>
<span id="cb281-8"><a href="#cb281-8"></a></span>
<span id="cb281-9"><a href="#cb281-9"></a>    a <span class="op">=</span> <span class="dv">99</span><span class="op">;</span></span>
<span id="cb281-10"><a href="#cb281-10"></a></span>
<span id="cb281-11"><a href="#cb281-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// La misma «a» de bar.c, pero ahora es 99</span></span>
<span id="cb281-12"><a href="#cb281-12"></a><span class="op">}</span></span></code></pre></div>
<p>Ahora bien, si <code>a</code> en <code>bar.c</code> se hubiera marcado como <code>static</code>, esto no habría funcionado. Las variables <code>static</code> en el ámbito de un fichero no son visibles fuera de ese fichero.</p>
<p>Una nota final sobre <code>extern</code> en funciones. Para las funciones, <code>extern</code> es el valor por defecto, por lo que es redundante. Puedes declarar una función <code>static</code> si sólo quieres que sea visible en un único fichero fuente.</p>
<p></p>
<h3 data-number="16.2.4" id="register"><span class="header-section-number">16.2.4</span> <code>register</code></h3>
<p></p>
<p>Se trata de una palabra clave que indica al compilador que esta variable se utiliza con frecuencia, y que debe ser lo más rápida posible. El compilador no está obligado a aceptarla.</p>
<p>Ahora bien, los modernos optimizadores del compilador de C son bastante eficaces a la hora de averiguar esto por sí mismos, por lo que es raro verlo hoy en día.</p>
<p>Pero si es necesario:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb282-1"><a href="#cb282-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb282-2"><a href="#cb282-2"></a></span>
<span id="cb282-3"><a href="#cb282-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb282-4"><a href="#cb282-4"></a><span class="op">{</span></span>
<span id="cb282-5"><a href="#cb282-5"></a>    <span class="dt">register</span> <span class="dt">int</span> a<span class="op">;</span>   <span class="co">// Haz que «a» sea tan rápido de usar como sea posible.</span></span>
<span id="cb282-6"><a href="#cb282-6"></a></span>
<span id="cb282-7"><a href="#cb282-7"></a>    <span class="cf">for</span> <span class="op">(</span>a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> a <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> a<span class="op">++)</span></span>
<span id="cb282-8"><a href="#cb282-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span></span>
<span id="cb282-9"><a href="#cb282-9"></a><span class="op">}</span></span></code></pre></div>
<p>Sin embargo, tiene un precio. No se puede tomar la dirección de un registro:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">;</span>    <span class="co">// ¡ERROR DEL COMPILADOR!</span></span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true" tabindex="-1"></a>                <span class="co">// No se puede tomar la dirección de un registro!</span></span></code></pre></div>
<p>Lo mismo se aplica a cualquier parte de una matriz:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> a<span class="op">;</span>  <span class="co">// ¡ERROR DEL COMPILADOR! No se puede tomar la dirección de a[0]</span></span></code></pre></div>
<p>O desreferenciar parte de un array:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="op">*(</span>a <span class="op">+</span> <span class="dv">2</span><span class="op">);</span>  <span class="co">// ¡ERROR DEL COMPILADOR! Dirección de a[0] tomada</span></span></code></pre></div>
<p>Curiosamente, para el equivalente con notación array, gcc sólo avisa:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> a<span class="op">[</span><span class="dv">2</span><span class="op">];</span>  <span class="co">// ¡ADVERTENCIA DEL COMPILADOR!</span></span></code></pre></div>
<p>con:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a>warning: ISO C forbids subscripting ‘register’ array</span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a>//Advertencia: ISO C prohíbe los subíndices en las matrices &#39;register&#39;</span></code></pre></div>
<p>El hecho de que no se pueda tomar la dirección de una variable de registro libera al compilador para realizar optimizaciones en torno a esa suposición, si es que aún no las ha deducido. Además, añadir <code>register</code> a una variable <code>const</code> evita que accidentalmente se pase su puntero a otra función que ignore su constancia <a href="#fn115" class="footnote-ref" id="fnref115" role="doc-noteref"><sup>115</sup></a>.</p>
<p>Un poco de historia: en el interior de la CPU hay pequeñas «variables» dedicadas llamadas <a href="https://en.wikipedia.org/wiki/Processor_register"><em>registers / registros</em></a><a href="#fn116" class="footnote-ref" id="fnref116" role="doc-noteref"><sup>116</sup></a>. Su acceso es superrápido comparado con la RAM, por lo que usarlas aumenta la velocidad. Pero no están en la RAM, así que no tienen una dirección de memoria asociada (por eso no puedes tomar la dirección-de u obtener un puntero a ellas).</p>
<p>Pero, como ya he dicho, los compiladores modernos son realmente buenos a la hora de producir código óptimo, utilizando registros siempre que sea posible independientemente de si se ha especificado o no la palabra clave <code>register</code>. No sólo eso, sino que la especificación les permite tratarlo como si hubieras escrito «auto», si quieren. Así que no hay garantías.</p>
<p></p>
<h3 data-number="16.2.5" id="thread_local"><span class="header-section-number">16.2.5</span> <code>_Thread_local</code></h3>
<p></p>
<p>Cuando utilizas varios subprocesos y tienes algunas variables en el ámbito global o <code>static</code> del bloque, esta es una forma de asegurarte de que cada subproceso obtiene su propia copia de la variable. Esto te ayudará a evitar condiciones de carrera y que los hilos se pisen unos a otros.</p>
<p>Si estás en ámbito de bloque, tienes que usar esto junto con <code>extern</code> o <code>static</code>.</p>
<p>Además, si incluyes <code>&lt;threads.h&gt;</code>, puedes usar el más agradable <code>thread_local</code> como alias del más feo <code>_Thread_local</code>.</p>
<p>Puedes encontrar más información en la sección <a href="#thread-local">Threads</a>.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="17" id="proyectos-multiarchivos"><span class="header-section-number">17</span> Proyectos multiarchivos</h1>
<p></p>
<p>Hasta ahora hemos visto programas de juguete que, en su mayor parte, caben en un único archivo. Pero los programas C complejos se componen de muchos archivos que se compilan y enlazan en un único ejecutable.</p>
<p>En este capítulo veremos algunos de los patrones y prácticas más comunes para crear proyectos más grandes.</p>
<h2 data-number="17.1" id="includes-func-protos"><span class="header-section-number">17.1</span> Incluye prototipos y funciones</h2>
<p> </p>
<p>Una situación realmente común es que algunas de tus funciones estén definidas en un fichero, y quieras llamarlas desde otro.</p>
<p>Esto en realidad funciona con una advertencia… probemos primero y luego veamos la forma correcta de arreglar la advertencia.</p>
<p>Para estos ejemplos, pondremos el nombre del archivo como el primer comentario en el código fuente.</p>
<p>Para compilarlos, necesitarás especificar todas las fuentes en la línea de comandos:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="co"># archivo de salida      archivos de origen</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a><span class="co">#     v                       |</span></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a><span class="co">#   |----| |---------|        | </span></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-o</span> foo foo.c bar.c  <span class="op">&lt;</span>-----<span class="kw">|</span></span></code></pre></div>
<p>En esos ejemplos, <code>foo.c</code> y <code>bar.c</code> se construyen en el ejecutable llamado <code>foo</code>.</p>
<p>Así que echemos un vistazo al archivo fuente <code>bar.c</code>:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb289-1"><a href="#cb289-1"></a><span class="co">// Archivo bar.c</span></span>
<span id="cb289-2"><a href="#cb289-2"></a></span>
<span id="cb289-3"><a href="#cb289-3"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb289-4"><a href="#cb289-4"></a><span class="op">{</span></span>
<span id="cb289-5"><a href="#cb289-5"></a>    <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb289-6"><a href="#cb289-6"></a><span class="op">}</span></span></code></pre></div>
<p>Y el archivo <code>foo.c</code> con main en él:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb290-1"><a href="#cb290-1"></a><span class="co">// Archivo foo.c</span></span>
<span id="cb290-2"><a href="#cb290-2"></a></span>
<span id="cb290-3"><a href="#cb290-3"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb290-4"><a href="#cb290-4"></a></span>
<span id="cb290-5"><a href="#cb290-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb290-6"><a href="#cb290-6"></a><span class="op">{</span></span>
<span id="cb290-7"><a href="#cb290-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> add<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">));</span>  <span class="co">// 5!</span></span>
<span id="cb290-8"><a href="#cb290-8"></a><span class="op">}</span></span></code></pre></div>
<p>Mira cómo desde <code>main()</code> llamamos a <code>add()</code>–¡pero <code>add()</code> está en un fichero fuente completamente diferente! Está en <code>bar.c</code>, ¡mientras que la llamada a él está en <code>foo.c</code>!</p>
<p>Si construimos esto con:</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-o</span> foo foo.c bar.c</span></code></pre></div>
<p>obtenemos este error:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>error: implicit declaration of function &#39;add&#39; is invalid in C99</span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a>// error: la declaración implícita de la función &#39;add&#39; no es válida en C99</span></code></pre></div>
<p>(O puede recibir una advertencia. Que no debes ignorar. Nunca ignores las advertencias en C; atiéndelas todas).</p>
<p>Si recuerdas la <a href="#prototypes">sección sobre prototipos</a>, las declaraciones implícitas están prohibidas en el C moderno y no hay ninguna razón legítima para introducirlas en código nuevo. Deberíamos arreglarlo.</p>
<p>Lo que significa <code>declaración implícita</code> es que estamos usando una función, en este caso <code>add()</code>, sin que C sepa nada de ella de antemano. C quiere saber qué devuelve, qué tipos toma como argumentos, y cosas por el estilo.</p>
<p>Ya vimos cómo arreglar esto antes con un <em>prototipo de función</em>. De hecho, si añadimos uno de esos a <code>foo.c</code> antes de hacer la llamada, todo funciona bien:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb293-1"><a href="#cb293-1"></a><span class="co">// File foo.c</span></span>
<span id="cb293-2"><a href="#cb293-2"></a></span>
<span id="cb293-3"><a href="#cb293-3"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb293-4"><a href="#cb293-4"></a></span>
<span id="cb293-5"><a href="#cb293-5"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">);</span>  <span class="co">// Añadir el prototipo</span></span>
<span id="cb293-6"><a href="#cb293-6"></a></span>
<span id="cb293-7"><a href="#cb293-7"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb293-8"><a href="#cb293-8"></a><span class="op">{</span></span>
<span id="cb293-9"><a href="#cb293-9"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> add<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">));</span>  <span class="co">// 5!</span></span>
<span id="cb293-10"><a href="#cb293-10"></a><span class="op">}</span></span></code></pre></div>
<p>Se acabaron los errores.</p>
<p>Pero eso es un coñazo—tener que teclear el prototipo cada vez que quieres usar una función. Quiero decir, usamos <code>printf()</code> justo ahí y no necesitamos teclear un prototipo; ¿qué pasa?</p>
<p>Si recuerdas lo que pasó con «hola.c» al principio del libro, ¡en realidad incluimos el prototipo de <code>printf()</code> <em>! ¡Está en el fichero <code>stdio.h</code> !</em> ¡Y lo incluimos con <code>#include</code>!</p>
<p>¿Podemos hacer lo mismo con nuestra función <code>add()</code>? ¿Hacer un prototipo para ella y ponerlo en un fichero de cabecera?</p>
<p>Por supuesto.</p>
<p>Los ficheros de cabecera en C tienen una extensión <code>.h</code> por defecto. Y a menudo, aunque no siempre, tienen el mismo nombre que su correspondiente archivo <code>.c</code>. Así que vamos a crear un fichero <code>bar.h</code> para nuestro fichero <code>bar.c</code>, y vamos a meter el prototipo en él:</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb294-1"><a href="#cb294-1"></a><span class="co">// Archivo bar.h</span></span>
<span id="cb294-2"><a href="#cb294-2"></a></span>
<span id="cb294-3"><a href="#cb294-3"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">);</span></span></code></pre></div>
<p>Y ahora vamos a modificar <code>foo.c</code> para incluir ese fichero. Suponiendo que está en el mismo directorio, lo incluimos entre comillas dobles (en lugar de corchetes angulares):</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb295-1"><a href="#cb295-1"></a><span class="co">// Archivo foo.c</span></span>
<span id="cb295-2"><a href="#cb295-2"></a></span>
<span id="cb295-3"><a href="#cb295-3"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb295-4"><a href="#cb295-4"></a></span>
<span id="cb295-5"><a href="#cb295-5"></a><span class="pp">#include </span><span class="im">&quot;bar.h&quot;</span><span class="pp">  </span><span class="co">// Incluir desde el directorio actual</span></span>
<span id="cb295-6"><a href="#cb295-6"></a></span>
<span id="cb295-7"><a href="#cb295-7"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb295-8"><a href="#cb295-8"></a><span class="op">{</span></span>
<span id="cb295-9"><a href="#cb295-9"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> add<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">));</span>  <span class="co">// 5!</span></span>
<span id="cb295-10"><a href="#cb295-10"></a><span class="op">}</span></span></code></pre></div>
<p>Fíjate en que ya no tenemos el prototipo en <code>foo.c</code>, lo hemos incluido en <code>bar.h</code>. Ahora <em>cualquier</em> fichero que quiera la funcionalidad <code>add()</code> puede simplemente <code>#include «bar.h»</code> para obtenerla, y no necesitas preocuparte de escribir el prototipo de la función.</p>
<p>Como habrás adivinado, <code>#include</code> incluye literalmente el fichero nombrado <em>ahí mismo</em> en tu código fuente, como si lo hubieras tecleado.</p>
<p>Y al construir y ejecutar:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./foo</span></span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a><span class="ex">5</span></span></code></pre></div>
<p>Efectivamente, ¡obtenemos el resultado de <span class="math inline">\(2+3\)</span>! ¡Bien!</p>
<p>Pero no abras todavía tu bebida preferida. Ya casi hemos llegado. Sólo tenemos que añadir una pieza más de la repetición.</p>
<p></p>
<h2 data-number="17.2" id="tratamiento-de-la-repetición-include"><span class="header-section-number">17.2</span> Tratamiento de la repetición <code>#include</code></h2>
<p>No es infrecuente que un fichero de cabecera incluya a su vez otras cabeceras necesarias para la funcionalidad de sus correspondientes ficheros C. ¿Por qué no?</p>
<p>Y puede ser que tengas una cabecera <code>#include</code> varias veces desde diferentes sitios. Puede que eso no sea un problema, pero puede que cause errores de compilación. ¡Y no podemos controlar en cuántos sitios se hace <code>#include</code>!</p>
<p>Peor aún, ¡podríamos llegar a una situación loca en la que la cabecera <code>a.h</code> incluya la cabecera <code>b.h</code>, y <code>b.h</code> incluya <code>a.h</code>! ¡Es un ciclo infinito <code>#include</code>!</p>
<p>Intentar construir algo así da error:</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a>error: #include nested depth 200 exceeds maximum of 200</span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>//error : #include profundidad anidada 200 supera el máximo de 200</span></code></pre></div>
<p>Lo que tenemos que hacer es que si un archivo se incluye una vez, los subsiguientes <code>#include</code>s para ese archivo sean ignorados.</p>
<p><strong>Lo que vamos a hacer es tan común que deberías hacerlo automáticamente cada vez que crees un archivo de cabecera.</strong></p>
<p>Y la forma común de hacerlo es con una variable de preprocesador que establecemos la primera vez que <code>#incluimos</code> el archivo. Y entonces para los subsiguientes <code>#include</code>s, primero comprobamos que la variable no está definida.</p>
<p>Para ese nombre de variable, es supercomún tomar el nombre del fichero de cabecera, como <code>bar.h</code>, ponerlo en mayúsculas, y sustituir el punto por un guión bajo: <code>BAR_H</code>.</p>
<p>Por lo tanto, compruebe en la parte superior del archivo si ya se ha incluido y, en caso afirmativo, coméntelo todo.</p>
<p>(No pongas un guión bajo inicial (porque un guión bajo inicial seguido de una letra mayúscula está reservado) o un doble guión bajo inicial (porque también está reservado.))</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb298-1"><a href="#cb298-1"></a><span class="pp">#ifndef BAR_H </span><span class="co">// Si BAR_H no está definido...</span></span>
<span id="cb298-2"><a href="#cb298-2"></a><span class="pp">#define BAR_H </span><span class="co">// Definirlo (sin valor particular)</span></span>
<span id="cb298-3"><a href="#cb298-3"></a></span>
<span id="cb298-4"><a href="#cb298-4"></a><span class="co">// Archivo bar.h</span></span>
<span id="cb298-5"><a href="#cb298-5"></a></span>
<span id="cb298-6"><a href="#cb298-6"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">);</span></span>
<span id="cb298-7"><a href="#cb298-7"></a></span>
<span id="cb298-8"><a href="#cb298-8"></a><span class="pp">#endif          </span><span class="co">// Fin del #ifndef BAR_H</span></span></code></pre></div>
<p>Esto hará que el fichero de cabecera se incluya sólo una vez, sin importar en cuántos sitios se intente hacer <code>#include</code>.</p>
<p></p>
<h2 data-number="17.3" id="static-y-extern"><span class="header-section-number">17.3</span> <code>static</code> y <code>extern</code></h2>
<p> </p>
<p>Cuando se trata de proyectos multifichero, puedes asegurarte de que las variables y funciones de un fichero no son visibles desde otros ficheros fuente con la palabra clave <code>static</code>.</p>
<p>Y puedes hacer referencia a objetos de otros ficheros con <code>extern</code>.</p>
<p>Para más información, echa un vistazo a las secciones en el libro sobre el <a href="#static"><code>static</code></a> y <a href="#extern"><code>extern</code></a> especificadores de clase de almacenamiento.</p>
<p> </p>
<h2 data-number="17.4" id="compilación-con-archivos-de-objetos"><span class="header-section-number">17.4</span> Compilación con archivos de objetos</h2>
<p></p>
<p>Esto no es parte de la especificación, pero es 99,999% común en el mundo C.</p>
<p>Puedes compilar archivos C en una representación intermedia llamada <em>archivos objeto</em>. Estos son código máquina compilado que aún no ha sido puesto en un ejecutable.</p>
<p>Los archivos objeto en Windows tienen una extensión <code>.OBJ</code>; en Unix, son <code>.o</code>. </p>
<p>En gcc, podemos construir algo como esto, con la bandera <code>-c</code> (¡sólo compilar!):</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-c</span> foo.c <span class="co"># produce foo.o</span></span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-c</span> bar.c <span class="co"># produce bar.o</span></span></code></pre></div>
<p>Y luego podemos <em>enlazarlos</em> juntos en un único ejecutable:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-o</span> foo foo.o bar.o</span></code></pre></div>
<p><em>Voila</em>, hemos producido un ejecutable <code>foo</code> a partir de los dos ficheros objeto.</p>
<p>Pero usted está pensando, ¿por qué molestarse? ¿No podemos simplemente:</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-o</span> foo foo.c bar.c</span></code></pre></div>
<p>¿y matar dos <a href="https://en.wikipedia.org/wiki/Boids">boids</a><a href="#fn117" class="footnote-ref" id="fnref117" role="doc-noteref"><sup>117</sup></a> de un tiro?</p>
<p></p>
<p>Para programas pequeños, está bien. Yo lo hago todo el tiempo.</p>
<p>Pero para programas más grandes, podemos aprovechar el hecho de que compilar desde el código fuente a los ficheros objeto es relativamente lento, y enlazar un montón de ficheros objeto es relativamente rápido.</p>
<p>Esto realmente se muestra con la utilidad <code>make</code> que sólo reconstruye fuentes que son más recientes que sus salidas.</p>
<p>Digamos que tienes mil archivos C. Podrías compilarlos todos a ficheros objeto para empezar (lentamente) y luego combinar todos esos ficheros objeto en un ejecutable (rápido).</p>
<p>Ahora digamos que modificas sólo uno de esos archivos fuente en C -aquí está la magia: ¡sólo tienes que reconstruir ese archivo objeto para ese archivo fuente! Y luego reconstruir el ejecutable (rápido). Todos los demás archivos C no tienen que ser tocados.</p>
<p>En otras palabras, al reconstruir sólo los archivos objeto que necesitamos, reducimos radicalmente los tiempos de compilación. (A menos, claro, que estés haciendo una compilación «limpia», en cuyo caso hay que crear todos los ficheros objeto).</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="18" id="entorno-exterior"><span class="header-section-number">18</span> Entorno exterior</h1>
<p>Cuando ejecutas un programa, en realidad eres tú quien le habla al shell, diciéndole: «Oye, por favor, ejecuta esto». Y el intérprete de comandos dice: «Claro», y luego le dice al sistema operativo: «Oye, ¿podrías crear un nuevo proceso y ejecutar esta cosa?». Y si todo va bien, el sistema operativo cumple y tu programa se ejecuta.</p>
<p>Pero hay todo un mundo fuera de tu programa en el shell con el que se puede interactuar desde C. Veremos algunos de ellos en este capítulo.</p>
<h2 data-number="18.1" id="argumentos-de-la-línea-de-comandos"><span class="header-section-number">18.1</span> Argumentos de la línea de comandos</h2>
<p></p>
<p>Muchas utilidades de línea de comandos aceptan <em>argumentos de línea de comandos</em>. Por ejemplo, si queremos ver todos los archivos que terminan en <code>.txt</code>, podemos escribir algo como esto en un sistema tipo Unix:</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span> <span class="pp">*</span>.txt</span></code></pre></div>
<p>(o <code>dir</code> en lugar de <code>ls</code> en un sistema Windows).</p>
<p>En este caso, el comando es <code>ls</code>, pero sus argumentos son todos los ficheros que terminan en <code>.txt</code><a href="#fn118" class="footnote-ref" id="fnref118" role="doc-noteref"><sup>118</sup></a>.</p>
<p>Entonces, ¿cómo podemos ver lo que se pasa al programa desde la línea de comandos?</p>
<p>Digamos que tenemos un programa llamado <code>add</code> que suma todos los números pasados en la línea de comandos e imprime el resultado:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./add</span> 10 30 5</span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a><span class="ex">45</span></span></code></pre></div>
<p>¡Seguro que eso pagará las facturas!</p>
<p>Pero en serio, esta es una gran herramienta para ver cómo obtener esos argumentos de la línea de comandos y desglosarlos.</p>
<p>Primero, veamos cómo obtenerlos. ¡Para ello, vamos a necesitar un nuevo <code>main()</code>!</p>
<p>Aquí hay un programa que imprime todos los argumentos de la línea de comandos. Por ejemplo, si nombramos al ejecutable <code>foo</code>, podemos ejecutarlo así:</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./foo</span> i like turtles</span></code></pre></div>
<p>y veremos esta salida:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a>arg 0: ./foo</span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a>arg 1: i</span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a>arg 2: like</span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a>arg 3: turtles</span></code></pre></div>
<p>Es un poco raro, porque el argumento zero es el nombre del ejecutable, en sí mismo. Pero es algo a lo que hay que acostumbrarse. Los argumentos en sí siguen directamente.</p>
<p>Fuente:</p>
<p> </p>
<div class="sourceCode" id="cb306"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb306-1"><a href="#cb306-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb306-2"><a href="#cb306-2"></a></span>
<span id="cb306-3"><a href="#cb306-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb306-4"><a href="#cb306-4"></a><span class="op">{</span></span>
<span id="cb306-5"><a href="#cb306-5"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> argc<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb306-6"><a href="#cb306-6"></a>        printf<span class="op">(</span><span class="st">&quot;arg </span><span class="sc">%d</span><span class="st">: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> argv<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb306-7"><a href="#cb306-7"></a>    <span class="op">}</span></span>
<span id="cb306-8"><a href="#cb306-8"></a><span class="op">}</span></span></code></pre></div>
<p>¡Vaya! ¿Qué pasa con la firma de la función <code>main()</code>? ¿Qué son <code>argc</code> y <code>argv</code> <a href="#fn119" class="footnote-ref" id="fnref119" role="doc-noteref"><sup>119</sup></a>. (pronunciados <em>arg-cee</em> y <em>arg-vee</em>)?</p>
<p>Empecemos por lo más fácil: <code>argc</code>. Es el <em>número de argumentos</em>, incluido el propio nombre del programa. Si piensas en todos los argumentos como un array de cadenas, que es exactamente lo que son, entonces puedes pensar en <code>argc</code> como la longitud de ese array, que es exactamente lo que es.</p>
<p>Y así lo que estamos haciendo en ese bucle es ir a través de todos los <code>argv</code>s e imprimirlos uno a la vez, por lo que para una entrada dada:</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./foo</span> i like turtles</span></code></pre></div>
<p>obtenemos la salida correspondiente:</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>arg 0: ./foo</span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a>arg 1: i</span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a>arg 2: like</span>
<span id="cb308-4"><a href="#cb308-4" aria-hidden="true" tabindex="-1"></a>arg 3: turtles</span></code></pre></div>
<p>Con esto en mente, deberíamos estar listos para empezar con nuestro programa de sumadores.</p>
<p>Nuestro plan:</p>
<ul>
<li>Mirar todos los argumentos de la línea de comandos (pasado <code>argv[0]</code>, el nombre del programa)</li>
<li>Convertirlos en enteros</li>
<li>Sumarlos a un total</li>
<li>Imprimir el resultado</li>
</ul>
<p>Manos a la obra.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb309-1"><a href="#cb309-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb309-2"><a href="#cb309-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb309-3"><a href="#cb309-3"></a></span>
<span id="cb309-4"><a href="#cb309-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span></span>
<span id="cb309-5"><a href="#cb309-5"></a><span class="op">{</span></span>
<span id="cb309-6"><a href="#cb309-6"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb309-7"><a href="#cb309-7"></a></span>
<span id="cb309-8"><a href="#cb309-8"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> argc<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span> <span class="co">// Empieza en 1, el primer argumento</span></span>
<span id="cb309-9"><a href="#cb309-9"></a>        <span class="dt">int</span> value <span class="op">=</span> atoi<span class="op">(</span>argv<span class="op">[</span>i<span class="op">]);</span> <span class="co">// Usa strtol() para un mejor manejo de errores</span></span>
<span id="cb309-10"><a href="#cb309-10"></a></span>
<span id="cb309-11"><a href="#cb309-11"></a>        total <span class="op">+=</span> value<span class="op">;</span></span>
<span id="cb309-12"><a href="#cb309-12"></a>    <span class="op">}</span></span>
<span id="cb309-13"><a href="#cb309-13"></a></span>
<span id="cb309-14"><a href="#cb309-14"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> total<span class="op">);</span></span>
<span id="cb309-15"><a href="#cb309-15"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Recorridos de muestra:</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./add</span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a><span class="ex">0</span></span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./add 1</span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a><span class="ex">1</span></span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./add 1 2</span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a><span class="ex">3</span></span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./add 1 2 3</span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a><span class="ex">6</span></span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./add 1 2 3 4</span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a><span class="ex">10</span></span></code></pre></div>
<p>Por supuesto, podría vomitar si le pasas un no entero, pero endurecer contra eso se deja como un ejercicio para el lector.</p>
<h3 data-number="18.1.1" id="el-último-argv-es-null."><span class="header-section-number">18.1.1</span> El último <code>argv</code> es <code>NULL</code>.</h3>
<p>Una curiosidad sobre <code>argv</code> es que después de la última cadena hay un puntero a <code>NULL</code>.</p>
<p>Eso es:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a>argv<span class="op">[</span>argc<span class="op">]</span> <span class="op">==</span> NULL</span></code></pre></div>
<p>¡siempre es cierto!</p>
<p>Esto puede parecer inútil, pero resulta ser útil en un par de lugares; vamos a echar un vistazo a uno de ellos ahora mismo.</p>
<h3 data-number="18.1.2" id="el-suplente-char-argv"><span class="header-section-number">18.1.2</span> El suplente: <code>char **argv</code></h3>
<p>Recuerda que cuando llamas a una función, C no diferencia entre notación de array y notación de puntero en la firma de la función.</p>
<p>Es decir, son lo mismo:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">char</span> a<span class="op">[])</span></span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>a<span class="op">)</span></span></code></pre></div>
<p>Ahora, ha sido conveniente pensar en <code>argv</code> como una matriz de cadenas, es decir, una matriz de <code>char*</code>s, así que esto tenía sentido:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span></code></pre></div>
<p>pero debido a la equivalencia, también se podría escribir:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span></span></code></pre></div>
<p>¡Sí, es un puntero a un puntero, de acuerdo! Si te resulta más fácil, piensa que es un puntero a una cadena. Pero en realidad, es un puntero a un valor que apunta a un <code>char</code>.</p>
<p>Recuerda también que son equivalentes:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a>argv<span class="op">[</span>i<span class="op">]</span></span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a><span class="op">*(</span>argv <span class="op">+</span> i<span class="op">)</span></span></code></pre></div>
<p>Lo que significa que puedes hacer aritmética de punteros en <code>argv</code>.</p>
<p>Así que una forma alternativa de consumir los argumentos de la línea de comandos podría ser simplemente caminar a lo largo de la matriz <code>argv</code> subiendo un puntero hasta que lleguemos a ese <code>NULL</code> al final.</p>
<p>Vamos a modificar nuestro sumador para hacer eso:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb316-1"><a href="#cb316-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb316-2"><a href="#cb316-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb316-3"><a href="#cb316-3"></a></span>
<span id="cb316-4"><a href="#cb316-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span></span>
<span id="cb316-5"><a href="#cb316-5"></a><span class="op">{</span></span>
<span id="cb316-6"><a href="#cb316-6"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb316-7"><a href="#cb316-7"></a>    </span>
<span id="cb316-8"><a href="#cb316-8"></a>    <span class="co">// Bonito truco para que el compilador deje de advertir sobre la</span></span>
<span id="cb316-9"><a href="#cb316-9"></a>    <span class="co">// variable no utilizada argc:</span></span>
<span id="cb316-10"><a href="#cb316-10"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>argc<span class="op">;</span></span>
<span id="cb316-11"><a href="#cb316-11"></a></span>
<span id="cb316-12"><a href="#cb316-12"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">char</span> <span class="op">**</span>p <span class="op">=</span> argv <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">*</span>p <span class="op">!=</span> NULL<span class="op">;</span> p<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb316-13"><a href="#cb316-13"></a>        <span class="dt">int</span> value <span class="op">=</span> atoi<span class="op">(*</span>p<span class="op">);</span>  <span class="co">// Use strtol() para un mejor manejo de errores</span></span>
<span id="cb316-14"><a href="#cb316-14"></a></span>
<span id="cb316-15"><a href="#cb316-15"></a>        total <span class="op">+=</span> value<span class="op">;</span></span>
<span id="cb316-16"><a href="#cb316-16"></a>    <span class="op">}</span></span>
<span id="cb316-17"><a href="#cb316-17"></a></span>
<span id="cb316-18"><a href="#cb316-18"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> total<span class="op">);</span></span>
<span id="cb316-19"><a href="#cb316-19"></a><span class="op">}</span></span></code></pre></div>
<p>Personalmente, utilizo la notación array para acceder a <code>argv</code>, pero he visto este estilo flotando por ahí, también.</p>
<h3 data-number="18.1.3" id="datos-curiosos"><span class="header-section-number">18.1.3</span> Datos curiosos</h3>
<p></p>
<p>Algunas cosas más sobre <code>argc</code> y <code>argv</code>.</p>
<ul>
<li><p>Algunos entornos pueden no establecer <code>argv[0]</code> al nombre del programa. Si no está disponible, <code>argv[0]</code> será una cadena vacía. Nunca he visto que esto ocurra.</p></li>
<li><p>La especificación es bastante liberal con lo que una implementación puede hacer con <code>argv</code> y de dónde vienen esos valores. Pero en todos los sistemas (en los que he estado) funciona de la misma manera, como hemos discutido en esta sección.</p></li>
<li><p>Puedes modificar <code>argc</code>, <code>argv</code>, o cualquiera de las cadenas a las que apunta <code>argv</code>. (¡Sólo no hagas esas cadenas más largas de lo que ya son!)</p></li>
<li><p>En algunos sistemas tipo Unix, modificar la cadena <code>argv[0]</code> hace que la salida de <code>ps</code> cambie<a href="#fn120" class="footnote-ref" id="fnref120" role="doc-noteref"><sup>120</sup></a>.</p></li>
</ul>
<p>Normalmente, si tienes un programa llamado <code>foo</code> que has ejecutado con <code>./foo</code>,podrías ver esto en la salida de <code>ps</code>:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a> 4078 tty1     S      0:00 ./foo</span></code></pre></div>
<p>Pero si modificas <code>argv[0]</code> así, teniendo cuidado de que la nueva cadena <code>«Hi!»</code> tenga la misma longitud que la anterior <code>«. foo»</code>:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>argv<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="st">&quot;Hi!  &quot;</span><span class="op">);</span></span></code></pre></div>
<p>y luego ejecutamos <code>ps</code> mientras el programa <code>./foo</code> aún se está ejecutando, veremos esto en su lugar:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a> 4079 tty1     S      0:00 Hi!  </span></code></pre></div>
<p>Este comportamiento no está en la especificación y depende en gran medida del sistema. </p>
<h2 data-number="18.2" id="exit-status"><span class="header-section-number">18.2</span> Estado de salida</h2>
<p></p>
<p>¿Te has dado cuenta de que la firma de la función <code>main()</code> devuelve el tipo <code>int</code>? ¿A qué se debe? Tiene que ver con una cosa llamada <em>exit status</em>, que es un entero que puede ser devuelto al programa que lanzó el suyo para hacerle saber cómo fueron las cosas.</p>
<p>Ahora, hay un número de maneras en que un programa puede salir en C, incluyendo <code>return</code> desde <code>main()</code>, o llamando a una de las variantes de <code>exit()</code>.</p>
<p>Todos estos métodos aceptan un <code>int</code> como argumento. </p>
<p>Nota al margen: ¿has visto que básicamente en todos mis ejemplos, aunque se supone que <code>main()</code> debe devolver un <code>int</code>, en realidad no <code>devuelvo</code> nada? En cualquier otra función, esto sería ilegal, pero hay un caso especial en C: si la ejecución llega al final de <code>main()</code> sin encontrar un <code>return</code>, automáticamente hace un <code>return 0</code>.</p>
<p>Pero, ¿qué significa el «0»? ¿Qué otros números podemos poner ahí? ¿Y cómo se utilizan?</p>
<p>La especificación es a la vez clara e imprecisa al respecto, como suele ser habitual. Clara porque detalla lo que se puede hacer, pero vaga porque tampoco lo limita especialmente.</p>
<p>No queda más remedio que <em>seguir adelante</em> e ingeniárselas.</p>
<p>Pongámonos <a href="https://en.wikipedia.org/wiki/Inception">Inicio</a><a href="#fn121" class="footnote-ref" id="fnref121" role="doc-noteref"><sup>121</sup></a> por un segundo: resulta que cuando ejecutas tu programa, <em>lo estás ejecutando desde otro programa</em>.</p>
<p>Normalmente este otro programa es algún tipo de <a href="https://en.wikipedia.org/wiki/Shell_(computing)">shell</a><a href="#fn122" class="footnote-ref" id="fnref122" role="doc-noteref"><sup>122</sup></a> que no hace mucho por sí mismo, excepto lanzar otros programas.</p>
<p>Pero se trata de un proceso de varias fases, especialmente visible en los shells de línea de comandos:</p>
<ol type="1">
<li>El intérprete de comandos inicia el programa</li>
<li>El shell normalmente entra en reposo (para los shells de línea de comandos)</li>
<li>Su programa se ejecuta</li>
<li>Tu programa termina</li>
<li>El shell se despierta y espera otro comando</li>
</ol>
<p>Ahora, hay una pequeña pieza de comunicación que tiene lugar entre los pasos 4 y 5: el programa puede devolver un <em>valor de estado</em> que el shell puede interrogar. Típicamente, este valor se usa para indicar el éxito o fracaso de su programa, y, si es un fracaso, qué tipo de fracaso.</p>
<p>Este valor es el que hemos estado <code>devolviendo</code> desde <code>main()</code>. Ese es el estado.</p>
<p>Ahora, la especificación C permite dos valores de estado diferentes, que tienen nombres de macros definidos en <code>&lt;stdlib.h&gt;</code>: </p>
<table>
<thead>
<tr class="header">
<th>Estado</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>EXIT_SUCCESS</code> o <code>0</code></td>
<td>El programa ha finalizado correctamente.</td>
</tr>
<tr class="even">
<td><code>EXIT_FAILURE</code></td>
<td>El programa ha finalizado con un error.</td>
</tr>
</tbody>
</table>
<p>Vamos a escribir un programa corto que multiplique dos números desde la línea de comandos. Requeriremos que especifiques exactamente dos valores. Si no lo hace, vamos a imprimir un mensaje de error, y salir con un estado de error.</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb320-1"><a href="#cb320-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb320-2"><a href="#cb320-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb320-3"><a href="#cb320-3"></a></span>
<span id="cb320-4"><a href="#cb320-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span></span>
<span id="cb320-5"><a href="#cb320-5"></a><span class="op">{</span></span>
<span id="cb320-6"><a href="#cb320-6"></a>    <span class="cf">if</span> <span class="op">(</span>argc <span class="op">!=</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb320-7"><a href="#cb320-7"></a>        printf<span class="op">(</span><span class="st">&quot;usage: mult x y</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb320-8"><a href="#cb320-8"></a>        <span class="cf">return</span> EXIT_FAILURE<span class="op">;</span>   <span class="co">// Indicar al shell que no funcionó</span></span>
<span id="cb320-9"><a href="#cb320-9"></a>    <span class="op">}</span></span>
<span id="cb320-10"><a href="#cb320-10"></a></span>
<span id="cb320-11"><a href="#cb320-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> atoi<span class="op">(</span>argv<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">*</span> atoi<span class="op">(</span>argv<span class="op">[</span><span class="dv">2</span><span class="op">]));</span></span>
<span id="cb320-12"><a href="#cb320-12"></a></span>
<span id="cb320-13"><a href="#cb320-13"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// igual que EXIT_SUCCESS, todo iba bien.</span></span>
<span id="cb320-14"><a href="#cb320-14"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Ahora, si intentamos ejecutarlo, obtendremos el efecto esperado hasta que especifiquemos exactamente el número correcto de argumentos de la línea de comandos:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./mult</span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a><span class="ex">usage:</span> mult x y</span>
<span id="cb321-3"><a href="#cb321-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-4"><a href="#cb321-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./mult 3 4 5</span>
<span id="cb321-5"><a href="#cb321-5" aria-hidden="true" tabindex="-1"></a><span class="ex">usage:</span> mult x y</span>
<span id="cb321-6"><a href="#cb321-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-7"><a href="#cb321-7" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./mult 3 4</span>
<span id="cb321-8"><a href="#cb321-8" aria-hidden="true" tabindex="-1"></a><span class="ex">12</span></span></code></pre></div>
<p></p>
<p>Pero eso no muestra realmente el estado de salida que hemos devuelto, ¿verdad? Sin embargo, podemos hacer que el shell lo imprima. Asumiendo que estás ejecutando Bash u otro shell POSIX, puedes usar <code>echo $?</code> para verlo<a href="#fn123" class="footnote-ref" id="fnref123" role="doc-noteref"><sup>123</sup></a>.</p>
<p>Intentémoslo:</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./mult</span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true" tabindex="-1"></a><span class="ex">usage:</span> mult x y</span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="va">$?</span></span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true" tabindex="-1"></a><span class="ex">1</span></span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-6"><a href="#cb322-6" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./mult 3 4 5</span>
<span id="cb322-7"><a href="#cb322-7" aria-hidden="true" tabindex="-1"></a><span class="ex">usage:</span> mult x y</span>
<span id="cb322-8"><a href="#cb322-8" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="va">$?</span></span>
<span id="cb322-9"><a href="#cb322-9" aria-hidden="true" tabindex="-1"></a><span class="ex">1</span></span>
<span id="cb322-10"><a href="#cb322-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-11"><a href="#cb322-11" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./mult 3 4</span>
<span id="cb322-12"><a href="#cb322-12" aria-hidden="true" tabindex="-1"></a><span class="ex">12</span></span>
<span id="cb322-13"><a href="#cb322-13" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="va">$?</span></span>
<span id="cb322-14"><a href="#cb322-14" aria-hidden="true" tabindex="-1"></a><span class="ex">0</span></span></code></pre></div>
<p></p>
<p>¡Interesante! Vemos que en mi sistema <code>EXIT_FAILURE</code> es <code>1</code>. La especificación no lo especifica, así que podría ser cualquier número. Pero pruébalo; probablemente sea <code>1</code> en tu sistema también.</p>
<h3 data-number="18.2.1" id="otros-valores-de-estado-de-salida"><span class="header-section-number">18.2.1</span> Otros valores de estado de salida</h3>
<p>El estado <code>0</code> definitivamente significa éxito, pero ¿qué pasa con el resto de enteros, incluso los negativos?</p>
<p>Aquí nos salimos de la especificación C y nos adentramos en la tierra de Unix. En general, mientras que <code>0</code> significa éxito, un número positivo distinto de cero significa fracaso. Así que sólo puedes tener un tipo de éxito, y múltiples tipos de fallo. Bash dice que el código de salida debe estar entre 0 y 255, aunque hay una serie de códigos reservados.</p>
<p>En resumen, si quieres indicar diferentes estados de salida de error en un entorno Unix, puedes empezar con <code>1</code> e ir subiendo.</p>
<p>En Linux, si intentas cualquier código fuera del rango 0-255, el código será bitwise AND con <code>0xff</code>, sujetándolo efectivamente a ese rango.</p>
<p>Puedes programar el shell para que más tarde use estos códigos de estado para tomar decisiones sobre qué hacer a continuación. </p>
<h2 data-number="18.3" id="env-var"><span class="header-section-number">18.3</span> Variables de entorno</h2>
<p></p>
<p>Antes de entrar en materia, debo advertirte que C no especifica qué es una variable de entorno. Así que voy a describir el sistema de variables de entorno que funciona en todas las plataformas importantes que conozco.</p>
<p>Básicamente, el entorno es el programa que va a ejecutar tu programa, por ejemplo, el shell bash. Y puede tener definidas algunas variables bash. En caso de que no lo sepas, el shell puede crear sus propias variables. Cada shell es diferente, pero en bash puedes simplemente escribir <code>set</code> y te las mostrará todas.</p>
<p>Aquí hay un extracto de las 61 variables que están definidas en mi shell bash:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a>HISTFILE=/home/beej/.bash_history</span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a>HISTFILESIZE=500</span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true" tabindex="-1"></a>HISTSIZE=500</span>
<span id="cb323-4"><a href="#cb323-4" aria-hidden="true" tabindex="-1"></a>HOME=/home/beej</span>
<span id="cb323-5"><a href="#cb323-5" aria-hidden="true" tabindex="-1"></a>HOSTNAME=FBILAPTOP</span>
<span id="cb323-6"><a href="#cb323-6" aria-hidden="true" tabindex="-1"></a>HOSTTYPE=x86_64</span>
<span id="cb323-7"><a href="#cb323-7" aria-hidden="true" tabindex="-1"></a>IFS=$&#39; \t\n&#39;</span></code></pre></div>
<p>Fíjese en que están en forma de pares clave/valor. Por ejemplo, una clave es <code>HOSTTYPE</code> y su valor es <code>x86_64</code>. Desde una perspectiva C, todos los valores son cadenas, incluso si son números<a href="#fn124" class="footnote-ref" id="fnref124" role="doc-noteref"><sup>124</sup></a>.</p>
<p>Así que, ¡como quieras! Resumiendo, es posible obtener estos valores desde dentro de tu programa C.</p>
<p></p>
<p>Escribamos un programa que utilice la función estándar <code>getenv()</code> para buscar un valor que hayas establecido en el shell.</p>
<p>La función <code>getenv()</code> devolverá un puntero a la cadena de valores, o bien <code>NULL</code> si la variable de entorno no existe.</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb324-1"><a href="#cb324-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb324-2"><a href="#cb324-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb324-3"><a href="#cb324-3"></a></span>
<span id="cb324-4"><a href="#cb324-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb324-5"><a href="#cb324-5"></a><span class="op">{</span></span>
<span id="cb324-6"><a href="#cb324-6"></a>    <span class="dt">char</span> <span class="op">*</span>val <span class="op">=</span> getenv<span class="op">(</span><span class="st">&quot;FROTZ&quot;</span><span class="op">);</span>  <span class="co">// Intenta obtener el valor</span></span>
<span id="cb324-7"><a href="#cb324-7"></a></span>
<span id="cb324-8"><a href="#cb324-8"></a>    <span class="co">// Comprueba que existe</span></span>
<span id="cb324-9"><a href="#cb324-9"></a>    <span class="cf">if</span> <span class="op">(</span>val <span class="op">==</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb324-10"><a href="#cb324-10"></a>        printf<span class="op">(</span><span class="st">&quot;No se encuentra la variable de entorno FROTZ</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb324-11"><a href="#cb324-11"></a>        <span class="cf">return</span> EXIT_FAILURE<span class="op">;</span></span>
<span id="cb324-12"><a href="#cb324-12"></a>    <span class="op">}</span></span>
<span id="cb324-13"><a href="#cb324-13"></a></span>
<span id="cb324-14"><a href="#cb324-14"></a>    printf<span class="op">(</span><span class="st">&quot;Value: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> val<span class="op">);</span></span>
<span id="cb324-15"><a href="#cb324-15"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Si ejecuto esto directamente, obtengo lo siguiente:</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./foo</span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true" tabindex="-1"></a><span class="ex">No</span> se encuentra la variable de entorno FROTZ</span></code></pre></div>
<p>que tiene sentido, ya que no lo he establecido todavía.</p>
<p>En bash, puedo ponerlo a algo con<a href="#fn125" class="footnote-ref" id="fnref125" role="doc-noteref"><sup>125</sup></a>:</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> export FROTZ=<span class="st">&quot;C is awesome!&quot;</span></span></code></pre></div>
<p>Entonces si lo ejecuto, obtengo:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./foo</span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Value:</span> C is awesome!</span></code></pre></div>
<p>De este modo, puede establecer datos en variables de entorno, y puede obtenerlos en su código C y modificar su comportamiento en consecuencia.</p>
<h3 data-number="18.3.1" id="configuración-de-variables-de-entorno"><span class="header-section-number">18.3.1</span> Configuración de variables de entorno</h3>
<p>Esto no es estándar, pero muchos sistemas proporcionan formas de establecer variables de entorno.</p>
<p>Si está en un sistema tipo Unix, busque la documentación de <code>putenv()</code>, <code>setenv()</code>, y <code>unsetenv()</code>. En Windows, consulte <code>_putenv()</code>.</p>
<h3 data-number="18.3.2" id="variables-de-entorno-alternativas-a-unix"><span class="header-section-number">18.3.2</span> Variables de entorno alternativas a Unix</h3>
<p>Si estás en un sistema tipo Unix, lo más probable es que tengas otro par de formas de acceder a las variables de entorno. Tenga en cuenta que aunque la especificación señala esto como una extensión común, no es realmente parte del estándar de C. Es, sin embargo, parte del estándar POSIX. </p>
<p>Una de ellas es una variable llamada <code>environ</code> que debe declararse así:</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="dt">char</span> <span class="op">**</span>environ<span class="op">;</span></span></code></pre></div>
<p>Es un array de cadenas terminado con un puntero <code>NULL</code>.</p>
<p>Deberías declararlo tú mismo antes de usarlo, o podrías encontrarlo en el fichero de cabecera no estándar <code>&lt;unistd.h&gt;</code>.</p>
<p>Cada cadena tiene la forma <code>«clave=valor»</code>, por lo que tendrás que dividirla y analizarla tú mismo si quieres obtener las claves y los valores.</p>
<p>Aquí hay un ejemplo de un bucle e impresión de las variables de entorno de un par de maneras diferentes:</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb329-1"><a href="#cb329-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb329-2"><a href="#cb329-2"></a></span>
<span id="cb329-3"><a href="#cb329-3"></a><span class="kw">extern</span> <span class="dt">char</span> <span class="op">**</span>environ<span class="op">;</span>  <span class="co">// DEBE ser externo Y llamarse «environ».</span></span>
<span id="cb329-4"><a href="#cb329-4"></a></span>
<span id="cb329-5"><a href="#cb329-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb329-6"><a href="#cb329-6"></a><span class="op">{</span></span>
<span id="cb329-7"><a href="#cb329-7"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">char</span> <span class="op">**</span>p <span class="op">=</span> environ<span class="op">;</span> <span class="op">*</span>p <span class="op">!=</span> NULL<span class="op">;</span> p<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb329-8"><a href="#cb329-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span></span>
<span id="cb329-9"><a href="#cb329-9"></a>    <span class="op">}</span></span>
<span id="cb329-10"><a href="#cb329-10"></a></span>
<span id="cb329-11"><a href="#cb329-11"></a>    <span class="co">// O podrías hacer esto:</span></span>
<span id="cb329-12"><a href="#cb329-12"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> environ<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> NULL<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb329-13"><a href="#cb329-13"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> environ<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb329-14"><a href="#cb329-14"></a>    <span class="op">}</span></span>
<span id="cb329-15"><a href="#cb329-15"></a><span class="op">}</span></span></code></pre></div>
<p>Para un montón de salida que se parece a esto:</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a>SHELL=/bin/bash</span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a>COLORTERM=truecolor</span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a>TERM_PROGRAM_VERSION=1.53.2</span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true" tabindex="-1"></a>LOGNAME=beej</span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true" tabindex="-1"></a>HOME=/home/beej</span>
<span id="cb330-6"><a href="#cb330-6" aria-hidden="true" tabindex="-1"></a>... etc ...</span></code></pre></div>
<p>Utilice <code>getenv()</code> si es posible porque es más portable. Pero si tienes que iterar sobre variables de entorno, usar <code>environ</code> puede ser la mejor opción.</p>
<p> </p>
<p>Otra forma no estándar de obtener las variables de entorno es como parámetro de <code>main()</code>. Funciona de forma muy parecida, pero se evita tener que añadir la variable <code>environ</code> <code>extern</code>. <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html">Ni siquiera la especificación POSIX soporta esto.</a><a href="#fn126" class="footnote-ref" id="fnref126" role="doc-noteref"><sup>126</sup></a> que yo sepa, pero es común en la tierra de Unix.</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb331-1"><a href="#cb331-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb331-2"><a href="#cb331-2"></a></span>
<span id="cb331-3"><a href="#cb331-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>env<span class="op">)</span>  <span class="co">// &lt;-- env!</span></span>
<span id="cb331-4"><a href="#cb331-4"></a><span class="op">{</span></span>
<span id="cb331-5"><a href="#cb331-5"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>argc<span class="op">;</span> <span class="op">(</span><span class="dt">void</span><span class="op">)</span>argv<span class="op">;</span>  <span class="co">// Suprimir las advertencias no utilizadas</span></span>
<span id="cb331-6"><a href="#cb331-6"></a></span>
<span id="cb331-7"><a href="#cb331-7"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">char</span> <span class="op">**</span>p <span class="op">=</span> env<span class="op">;</span> <span class="op">*</span>p <span class="op">!=</span> NULL<span class="op">;</span> p<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb331-8"><a href="#cb331-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span></span>
<span id="cb331-9"><a href="#cb331-9"></a>    <span class="op">}</span></span>
<span id="cb331-10"><a href="#cb331-10"></a></span>
<span id="cb331-11"><a href="#cb331-11"></a>    <span class="co">// O podrías hacer esto:</span></span>
<span id="cb331-12"><a href="#cb331-12"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> env<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> NULL<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb331-13"><a href="#cb331-13"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> env<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb331-14"><a href="#cb331-14"></a>    <span class="op">}</span></span>
<span id="cb331-15"><a href="#cb331-15"></a><span class="op">}</span></span></code></pre></div>
<p>Es como usar <code>environ</code> pero <em>incluso menos portable</em>. Es bueno tener objetivos.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="19" id="el-preprocesador-c"><span class="header-section-number">19</span> El preprocesador C</h1>
<p></p>
<p>Antes de que el programa se compile, pasa por una fase llamada <em>preprocesamiento</em>. Es casi como si hubiera un lenguaje <em>sobre</em> el lenguaje C que se ejecuta primero. Y genera el código C, que luego se compila.</p>
<p>¡Ya hemos visto esto hasta cierto punto con <code>#include</code>! Ese es el preprocesador C. Cuando ve esa directiva, incluye el fichero nombrado allí mismo, como si lo hubieras escrito allí. Y <em>entonces</em> el compilador lo construye todo.</p>
<p>Pero resulta que es mucho más potente que simplemente poder incluir cosas. Puedes definir <em>macros</em> que son sustituidas… ¡e incluso macros que toman argumentos!</p>
<h2 data-number="19.1" id="include"><span class="header-section-number">19.1</span> <code>#include</code></h2>
<p></p>
<p>Empecemos por la que ya hemos visto muchas veces. Se trata, por supuesto, de una forma de incluir otras fuentes en tu fuente. Muy comúnmente usado con archivos de cabecera.</p>
<p>Mientras que la especificación permite todo tipo de comportamientos con <code>#include</code>, vamos a tomar un enfoque más pragmático y hablar de la forma en que funciona en todos los sistemas que he visto.</p>
<p>Podemos dividir los ficheros de cabecera en dos categorías: sistema y local. Las cosas que están integradas, como <code>stdio.h</code>, <code>stdlib.h</code>, <code>math.h</code>, etc., se pueden incluir con corchetes angulares:</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb332-2"><a href="#cb332-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span></code></pre></div>
<p>Los corchetes angulares le dicen a C: «Oye, no busques este archivo de cabecera en el directorio actual, sino en el directorio de inclusión de todo el sistema».</p>
<p></p>
<p>Lo que, por supuesto, implica que debe haber una forma de incluir archivos locales del directorio actual. Y la hay: con comillas dobles:</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;myheader.h&quot;</span></span></code></pre></div>
<p>O muy probablemente puede buscar en directorios relativos usando barras inclinadas y puntos, así:</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;mydir/myheader.h&quot;</span></span>
<span id="cb334-2"><a href="#cb334-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;../someheader.py&quot;</span></span></code></pre></div>
<p>¡No use una barra invertida (<code>\</code>) para sus separadores de ruta en su <code>#include</code>! Es un comportamiento indefinido. Utilice sólo la barra oblicua (<code>/</code>), incluso en Windows.</p>
<p>En resumen, usa corchetes angulares (<code>&lt;</code> y <code>&gt;</code>) para los includes del sistema, y usa comillas dobles (<code>"</code>) para tus includes personales.</p>
<p> </p>
<h2 data-number="19.2" id="macros-sencillas"><span class="header-section-number">19.2</span> Macros sencillas</h2>
<p></p>
<p>Un <em>macro</em> es un identificador que se <em>expande</em> a otro trozo de código antes de que el compilador lo vea. Piense en ello como un marcador de posición - cuando el preprocesador ve uno de esos identificadores, lo sustituye por otro valor que ha definido.</p>
<p></p>
<p>Lo hacemos con <code>#define</code> (a menudo se lee «pound define»). He aquí un ejemplo:</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb335-1"><a href="#cb335-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb335-2"><a href="#cb335-2"></a></span>
<span id="cb335-3"><a href="#cb335-3"></a><span class="pp">#define HELLO </span><span class="st">&quot;Hello, world&quot;</span></span>
<span id="cb335-4"><a href="#cb335-4"></a><span class="pp">#define PI </span><span class="fl">3.14159</span></span>
<span id="cb335-5"><a href="#cb335-5"></a></span>
<span id="cb335-6"><a href="#cb335-6"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb335-7"><a href="#cb335-7"></a><span class="op">{</span></span>
<span id="cb335-8"><a href="#cb335-8"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">, </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> HELLO<span class="op">,</span> PI<span class="op">);</span></span>
<span id="cb335-9"><a href="#cb335-9"></a><span class="op">}</span></span></code></pre></div>
<p>En las líneas 3 y 4 definimos un par de macros. Dondequiera que aparezcan en el código (línea 8), serán sustituidas por los valores definidos.</p>
<p>Desde la perspectiva del compilador de C, es exactamente como si hubiéramos escrito esto, en su lugar:</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb336-1"><a href="#cb336-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb336-2"><a href="#cb336-2"></a></span>
<span id="cb336-3"><a href="#cb336-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb336-4"><a href="#cb336-4"></a><span class="op">{</span></span>
<span id="cb336-5"><a href="#cb336-5"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">, </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;Hello, world&quot;</span><span class="op">,</span> <span class="fl">3.14159</span><span class="op">);</span></span>
<span id="cb336-6"><a href="#cb336-6"></a><span class="op">}</span></span></code></pre></div>
<p>¿Ve cómo <code>HELLO</code> ha sido sustituido por <code>«Hola, mundo»</code> y <code>PI</code> por <code>3,14159</code>? Desde la perspectiva del compilador, es como si esos valores hubieran “aparecido” en el código.</p>
<p>Tenga en cuenta que las macros no tienen un tipo específico, <em>per se</em>. Realmente todo lo que ocurre es que son reemplazadas al por mayor por lo que sea que estén <code>#definidas</code>. Si el código C resultante no es válido, el compilador vomitará.</p>
<p>También puedes definir una macro sin valor:</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define EXTRA_HAPPY</span></span></code></pre></div>
<p>en ese caso, la macro existe y está definida, pero está definida para no ser nada. Así que en cualquier lugar que aparezca en el texto será reemplazada por nada. Veremos un uso para esto más adelante.</p>
<p>Es convencional escribir los nombres de las macros en <code>ALL_CAPS</code> aunque técnicamente no sea necesario.</p>
<p></p>
<p>En general, esto le da una manera de definir valores constantes que son efectivamente globales y se pueden utilizar en cualquier lugar. Incluso en aquellos lugares donde una variable <code>const</code> no funcionaría, por ejemplo en <code>switch</code> <code>case</code>s y longitudes de array fijas.</p>
<p>Dicho esto, se debate en la red si una variable <code>const</code> tipada es mejor que la macro <code>#define</code> en el caso general.</p>
<p>También puede usarse para reemplazar o modificar palabras clave, un concepto completamente ajeno a <code>const</code>, aunque esta práctica debería usarse con moderación.</p>
<p> </p>
<h2 data-number="19.3" id="compilación-condicional"><span class="header-section-number">19.3</span> Compilación condicional</h2>
<p></p>
<p>Es posible hacer que el preprocesador decida si presentar o no ciertos bloques de código al compilador, o simplemente eliminarlos por completo antes de la compilación.</p>
<p>Para ello, básicamente envolvemos el código en bloques condicionales, similares a las sentencias <code>if</code>-<code>else</code>.</p>
<h3 data-number="19.3.1" id="si-está-definido-ifdef-y-endif."><span class="header-section-number">19.3.1</span> Si está definido, <code>#ifdef</code> y <code>#endif</code>.</h3>
<p>En primer lugar, vamos a intentar compilar código específico dependiendo de si una macro está o no definida.</p>
<p> </p>
<div class="sourceCode" id="cb338"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb338-1"><a href="#cb338-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb338-2"><a href="#cb338-2"></a></span>
<span id="cb338-3"><a href="#cb338-3"></a><span class="pp">#define EXTRA_HAPPY</span></span>
<span id="cb338-4"><a href="#cb338-4"></a></span>
<span id="cb338-5"><a href="#cb338-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb338-6"><a href="#cb338-6"></a><span class="op">{</span></span>
<span id="cb338-7"><a href="#cb338-7"></a></span>
<span id="cb338-8"><a href="#cb338-8"></a><span class="pp">#ifdef EXTRA_HAPPY</span></span>
<span id="cb338-9"><a href="#cb338-9"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m extra happy!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb338-10"><a href="#cb338-10"></a><span class="pp">#endif</span></span>
<span id="cb338-11"><a href="#cb338-11"></a></span>
<span id="cb338-12"><a href="#cb338-12"></a>    printf<span class="op">(</span><span class="st">&quot;OK!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb338-13"><a href="#cb338-13"></a><span class="op">}</span></span></code></pre></div>
<p>En ese ejemplo, definimos <code>EXTRA_HAPPY</code> (para que no sea nada, pero <em>está</em> definido), luego en la línea 8 comprobamos si está definido con una directiva <code>#ifdef</code>. Si está definida, el código subsiguiente se incluirá hasta el <code>#endif</code>.</p>
<p> </p>
<p>Por lo tanto, al estar definido, el código se incluirá para la compilación y la salida será:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a>I&#39;m extra happy!</span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true" tabindex="-1"></a>OK!</span></code></pre></div>
<p>Si comentáramos el <code>#define</code>, así:</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a><span class="co">//#define EXTRA_HAPPY</span></span></code></pre></div>
<p>entonces no se definiría, y el código no se incluiría en la compilación. Y la salida sería simplemente:</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a>OK!</span></code></pre></div>
<p>Es importante recordar que estas decisiones se toman en tiempo de compilación. El código se compila o elimina dependiendo de la condición. Esto contrasta con una sentencia <code>if</code> estándar que se evalúa mientras el programa se está ejecutando.</p>
<h3 data-number="19.3.2" id="si-no-está-definido-ifndef."><span class="header-section-number">19.3.2</span> Si no está definido, <code>#ifndef</code>.</h3>
<p>También existe el sentido negativo de «si se define»: «si no está definido», o <code>#ifndef</code>. Podríamos cambiar el ejemplo anterior para que salieran cosas diferentes en función de si algo estaba definido o no:</p>
<p> </p>
<div class="sourceCode" id="cb342" data-startFrom="8"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 7;"><span id="cb342-8"><a href="#cb342-8"></a><span class="pp">#ifdef EXTRA_HAPPY</span></span>
<span id="cb342-9"><a href="#cb342-9"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m extra happy!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb342-10"><a href="#cb342-10"></a><span class="pp">#endif</span></span>
<span id="cb342-11"><a href="#cb342-11"></a></span>
<span id="cb342-12"><a href="#cb342-12"></a><span class="pp">#ifndef EXTRA_HAPPY</span></span>
<span id="cb342-13"><a href="#cb342-13"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m just regular</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb342-14"><a href="#cb342-14"></a><span class="pp">#endif</span></span></code></pre></div>
<p>Veremos una forma más limpia de hacerlo en la siguiente sección.</p>
<p>Volviendo a los archivos de cabecera, hemos visto cómo podemos hacer que los archivos de cabecera sólo se incluyan una vez envolviéndolos en directivas de preprocesador como esta:</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef MYHEADER_H  </span><span class="co">// Primera línea de myheader.h</span></span>
<span id="cb343-2"><a href="#cb343-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MYHEADER_H</span></span>
<span id="cb343-3"><a href="#cb343-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-4"><a href="#cb343-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb343-5"><a href="#cb343-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-6"><a href="#cb343-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif  </span><span class="co">// Última línea de myheader.h</span></span></code></pre></div>
<p> </p>
<p>Esto demuestra cómo una macro persiste a través de archivos y múltiples <code>#include</code>s. Si aún no está definida, definámosla y compilemos todo el fichero de cabecera.</p>
<p>Pero la próxima vez que se incluya, vemos que <code>MYHEADER_H</code> <em>está</em> definida, así que no enviamos el fichero de cabecera al compilador— se elimina efectivamente.</p>
<h3 data-number="19.3.3" id="else"><span class="header-section-number">19.3.3</span> <code>#else</code></h3>
<p></p>
<p>Pero eso no es todo lo que podemos hacer. También podemos añadir un `#else.</p>
<p> </p>
<p>Modifiquemos el ejemplo anterior:</p>
<div class="sourceCode" id="cb344" data-startFrom="8"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 7;"><span id="cb344-8"><a href="#cb344-8"></a><span class="pp">#ifdef EXTRA_HAPPY</span></span>
<span id="cb344-9"><a href="#cb344-9"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m extra happy!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb344-10"><a href="#cb344-10"></a><span class="pp">#else</span></span>
<span id="cb344-11"><a href="#cb344-11"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m just regular</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb344-12"><a href="#cb344-12"></a><span class="pp">#endif</span></span></code></pre></div>
<p> </p>
<p>Ahora, si <code>EXTRA_HAPPY</code> no está definido, entrará en la cláusula <code>#else</code> e imprimirá:</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a>I&#39;m just regular</span></code></pre></div>
<h3 data-number="19.3.4" id="else-if-elifdef-elifndef"><span class="header-section-number">19.3.4</span> Else-If: <code>#elifdef</code>, <code>#elifndef</code></h3>
<p> </p>
<p>Esta función es nueva en C23.</p>
<p>¿Y si quiere algo más complejo? ¿Quizás necesitas una estructura en cascada if-else para que tu código se construya correctamente?</p>
<p>Por suerte tenemos estas directivas a nuestra disposición. Podemos usar <code>#elifdef</code> para «definir else if»:</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef MODE_1</span></span>
<span id="cb346-2"><a href="#cb346-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This is mode 1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb346-3"><a href="#cb346-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#elifdef MODE_2</span></span>
<span id="cb346-4"><a href="#cb346-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This is mode 2</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb346-5"><a href="#cb346-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#elifdef MODE_3</span></span>
<span id="cb346-6"><a href="#cb346-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This is mode 3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb346-7"><a href="#cb346-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb346-8"><a href="#cb346-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This is some other mode</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb346-9"><a href="#cb346-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p></p>
<p>Por otro lado, puede utilizar <code>#elifndef</code> para «else if not defined».</p>
<p></p>
<h3 data-number="19.3.5" id="condicional-general-if-elif"><span class="header-section-number">19.3.5</span> Condicional general: <code>#if</code>, <code>#elif</code></h3>
<p> </p>
<p>Funciona de forma muy parecida a las directivas <code>#ifdef</code> y <code>#ifndef</code> en el sentido de que también puede tener un <code>#else</code> y todo termina con <code>#endif</code>.</p>
<p>La única diferencia es que la expresión constante después de <code>#if</code> debe evaluarse a verdadero (distinto de cero) para que el código en <code>#if</code> sea compilado. Así que en lugar de si algo está definido o no, queremos una expresión que se evalúe como verdadera.</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb347-1"><a href="#cb347-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb347-2"><a href="#cb347-2"></a></span>
<span id="cb347-3"><a href="#cb347-3"></a><span class="pp">#define HAPPY_FACTOR </span><span class="dv">1</span></span>
<span id="cb347-4"><a href="#cb347-4"></a></span>
<span id="cb347-5"><a href="#cb347-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb347-6"><a href="#cb347-6"></a><span class="op">{</span></span>
<span id="cb347-7"><a href="#cb347-7"></a></span>
<span id="cb347-8"><a href="#cb347-8"></a><span class="pp">#if HAPPY_FACTOR == 0</span></span>
<span id="cb347-9"><a href="#cb347-9"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m not happy!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb347-10"><a href="#cb347-10"></a><span class="pp">#elif HAPPY_FACTOR == 1</span></span>
<span id="cb347-11"><a href="#cb347-11"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m just regular</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb347-12"><a href="#cb347-12"></a><span class="pp">#else</span></span>
<span id="cb347-13"><a href="#cb347-13"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m extra happy!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb347-14"><a href="#cb347-14"></a><span class="pp">#endif</span></span>
<span id="cb347-15"><a href="#cb347-15"></a></span>
<span id="cb347-16"><a href="#cb347-16"></a>    printf<span class="op">(</span><span class="st">&quot;OK!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb347-17"><a href="#cb347-17"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>De nuevo, para las cláusulas <code>#if</code> no emparejadas, el compilador ni siquiera verá esas líneas. Para el código anterior, después de que el preprocesador haya terminado con él, todo lo que el compilador ve es:</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb348-1"><a href="#cb348-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb348-2"><a href="#cb348-2"></a></span>
<span id="cb348-3"><a href="#cb348-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb348-4"><a href="#cb348-4"></a><span class="op">{</span></span>
<span id="cb348-5"><a href="#cb348-5"></a></span>
<span id="cb348-6"><a href="#cb348-6"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m just regular</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb348-7"><a href="#cb348-7"></a></span>
<span id="cb348-8"><a href="#cb348-8"></a>    printf<span class="op">(</span><span class="st">&quot;OK!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb348-9"><a href="#cb348-9"></a><span class="op">}</span></span></code></pre></div>
<p>Un truco que se utiliza es comentar un gran número de líneas rápidamente <a href="#fn127" class="footnote-ref" id="fnref127" role="doc-noteref"><sup>127</sup></a>.</p>
<p></p>
<p>Si pones un <code>#if 0</code> («si false») al principio del bloque a comentar y un <code>#endif</code> al final, puedes conseguir este efecto:</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if 0</span></span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true" tabindex="-1"></a><span class="co">    printf(«Todo este código»); /* está efectivamente */</span></span>
<span id="cb349-3"><a href="#cb349-3" aria-hidden="true" tabindex="-1"></a><span class="co">    printf(«comentado»); // por el #if 0</span></span>
<span id="cb349-4"><a href="#cb349-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p></p>
<p>¿Qué pasa si estás en un compilador pre-C23 y no tienes soporte para las directivas <code>#elifdef</code> o <code>#elifndef</code>? ¿Cómo podemos conseguir el mismo efecto con <code>#if</code>? Es decir, qué pasaría si quisiera esto</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef FOO</span></span>
<span id="cb350-2"><a href="#cb350-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb350-3"><a href="#cb350-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#elifdef BAR  </span><span class="co">// ERROR POTENCIAL: No soportado antes de C23</span></span>
<span id="cb350-4"><a href="#cb350-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb350-5"><a href="#cb350-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p>¿Cómo podría hacerlo?</p>
<p>Resulta que hay un operador de preprocesador llamado <code>defined</code> que podemos usar con una sentencia <code>#if</code>.</p>
<p>Son equivalentes:</p>
<p></p>
<div class="sourceCode" id="cb351"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef FOO</span></span>
<span id="cb351-2"><a href="#cb351-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined FOO</span></span>
<span id="cb351-3"><a href="#cb351-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined(FOO)   </span><span class="co">// Paréntesis opcional</span></span></code></pre></div>
<p>Como estos:</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef FOO</span></span>
<span id="cb352-2"><a href="#cb352-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#if !defined FOO</span></span>
<span id="cb352-3"><a href="#cb352-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#if !defined(FOO)   </span><span class="co">// Paréntesis opcional</span></span></code></pre></div>
<p>Observe que podemos utilizar el operador lógico estándar NOT (<code>!</code>) para «no definido».</p>
<p>¡Así que ahora estamos de vuelta en la tierra de <code>#if</code> y podemos usar <code>#elif</code> impunemente!</p>
<p>Este código roto:</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef FOO</span></span>
<span id="cb353-2"><a href="#cb353-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb353-3"><a href="#cb353-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#elifdef BAR  </span><span class="co">// ERROR POTENCIAL: No soportado antes de C23</span></span>
<span id="cb353-4"><a href="#cb353-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb353-5"><a href="#cb353-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p>puede sustituirse por:</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined FOO</span></span>
<span id="cb354-2"><a href="#cb354-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb354-3"><a href="#cb354-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#elif defined BAR</span></span>
<span id="cb354-4"><a href="#cb354-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb354-5"><a href="#cb354-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p> </p>
<h3 data-number="19.3.6" id="perder-una-macro-undef"><span class="header-section-number">19.3.6</span> Perder una macro: <code>#undef</code></h3>
<p></p>
<p>Si has definido algo pero ya no lo necesitas, puedes redefinirlo con <code>#undef</code>.</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb355-1"><a href="#cb355-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb355-2"><a href="#cb355-2"></a></span>
<span id="cb355-3"><a href="#cb355-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb355-4"><a href="#cb355-4"></a><span class="op">{</span></span>
<span id="cb355-5"><a href="#cb355-5"></a><span class="pp">#define GOATS</span></span>
<span id="cb355-6"><a href="#cb355-6"></a></span>
<span id="cb355-7"><a href="#cb355-7"></a><span class="pp">#ifdef GOATS</span></span>
<span id="cb355-8"><a href="#cb355-8"></a>    printf<span class="op">(</span><span class="st">&quot;Goats detected!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// Imprime</span></span>
<span id="cb355-9"><a href="#cb355-9"></a><span class="pp">#endif</span></span>
<span id="cb355-10"><a href="#cb355-10"></a></span>
<span id="cb355-11"><a href="#cb355-11"></a><span class="pp">#undef GOATS  </span><span class="co">// Hacer que GOATS ya no esté definido</span></span>
<span id="cb355-12"><a href="#cb355-12"></a></span>
<span id="cb355-13"><a href="#cb355-13"></a><span class="pp">#ifdef GOATS</span></span>
<span id="cb355-14"><a href="#cb355-14"></a>    printf<span class="op">(</span><span class="st">&quot;Goats detected, again!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="co">// no imprime</span></span>
<span id="cb355-15"><a href="#cb355-15"></a><span class="pp">#endif</span></span>
<span id="cb355-16"><a href="#cb355-16"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h2 data-number="19.4" id="macros-integradas"><span class="header-section-number">19.4</span> Macros integradas</h2>
<p></p>
<p>El estándar define un montón de macros incorporadas que puedes probar y utilizar para la compilación condicional. Veámoslas aquí.</p>
<h3 data-number="19.4.1" id="macros-obligatorias"><span class="header-section-number">19.4.1</span> Macros obligatorias</h3>
<p>Todos ellos están definidos:</p>
<p> </p>
<p> </p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>Macro</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__DATE__</code></td>
<td>La fecha de compilación –como cuando está compilando este archivo– en formato <code>Mmm dd yyyy</code></td>
</tr>
<tr class="even">
<td><code>__TIME__</code></td>
<td>La hora de compilación en formato <code>hh:mm:ss</code>.</td>
</tr>
<tr class="odd">
<td><code>__FILE__</code></td>
<td>Una cadena que contiene el nombre de este archivo</td>
</tr>
<tr class="even">
<td><code>__LINE__</code></td>
<td>El número de línea del archivo en el que aparece esta macro</td>
</tr>
<tr class="odd">
<td><code>__func__</code></td>
<td>El nombre de la función en la que aparece, como una cadena<a href="#fn128" class="footnote-ref" id="fnref128" role="doc-noteref"><sup>128</sup></a>.</td>
</tr>
<tr class="even">
<td><code>__STDC__</code></td>
<td>Definido con <code>1</code> si se trata de un compilador C estándar</td>
</tr>
<tr class="odd">
<td><code>__STDC_HOSTED__</code></td>
<td>Será <code>1</code> si el compilador es una <em>implementación hospedada</em><a href="#fn129" class="footnote-ref" id="fnref129" role="doc-noteref"><sup>129</sup></a>, en caso contrario <code>0</code>.</td>
</tr>
<tr class="even">
<td><code>__STDC_VERSION__</code></td>
<td>Esta versión de C, una constante <code>long int</code> de la forma <code>yyyymmL</code>, por ejemplo <code>201710L</code>.</td>
</tr>
</tbody>
</table>
<p>Pongámoslos juntos.</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb356-1"><a href="#cb356-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb356-2"><a href="#cb356-2"></a></span>
<span id="cb356-3"><a href="#cb356-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb356-4"><a href="#cb356-4"></a><span class="op">{</span></span>
<span id="cb356-5"><a href="#cb356-5"></a>    printf<span class="op">(</span><span class="st">&quot;Esta función: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> __func__<span class="op">);</span></span>
<span id="cb356-6"><a href="#cb356-6"></a>    printf<span class="op">(</span><span class="st">&quot;Este archivo </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> __FILE__<span class="op">);</span></span>
<span id="cb356-7"><a href="#cb356-7"></a>    printf<span class="op">(</span><span class="st">&quot;Esta linea: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> __LINE__<span class="op">);</span></span>
<span id="cb356-8"><a href="#cb356-8"></a>    printf<span class="op">(</span><span class="st">&quot;Compilado en: </span><span class="sc">%s</span><span class="st"> </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> __DATE__<span class="op">,</span> __TIME__<span class="op">);</span></span>
<span id="cb356-9"><a href="#cb356-9"></a>    printf<span class="op">(</span><span class="st">&quot;Versión de C: </span><span class="sc">%ld\n</span><span class="st">&quot;</span><span class="op">,</span> __STDC_VERSION__<span class="op">);</span></span>
<span id="cb356-10"><a href="#cb356-10"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>La salida en mi sistema es:</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true" tabindex="-1"></a>Esta función: main</span>
<span id="cb357-2"><a href="#cb357-2" aria-hidden="true" tabindex="-1"></a>Este archivo: foo.c</span>
<span id="cb357-3"><a href="#cb357-3" aria-hidden="true" tabindex="-1"></a>Esta linea: 7</span>
<span id="cb357-4"><a href="#cb357-4" aria-hidden="true" tabindex="-1"></a>Compilado en: Nov 23 2020 17:16:27</span>
<span id="cb357-5"><a href="#cb357-5" aria-hidden="true" tabindex="-1"></a>Versión de C : 201710</span></code></pre></div>
<p><code>__FILE__</code>, <code>__func__</code> y <code>__LINE__</code> son particularmente útiles para informar de condiciones de error en mensajes a los desarrolladores. La macro <code>assert()</code> de <code>&lt;assert.h&gt;</code> las utiliza para indicar en qué parte del código ha fallado la aserción.</p>
<p> </p>
<h4 data-number="19.4.1.1" id="stdc_version__s"><span class="header-section-number">19.4.1.1</span> <code>__STDC_VERSION__</code>s</h4>
<p></p>
<p>Por si te lo estás preguntando, aquí tienes los números de versión de las distintas versiones principales de la especificación del lenguaje C:</p>
<table>
<thead>
<tr class="header">
<th>Release</th>
<th>ISO/IEC version</th>
<th><code>__STDC_VERSION__</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C89</td>
<td>ISO/IEC 9899:1990</td>
<td>undefined</td>
</tr>
<tr class="even">
<td><strong>C89</strong></td>
<td>ISO/IEC 9899:1990/Amd.1:1995</td>
<td><code>199409L</code></td>
</tr>
<tr class="odd">
<td><strong>C99</strong></td>
<td>ISO/IEC 9899:1999</td>
<td><code>199901L</code></td>
</tr>
<tr class="even">
<td><strong>C11</strong></td>
<td>ISO/IEC 9899:2011/Amd.1:2012</td>
<td><code>201112L</code></td>
</tr>
</tbody>
</table>
<p>Tenga en cuenta que la macro no existía originalmente en C89.</p>
<p>También ten en cuenta que la idea es que los números de versión aumenten de manera estricta, así que siempre podrías verificar, por ejemplo, ‘al menos C99’ con:</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb358-1"><a href="#cb358-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if __STDC_VERSION__ &gt;= 1999901L</span></span></code></pre></div>
<p> </p>
<h3 data-number="19.4.2" id="macros-opcionales"><span class="header-section-number">19.4.2</span> Macros opcionales</h3>
<p>Es posible que su aplicación también los defina. O puede que no.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>Macro</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__STDC_ISO_10646__</code></td>
<td>Si está definido, <code>wchar_t</code> contiene valores Unicode, si no, otra cosa</td>
</tr>
<tr class="even">
<td><code>__STDC_MB_MIGHT_NEQ_WC__</code></td>
<td>Un “1” indica que los valores en caracteres multibyte pueden no corresponderse con los valores en caracteres anchos.</td>
</tr>
<tr class="odd">
<td><code>__STDC_UTF_16__</code></td>
<td>Un <code>1</code> indica que el sistema utiliza la codificación UTF-16 en el tipo <code>char16_t</code>.</td>
</tr>
<tr class="even">
<td><code>__STDC_UTF_32__</code></td>
<td>A <code>1</code> indicates that the system uses UTF-32 encoding in type <code>char32_t</code></td>
</tr>
<tr class="odd">
<td><code>__STDC_ANALYZABLE__</code></td>
<td>Un <code>1</code> indica que el código es analizable<a href="#fn130" class="footnote-ref" id="fnref130" role="doc-noteref"><sup>130</sup></a>.</td>
</tr>
<tr class="even">
<td><code>__STDC_IEC_559__</code></td>
<td><code>1</code> if IEEE-754 (aka IEC 60559) floating point is supported</td>
</tr>
<tr class="odd">
<td><code>__STDC_IEC_559_COMPLEX__</code></td>
<td><code>1</code> si se admite la coma flotante compleja IEC 60559</td>
</tr>
<tr class="even">
<td><code>__STDC_LIB_EXT1__</code></td>
<td><code>1</code> si esta implementación admite una serie de funciones de</td>
</tr>
<tr class="odd">
<td>biblioteca estándar alternativas “seguras” (tienen sufijos <code>_s</code> en el nombre)</td>
<td></td>
</tr>
<tr class="even">
<td><code>__STDC_NO_ATOMICS__</code></td>
<td><code>1</code> si esta implementación <strong>no</strong> soporta <code>_Atomic</code> o <code>&lt;stdatomic.h&gt;</code>.</td>
</tr>
<tr class="odd">
<td><code>__STDC_NO_COMPLEX__</code></td>
<td><code>1</code> si esta implementación <strong>no</strong> soporta tipos complejos o <code>&lt;complex.h&gt;</code>.</td>
</tr>
<tr class="even">
<td><code>__STDC_NO_THREADS__</code></td>
<td><code>1</code> si esta implementación <strong>no</strong> es compatible con <code>&lt;threads.h&gt;</code>.</td>
</tr>
<tr class="odd">
<td><code>__STDC_NO_VLA__</code></td>
<td><code>1</code> si esta implementación <strong>no</strong> admite matrices de longitud variable</td>
</tr>
</tbody>
</table>
<p></p>
<h2 data-number="19.5" id="macros-con-argumentos"><span class="header-section-number">19.5</span> Macros con argumentos</h2>
<p></p>
<p>Sin embargo, las macros son más potentes que una simple sustitución. También puede configurarlas para que acepten argumentos que sean sustituidos.</p>
<p>A menudo surge la pregunta de cuándo utilizar macros parametrizadas frente a funciones. Respuesta corta: usa funciones. Pero verás muchas macros en la naturaleza y en la biblioteca estándar. La gente tiende a usarlas para cosas cortas y matemáticas, y también para características que pueden cambiar de plataforma a plataforma. Puedes definir diferentes palabras clave para una plataforma u otra.</p>
<h3 data-number="19.5.1" id="macros-con-un-argumento"><span class="header-section-number">19.5.1</span> Macros con un argumento</h3>
<p>Empecemos con uno sencillo que eleva un número al cuadrado:</p>
<p></p>
<div class="sourceCode" id="cb359"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb359-1"><a href="#cb359-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb359-2"><a href="#cb359-2"></a></span>
<span id="cb359-3"><a href="#cb359-3"></a><span class="pp">#define SQR</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> x </span><span class="op">*</span><span class="pp"> x  </span><span class="co">// No es del todo correcto, pero ten paciencia conmigo</span></span>
<span id="cb359-4"><a href="#cb359-4"></a></span>
<span id="cb359-5"><a href="#cb359-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb359-6"><a href="#cb359-6"></a><span class="op">{</span></span>
<span id="cb359-7"><a href="#cb359-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> SQR<span class="op">(</span><span class="dv">12</span><span class="op">));</span>  <span class="co">// 144</span></span>
<span id="cb359-8"><a href="#cb359-8"></a><span class="op">}</span></span></code></pre></div>
<p>Lo que está diciendo es “dondequiera que veas <code>SQR</code> con algún valor, reemplázalo con ese valor multiplicado por sí mismo”.</p>
<p>Así que la línea 7 se cambiará a:</p>
<div class="sourceCode" id="cb360" data-startFrom="7"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 6;"><span id="cb360-7"><a href="#cb360-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">12</span> <span class="op">*</span> <span class="dv">12</span><span class="op">);</span>  <span class="co">// 144</span></span></code></pre></div>
<p>que C convierte cómodamente en 144.</p>
<p>Pero en esa macro hemos cometido un error elemental que debemos evitar.</p>
<p>Vamos a comprobarlo. ¿Y si quisiéramos calcular <code>SQR(3 + 4)</code>? Bueno, <span class="math inline">\(3+4=7\)</span>, así que debemos querer calcular <span class="math inline">\(7^2=49\)</span>. Eso es; <code>49</code>—respuesta final.</p>
<p>Pongámoslo en nuestro código y veremos que obtenemos… 19?</p>
<div class="sourceCode" id="cb361" data-startFrom="7"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 6;"><span id="cb361-7"><a href="#cb361-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> SQR<span class="op">(</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span><span class="op">));</span>  <span class="co">// 19!!??</span></span></code></pre></div>
<p>¿Qué ha pasado?</p>
<p>Si seguimos la macro expansión, obtenemos</p>
<div class="sourceCode" id="cb362" data-startFrom="7"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 6;"><span id="cb362-7"><a href="#cb362-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span><span class="op">);</span>  <span class="co">// 19!</span></span></code></pre></div>
<p>¡Uy! Como la multiplicación tiene prioridad, hacemos primero <span class="math inline">\(4+3=12\)</span> y obtenemos <span class="math inline">\(3+12+4=19\)</span>. No es lo que buscábamos.</p>
<p>Así que tenemos que arreglar esto para hacerlo bien.</p>
<p><strong>Esto es tan común que deberías hacerlo automáticamente cada vez que hagas una macro matemática parametrizada.</strong></p>
<p>La solución es fácil: ¡sólo tienes que añadir algunos paréntesis!</p>
<div class="sourceCode" id="cb363" data-startFrom="3"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 2;"><span id="cb363-3"><a href="#cb363-3"></a><span class="pp">#define SQR</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">   </span><span class="co">// Mejor... ¡pero aún no lo suficiente!</span></span></code></pre></div>
<p>Y ahora nuestra macro se expande a:</p>
<div class="sourceCode" id="cb364" data-startFrom="7"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 6;"><span id="cb364-7"><a href="#cb364-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span><span class="op">));</span>  <span class="co">// 49! Woo hoo!</span></span></code></pre></div>
<p>Pero en realidad seguimos teniendo el mismo problema que podría manifestarse si tenemos cerca un operador de mayor precedencia que multiplicar (<code>*</code>).</p>
<p>Así que la forma segura y adecuada de armar la macro es envolver todo entre paréntesis adicionales, así:</p>
<div class="sourceCode" id="cb365" data-startFrom="3"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 2;"><span id="cb365-3"><a href="#cb365-3"></a><span class="pp">#define SQR</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">x</span><span class="op">))</span><span class="pp">   </span><span class="co">// Perfecto!</span></span></code></pre></div>
<p>Acostúmbrate a hacerlo cuando hagas una macro matemática y no te equivocarás.</p>
<h3 data-number="19.5.2" id="macros-con-más-de-un-argumento"><span class="header-section-number">19.5.2</span> Macros con más de un argumento</h3>
<p>Puedes apilar estas cosas tanto como quieras:</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TRIANGLE_AREA</span><span class="op">(</span><span class="pp">w</span><span class="op">,</span><span class="pp"> h</span><span class="op">)</span><span class="pp"> </span><span class="op">(</span><span class="dv">0</span><span class="er">.5</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">w</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">h</span><span class="op">))</span></span></code></pre></div>
<p>Vamos a hacer unas macros que resuelven para <span class="math inline">\(x\)</span> usando la fórmula cuadrática. Por si acaso no la tienes en la cabeza, dice que para ecuaciones de la forma:</p>
<p><span class="math inline">\(ax^2+bx+c=0\)</span></p>
<p>puedes resolver <span class="math inline">\(x\)</span> con la fórmula cuadrática:</p>
<p><span class="math inline">\(x=\displaystyle\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)</span></p>
<p>Lo cual es una locura. También observe el más-o-menos (<span class="math inline">\(\pm\)</span>) allí, lo que indica que en realidad hay dos soluciones.</p>
<p>Así que vamos a hacer macros para ambos:</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define QUADP</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">)</span><span class="pp"> </span><span class="op">((-(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">+</span><span class="pp"> sqrt</span><span class="op">((</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">-</span><span class="pp"> </span><span class="dv">4</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">c</span><span class="op">)))</span><span class="pp"> </span><span class="op">/</span><span class="pp"> </span><span class="op">(</span><span class="dv">2</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)))</span></span>
<span id="cb367-2"><a href="#cb367-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define QUADM</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">)</span><span class="pp"> </span><span class="op">((-(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">-</span><span class="pp"> sqrt</span><span class="op">((</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">-</span><span class="pp"> </span><span class="dv">4</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">c</span><span class="op">)))</span><span class="pp"> </span><span class="op">/</span><span class="pp"> </span><span class="op">(</span><span class="dv">2</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)))</span></span></code></pre></div>
<p>Así que eso nos da algunas matemáticas. Pero vamos a definir una más que podemos utilizar como argumentos a <code>printf()</code> para imprimir ambas respuestas.</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true" tabindex="-1"></a><span class="co">//          macro           se reemplaza por</span></span>
<span id="cb368-2"><a href="#cb368-2" aria-hidden="true" tabindex="-1"></a><span class="co">//      |-----------| |----------------------------|</span></span>
<span id="cb368-3"><a href="#cb368-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define QUAD</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">)</span><span class="pp"> QUADP</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">),</span><span class="pp"> QUADM</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">)</span></span></code></pre></div>
<p>Eso es sólo un par de valores separados por una coma - y podemos usar eso como un argumento “combinado” de clases a <code>printf()</code> como esto:</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;x = </span><span class="sc">%f</span><span class="st"> or x = </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> QUAD<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">5</span><span class="op">));</span></span></code></pre></div>
<p>Pongámoslo junto en algún código:</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb370-1"><a href="#cb370-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb370-2"><a href="#cb370-2"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span><span class="pp">  </span><span class="co">// Para sqrt()</span></span>
<span id="cb370-3"><a href="#cb370-3"></a></span>
<span id="cb370-4"><a href="#cb370-4"></a><span class="pp">#define QUADP</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">)</span><span class="pp"> </span><span class="op">((-(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">+</span><span class="pp"> sqrt</span><span class="op">((</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">-</span><span class="pp"> </span><span class="dv">4</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">c</span><span class="op">)))</span><span class="pp"> </span><span class="op">/</span><span class="pp"> </span><span class="op">(</span><span class="dv">2</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)))</span></span>
<span id="cb370-5"><a href="#cb370-5"></a><span class="pp">#define QUADM</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">)</span><span class="pp"> </span><span class="op">((-(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">-</span><span class="pp"> sqrt</span><span class="op">((</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">-</span><span class="pp"> </span><span class="dv">4</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">c</span><span class="op">)))</span><span class="pp"> </span><span class="op">/</span><span class="pp"> </span><span class="op">(</span><span class="dv">2</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)))</span></span>
<span id="cb370-6"><a href="#cb370-6"></a><span class="pp">#define QUAD</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">)</span><span class="pp"> QUADP</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">),</span><span class="pp"> QUADM</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> c</span><span class="op">)</span></span>
<span id="cb370-7"><a href="#cb370-7"></a></span>
<span id="cb370-8"><a href="#cb370-8"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb370-9"><a href="#cb370-9"></a><span class="op">{</span></span>
<span id="cb370-10"><a href="#cb370-10"></a>    printf<span class="op">(</span><span class="st">&quot;2*x^2 + 10*x + 5 = 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb370-11"><a href="#cb370-11"></a>    printf<span class="op">(</span><span class="st">&quot;x = </span><span class="sc">%f</span><span class="st"> or x = </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> QUAD<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">5</span><span class="op">));</span></span>
<span id="cb370-12"><a href="#cb370-12"></a><span class="op">}</span></span></code></pre></div>
<p>Y esto nos da la salida:</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true" tabindex="-1"></a>2*x^2 + 10*x + 5 = 0</span>
<span id="cb371-2"><a href="#cb371-2" aria-hidden="true" tabindex="-1"></a>x = -0.563508 or x = -4.436492</span></code></pre></div>
<p>Si introducimos cualquiera de estos valores, obtendremos aproximadamente cero (un poco desviado porque los números no son exactos):</p>
<p><span class="math inline">\(2\times-0.563508^2+10\times-0.563508+5\approx0.000003\)</span></p>
<h3 data-number="19.5.3" id="macros-con-argumentos-variables"><span class="header-section-number">19.5.3</span> Macros con argumentos variables</h3>
<p></p>
<p>También hay una forma de pasar un número variable de argumentos a una macro, utilizando elipses (<code>...</code>) después de los argumentos conocidos con nombre. Cuando se expande la macro, todos los argumentos extra estarán en una lista separada por comas en la macro <code>__VA_ARGS__</code>, y pueden ser reemplazados desde allí:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb372-1"><a href="#cb372-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb372-2"><a href="#cb372-2"></a></span>
<span id="cb372-3"><a href="#cb372-3"></a><span class="co">// Combinar los dos primeros argumentos a un solo número,</span></span>
<span id="cb372-4"><a href="#cb372-4"></a><span class="co">// luego tener un commalist del resto de ellos:</span></span>
<span id="cb372-5"><a href="#cb372-5"></a><span class="pp">#define X</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">,</span><span class="pp"> </span><span class="op">...)</span><span class="pp"> </span><span class="op">(</span><span class="dv">10</span><span class="op">*(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">+</span><span class="pp"> </span><span class="dv">20</span><span class="op">*(</span><span class="pp">b</span><span class="op">)),</span><span class="pp"> __VA_ARGS__</span></span>
<span id="cb372-6"><a href="#cb372-6"></a></span>
<span id="cb372-7"><a href="#cb372-7"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb372-8"><a href="#cb372-8"></a><span class="op">{</span></span>
<span id="cb372-9"><a href="#cb372-9"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%f</span><span class="st"> </span><span class="sc">%s</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> X<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">,</span> <span class="st">&quot;Hi!&quot;</span><span class="op">,</span> <span class="dv">12</span><span class="op">));</span></span>
<span id="cb372-10"><a href="#cb372-10"></a><span class="op">}</span></span></code></pre></div>
<p>La sustitución que tiene lugar en la línea 10 sería:</p>
<div class="sourceCode" id="cb373" data-startFrom="10"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 9;"><span id="cb373-10"><a href="#cb373-10"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%f</span><span class="st"> </span><span class="sc">%s</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span><span class="dv">10</span><span class="op">*(</span><span class="dv">5</span><span class="op">)</span> <span class="op">+</span> <span class="dv">20</span><span class="op">*(</span><span class="dv">4</span><span class="op">)),</span> <span class="fl">3.14</span><span class="op">,</span> <span class="st">&quot;Hi!&quot;</span><span class="op">,</span> <span class="dv">12</span><span class="op">);</span></span></code></pre></div>
<p>para la salida:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true" tabindex="-1"></a>130 3.140000 Hi! 12</span></code></pre></div>
<p>También se puede “stringificar” <code>__VA_ARGS__</code> anteponiéndole un <code>#</code>:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define X</span><span class="op">(...)</span><span class="pp"> </span><span class="op">#</span><span class="pp">__VA_ARGS__</span></span>
<span id="cb375-2"><a href="#cb375-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-3"><a href="#cb375-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> X<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">));</span>  <span class="co">// Imprime &quot;1, 2, 3&quot;</span></span></code></pre></div>
<p> </p>
<h3 data-number="19.5.4" id="stringificación"><span class="header-section-number">19.5.4</span> Stringificación</h3>
<p></p>
<p>Ya se ha mencionado, justo arriba, que puede convertir cualquier argumento en una cadena precediéndolo de un <code>#</code> en el texto de sustitución.</p>
<p>Por ejemplo, podríamos imprimir cualquier cosa como una cadena con esta macro y <code>printf()</code>:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define STR</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="op">#</span><span class="pp">x</span></span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb376-3"><a href="#cb376-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> STR<span class="op">(</span><span class="fl">3.14159</span><span class="op">));</span></span></code></pre></div>
<p>En ese caso, la sustitución conduce a:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;3.14159&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Veamos si podemos usar esto con mayor efecto para que podamos pasar cualquier nombre de variable <code>int</code> a una macro, y hacer que imprima su nombre y valor.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb378-1"><a href="#cb378-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb378-2"><a href="#cb378-2"></a></span>
<span id="cb378-3"><a href="#cb378-3"></a><span class="pp">#define PRINT_INT_VAL</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> printf</span><span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st"> = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">#</span><span class="pp">x</span><span class="op">,</span><span class="pp"> x</span><span class="op">)</span></span>
<span id="cb378-4"><a href="#cb378-4"></a></span>
<span id="cb378-5"><a href="#cb378-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb378-6"><a href="#cb378-6"></a><span class="op">{</span></span>
<span id="cb378-7"><a href="#cb378-7"></a>    <span class="dt">int</span> a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb378-8"><a href="#cb378-8"></a></span>
<span id="cb378-9"><a href="#cb378-9"></a>    PRINT_INT_VAL<span class="op">(</span>a<span class="op">);</span>  <span class="co">// Imprime &quot;a = 5&quot;</span></span>
<span id="cb378-10"><a href="#cb378-10"></a><span class="op">}</span></span></code></pre></div>
<p>En la línea 9, obtenemos la siguiente macro de sustitución:</p>
<div class="sourceCode" id="cb379" data-startFrom="9"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 8;"><span id="cb379-9"><a href="#cb379-9"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st"> = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span></code></pre></div>
<p></p>
<h3 data-number="19.5.5" id="concatenación"><span class="header-section-number">19.5.5</span> Concatenación</h3>
<p></p>
<p>También podemos concatenar dos argumentos con <code>##</code>. ¡Qué divertido!</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb380-1"><a href="#cb380-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CAT</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">)</span><span class="pp"> a </span><span class="op">##</span><span class="pp"> b</span></span>
<span id="cb380-2"><a href="#cb380-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb380-3"><a href="#cb380-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> CAT<span class="op">(</span><span class="fl">3.14</span><span class="op">,</span> <span class="dv">1592</span><span class="op">));</span>   <span class="co">// 3.141592</span></span></code></pre></div>
<p></p>
<h2 data-number="19.6" id="macros-multilínea"><span class="header-section-number">19.6</span> Macros multilínea</h2>
<p></p>
<p>Es posible continuar una macro en varias líneas si se escapa la nueva línea con una barra invertida (<code>\</code>).</p>
<p>Escribamos una macro multilínea que imprima números desde <code>0</code> hasta el producto de los dos argumentos pasados.</p>
<p></p>
<div class="sourceCode" id="cb381"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb381-1"><a href="#cb381-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb381-2"><a href="#cb381-2"></a></span>
<span id="cb381-3"><a href="#cb381-3"></a><span class="pp">#define PRINT_NUMS_TO_PRODUCT</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp"> b</span><span class="op">)</span><span class="pp"> </span><span class="cf">do</span><span class="pp"> </span><span class="op">{</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb381-4"><a href="#cb381-4"></a><span class="pp">    </span><span class="dt">int</span><span class="pp"> product </span><span class="op">=</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">*</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">);</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb381-5"><a href="#cb381-5"></a><span class="pp">    </span><span class="cf">for</span><span class="pp"> </span><span class="op">(</span><span class="dt">int</span><span class="pp"> i </span><span class="op">=</span><span class="pp"> </span><span class="dv">0</span><span class="op">;</span><span class="pp"> i </span><span class="op">&lt;</span><span class="pp"> product</span><span class="op">;</span><span class="pp"> i</span><span class="op">++)</span><span class="pp"> </span><span class="op">{</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb381-6"><a href="#cb381-6"></a><span class="pp">        printf</span><span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> i</span><span class="op">);</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb381-7"><a href="#cb381-7"></a><span class="pp">    </span><span class="op">}</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb381-8"><a href="#cb381-8"></a><span class="op">}</span><span class="pp"> </span><span class="cf">while</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb381-9"><a href="#cb381-9"></a></span>
<span id="cb381-10"><a href="#cb381-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb381-11"><a href="#cb381-11"></a><span class="op">{</span></span>
<span id="cb381-12"><a href="#cb381-12"></a>    PRINT_NUMS_TO_PRODUCT<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span>  <span class="co">// Salida de números del 0 al 7</span></span>
<span id="cb381-13"><a href="#cb381-13"></a><span class="op">}</span></span></code></pre></div>
<p>Un par de cosas a tener en cuenta:</p>
<ul>
<li>Escapes al final de cada línea excepto la última para indicar que la macro continúa.</li>
<li>Todo está envuelto en un bucle <code>do</code>-<code>while(0)</code> con llaves de ardilla.</li>
</ul>
<p>El último punto puede ser un poco raro, pero se trata de absorber el <code>;</code> final que el programador deja caer después de la macro.</p>
<p>Al principio pensé que bastaría con usar llaves de ardilla, pero hay un caso en el que falla si el programador pone un punto y coma después de la macro. Este es el caso:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb382-1"><a href="#cb382-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb382-2"><a href="#cb382-2"></a></span>
<span id="cb382-3"><a href="#cb382-3"></a><span class="pp">#define FOO</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="op">{</span><span class="pp"> </span><span class="op">(</span><span class="pp">x</span><span class="op">)++;</span><span class="pp"> </span><span class="op">}</span></span>
<span id="cb382-4"><a href="#cb382-4"></a></span>
<span id="cb382-5"><a href="#cb382-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb382-6"><a href="#cb382-6"></a><span class="op">{</span></span>
<span id="cb382-7"><a href="#cb382-7"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb382-8"><a href="#cb382-8"></a></span>
<span id="cb382-9"><a href="#cb382-9"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb382-10"><a href="#cb382-10"></a>        FOO<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb382-11"><a href="#cb382-11"></a>    <span class="cf">else</span></span>
<span id="cb382-12"><a href="#cb382-12"></a>        printf<span class="op">(</span><span class="st">&quot;:-(</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb382-13"><a href="#cb382-13"></a></span>
<span id="cb382-14"><a href="#cb382-14"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb382-15"><a href="#cb382-15"></a><span class="op">}</span></span></code></pre></div>
<p>Parece bastante simple, pero no se construye sin un error de sintaxis:</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb383-1"><a href="#cb383-1" aria-hidden="true" tabindex="-1"></a>foo.c:11:5: error: ‘else’ without a previous ‘if’  </span></code></pre></div>
<p>¿Lo ve?</p>
<p>Veamos la expansión:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb384-1"><a href="#cb384-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb384-2"><a href="#cb384-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb384-3"><a href="#cb384-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>i<span class="op">)++;</span></span>
<span id="cb384-4"><a href="#cb384-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span>             <span class="co">// &lt;-- ¡Problema con MAYÚSCULAS!</span></span>
<span id="cb384-5"><a href="#cb384-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb384-6"><a href="#cb384-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb384-7"><a href="#cb384-7" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;:-(</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>El <code>;</code> pone fin a la sentencia <code>if</code>, así que el <code>else</code> queda flotando por ahí ilegalmente<a href="#fn131" class="footnote-ref" id="fnref131" role="doc-noteref"><sup>131</sup></a>.</p>
<p>Así que envuelve esa macro multilínea con un <code>do</code>-<code>while(0)</code>.</p>
<p> </p>
<h2 data-number="19.7" id="my-assert"><span class="header-section-number">19.7</span> Ejemplo: Una macro Assert</h2>
<p>Añadir asserts a tu código es una buena forma de detectar condiciones que crees que no deberían ocurrir. C proporciona la funcionalidad <code>assert()</code>. Comprueba una condición, y si es falsa, el programa explota diciéndote el fichero y el número de línea en el que falló la aserción.</p>
<p>Pero esto es insuficiente.</p>
<ol type="1">
<li><p>En primer lugar, no puedes especificar un mensaje adicional con la aserción.</p></li>
<li><p>En segundo lugar, no hay un interruptor fácil de encendido y apagado para todas las aserciones.</p></li>
</ol>
<p>Podemos abordar el primero con macros.</p>
<p>Básicamente, cuando tengo este código:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb385-1"><a href="#cb385-1" aria-hidden="true" tabindex="-1"></a>ASSERT<span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">20</span><span class="op">,</span> <span class="st">&quot;x debe tener menos de 20 años&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Quiero que ocurra algo como esto (asumiendo que <code>ASSERT()</code> está en la línea 220 de <code>foo.c</code>):</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb386-1"><a href="#cb386-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!(</span>x <span class="op">&lt;</span> <span class="dv">20</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb386-2"><a href="#cb386-2" aria-hidden="true" tabindex="-1"></a>    fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;foo.c:220: assertion x &lt; 20 failed: &quot;</span><span class="op">);</span></span>
<span id="cb386-3"><a href="#cb386-3" aria-hidden="true" tabindex="-1"></a>    fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;x debe tener menos de 20 años</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb386-4"><a href="#cb386-4" aria-hidden="true" tabindex="-1"></a>    exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb386-5"><a href="#cb386-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Podemos obtener el nombre del fichero de la macro <code>__FILE__</code>, y el número de línea de <code>__LINE__</code>. El mensaje ya es una cadena, pero <code>x &lt; 20</code> no lo es, así que tendremos que encadenarla con <code>#</code>. Podemos hacer una macro multilínea utilizando barras invertidas al final de la línea.</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ASSERT</span><span class="op">(</span><span class="pp">c</span><span class="op">,</span><span class="pp"> m</span><span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb387-2"><a href="#cb387-2" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span><span class="pp"> </span><span class="op">{</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb387-3"><a href="#cb387-3" aria-hidden="true" tabindex="-1"></a><span class="pp">    </span><span class="cf">if</span><span class="pp"> </span><span class="op">(!(</span><span class="pp">c</span><span class="op">))</span><span class="pp"> </span><span class="op">{</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb387-4"><a href="#cb387-4" aria-hidden="true" tabindex="-1"></a><span class="pp">        fprintf</span><span class="op">(</span><span class="pp">stderr</span><span class="op">,</span><span class="pp"> __FILE__ </span><span class="st">&quot;:</span><span class="sc">%d</span><span class="st">: assertion </span><span class="sc">%s</span><span class="st"> failed: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb387-5"><a href="#cb387-5" aria-hidden="true" tabindex="-1"></a><span class="pp">                        __LINE__</span><span class="op">,</span><span class="pp"> </span><span class="op">#</span><span class="pp">c</span><span class="op">,</span><span class="pp"> m</span><span class="op">);</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb387-6"><a href="#cb387-6" aria-hidden="true" tabindex="-1"></a><span class="pp">        exit</span><span class="op">(</span><span class="dv">1</span><span class="op">);</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb387-7"><a href="#cb387-7" aria-hidden="true" tabindex="-1"></a><span class="pp">    </span><span class="op">}</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb387-8"><a href="#cb387-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="pp"> </span><span class="cf">while</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>(Parece un poco raro con <code>__FILE__</code> así delante, pero recuerda que es una cadena literal, y las cadenas literales una al lado de la otra se concatenan automáticamente. En cambio, <code>__LINE__</code> es sólo un <code>int</code>).</p>
<p>¡Y funciona! Si ejecuto esto</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb388-1"><a href="#cb388-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">30</span><span class="op">;</span></span>
<span id="cb388-2"><a href="#cb388-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb388-3"><a href="#cb388-3" aria-hidden="true" tabindex="-1"></a>ASSERT<span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">20</span><span class="op">,</span> <span class="st">&quot;x debe tener menos de 20 años&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Obtengo este resultado:</p>
<pre><code>foo.c:23: assertion x &lt; 20 failed: x must be under 20</code></pre>
<p>¡Muy bonito!</p>
<p>Lo único que falta es una forma de activarlo y desactivarlo, y podríamos hacerlo con compilación condicional.</p>
<p>Aquí está el ejemplo completo:</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb390-1"><a href="#cb390-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb390-2"><a href="#cb390-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb390-3"><a href="#cb390-3"></a></span>
<span id="cb390-4"><a href="#cb390-4"></a><span class="pp">#define ASSERT_ENABLED </span><span class="dv">1</span></span>
<span id="cb390-5"><a href="#cb390-5"></a></span>
<span id="cb390-6"><a href="#cb390-6"></a><span class="pp">#if ASSERT_ENABLED</span></span>
<span id="cb390-7"><a href="#cb390-7"></a><span class="pp">#define ASSERT</span><span class="op">(</span><span class="pp">c</span><span class="op">,</span><span class="pp"> m</span><span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb390-8"><a href="#cb390-8"></a><span class="cf">do</span><span class="pp"> </span><span class="op">{</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb390-9"><a href="#cb390-9"></a><span class="pp">    </span><span class="cf">if</span><span class="pp"> </span><span class="op">(!(</span><span class="pp">c</span><span class="op">))</span><span class="pp"> </span><span class="op">{</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb390-10"><a href="#cb390-10"></a><span class="pp">        fprintf</span><span class="op">(</span><span class="pp">stderr</span><span class="op">,</span><span class="pp"> __FILE__ </span><span class="st">&quot;:</span><span class="sc">%d</span><span class="st">: assertion </span><span class="sc">%s</span><span class="st"> failed: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb390-11"><a href="#cb390-11"></a><span class="pp">                        __LINE__</span><span class="op">,</span><span class="pp"> </span><span class="op">#</span><span class="pp">c</span><span class="op">,</span><span class="pp"> m</span><span class="op">);</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb390-12"><a href="#cb390-12"></a><span class="pp">        exit</span><span class="op">(</span><span class="dv">1</span><span class="op">);</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb390-13"><a href="#cb390-13"></a><span class="pp">    </span><span class="op">}</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb390-14"><a href="#cb390-14"></a><span class="op">}</span><span class="pp"> </span><span class="cf">while</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb390-15"><a href="#cb390-15"></a><span class="pp">#else</span></span>
<span id="cb390-16"><a href="#cb390-16"></a><span class="pp">#define ASSERT</span><span class="op">(</span><span class="pp">c</span><span class="op">,</span><span class="pp"> m</span><span class="op">)</span><span class="pp">  </span><span class="co">// Macro vacía si no está activada</span></span>
<span id="cb390-17"><a href="#cb390-17"></a><span class="pp">#endif</span></span>
<span id="cb390-18"><a href="#cb390-18"></a></span>
<span id="cb390-19"><a href="#cb390-19"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb390-20"><a href="#cb390-20"></a><span class="op">{</span></span>
<span id="cb390-21"><a href="#cb390-21"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">30</span><span class="op">;</span></span>
<span id="cb390-22"><a href="#cb390-22"></a></span>
<span id="cb390-23"><a href="#cb390-23"></a>    ASSERT<span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">20</span><span class="op">,</span> <span class="st">&quot;x debe tener menos de 20 años&quot;</span><span class="op">);</span></span>
<span id="cb390-24"><a href="#cb390-24"></a><span class="op">}</span></span></code></pre></div>
<p>Esto tiene la salida:</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true" tabindex="-1"></a>foo.c:23: assertion x &lt; 20 failed: x must be under 20</span></code></pre></div>
<h2 data-number="19.8" id="directiva-error"><span class="header-section-number">19.8</span> Directiva <code>#error</code></h2>
<p></p>
<p>Esta directiva hace que el compilador se equivoque en cuanto la vea.</p>
<p>Normalmente, se utiliza dentro de una condicional para evitar la compilación a menos que se cumplan algunos requisitos previos:</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef __STDC_IEC_559__</span></span>
<span id="cb392-2"><a href="#cb392-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#error I really need IEEE-754 floating point to compile. Sorry!</span></span>
<span id="cb392-3"><a href="#cb392-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p> </p>
<p>Algunos compiladores tienen una directiva complementaria no estándar <code>#warning</code> que mostrará una advertencia pero no detendrá la compilación, pero esto no está en la especificación C11.</p>
<p></p>
<h2 data-number="19.9" id="directiva-embed"><span class="header-section-number">19.9</span> Directiva <code>#embed</code></h2>
<p></p>
<!-- Godbolt demo: https://godbolt.org/z/Kb3ejE7q5 -->
<p>¡Nuevo en C23!</p>
<p>Y actualmente todavía no funciona con ninguno de mis compiladores, ¡así que tómate esta sección con un grano de sal!</p>
<p>La esencia de esto es que puedes incluir bytes de un fichero como constantes enteras como si los hubieras tecleado.</p>
<p>Por ejemplo, si tienes un archivo binario llamado <code>foo.bin</code> que contiene cuatro bytes con valores decimales 11, 22, 33, y 44, y haces esto:</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb393-2"><a href="#cb393-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;foo.bin&quot;</span></span>
<span id="cb393-3"><a href="#cb393-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Será como si lo hubieras escrito tú:</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span><span class="dv">22</span><span class="op">,</span><span class="dv">33</span><span class="op">,</span><span class="dv">44</span><span class="op">};</span></span></code></pre></div>
<p>Se trata de una forma muy eficaz de inicializar una matriz con datos binarios sin necesidad de convertirlos primero en código: ¡el preprocesador lo hace por ti!</p>
<p>Un caso de uso más típico podría ser un archivo que contenga una pequeña imagen para mostrar y que no quieras cargar en tiempo de ejecución.</p>
<p>He aquí otro ejemplo:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb395-2"><a href="#cb395-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &lt;foo.bin&gt;</span></span>
<span id="cb395-3"><a href="#cb395-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Si utiliza corchetes angulares, el preprocesador busca en una serie de lugares definidos por la implementación para localizar el archivo, igual que haría <code>#include</code>. Si utiliza comillas dobles y el recurso no se encuentra, el compilador lo intentará como si hubiera utilizado paréntesis angulares en un último intento desesperado por encontrar el archivo.</p>
<p><code>#embed</code> funciona como <code>#include</code> en el sentido de que pega los valores antes de que el compilador los vea. Esto significa que puedes usarlo en todo tipo de lugares:</p>
<pre><code>return
#embed &quot;somevalue.dat&quot;
;</code></pre>
<p>o</p>
<pre><code>int x =
#embed &quot;xvalue.dat&quot;
;</code></pre>
<p>¿Son siempre bytes? ¿Significa que tendrán valores de 0 a 255, ambos inclusive? La respuesta es definitivamente por defecto “sí”, excepto cuando es “no”.</p>
<p>Técnicamente, los elementos serán <code>CHAR_BIT</code> bits de ancho. Y es muy probable que sean 8 en tu sistema, por lo que obtendrías ese rango de 0 a 255 en tus valores. (Siempre serán no negativos).</p>
<p>Además, es posible que una implementación permita que esto se anule de alguna manera, por ejemplo, en la línea de comandos o con parámetros.</p>
<p>El tamaño del fichero en bits debe ser múltiplo del tamaño del elemento. Es decir, si cada elemento tiene 8 bits, el tamaño del fichero (en bits) debe ser múltiplo de 8. En el uso cotidiano, esta es una forma confusa de decir que cada fichero debe tener un número entero de bytes… que por supuesto lo es. Honestamente, ni siquiera estoy seguro de por qué me molesté con este párrafo. Lee la especificación si realmente tienes curiosidad.</p>
<h3 data-number="19.9.1" id="parámetro-embed"><span class="header-section-number">19.9.1</span> Parámetro <code>#embed</code></h3>
<p>Hay todo tipo de parámetros que puedes especificar a la directiva <code>#embed</code>. He aquí un ejemplo con el parámetro aún no introducido <code>limit()</code>:</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb398-2"><a href="#cb398-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;/dev/random&quot; limit(5)</span></span>
<span id="cb398-3"><a href="#cb398-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Pero, ¿y si ya tienes definido <code>limit</code> en otro lugar? Afortunadamente puedes poner <code>__</code> alrededor de la palabra clave y funcionará de la misma manera:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb399-2"><a href="#cb399-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;/dev/random&quot; __limit__(5)</span></span>
<span id="cb399-3"><a href="#cb399-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Ahora… ¿qué es eso de “límite”?</p>
<h3 data-number="19.9.2" id="parámetro-limit"><span class="header-section-number">19.9.2</span> Parámetro <code>limit()</code></h3>
<p>Puede especificar un límite en el número de elementos a incrustar con este parámetro.</p>
<p>Se trata de un valor máximo, no de un valor absoluto. Si el fichero que se incrusta es más corto que el límite especificado, sólo se importarán esa cantidad de bytes.</p>
<p>El ejemplo <code>/dev/random</code> de arriba es un ejemplo de la motivación para esto—en Unix, eso es un <em>archivo de dispositivo de caracteres</em> que devolverá un flujo infinito de números bastante aleatorios.</p>
<p>Incrustar un número infinito de bytes es duro para tu RAM, así que el parámetro <code>limit</code> te da una forma de parar después de un cierto número.</p>
<p>Finalmente, puedes usar macros <code>#define</code> en tu <code>limit</code>, por si tienes curiosidad.</p>
<h3 data-number="19.9.3" id="parámetro-if_empty"><span class="header-section-number">19.9.3</span> Parámetro <code>if_empty</code></h3>
<p></p>
<p>Este parámetro define cuál debe ser el resultado de la incrustación si el fichero existe pero no contiene datos. Supongamos que el fichero <code>foo.dat</code> contiene un único byte con el valor 123. Si hacemos esto</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> </span>
<span id="cb400-2"><a href="#cb400-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;foo.dat&quot; if_empty(999)</span></span>
<span id="cb400-3"><a href="#cb400-3" aria-hidden="true" tabindex="-1"></a><span class="op">;</span></span></code></pre></div>
<p>lo conseguiremos:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">123</span><span class="op">;</span>   <span class="co">// Cuando foo.dat contiene un byte 123</span></span></code></pre></div>
<p>Pero, ¿y si el archivo <code>foo.dat</code> tiene cero bytes (es decir, no contiene datos y está vacío)? En ese caso, se expandiría a:</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">999</span><span class="op">;</span>   <span class="co">// Cuando foo.dat está vacío</span></span></code></pre></div>
<p>En particular, si el <code>limit</code> se establece en <code>0</code>, entonces el <code>if_empty</code> siempre será sustituido. Es decir, un límite cero significa que el fichero está vacío.</p>
<p>Esto siempre emitirá <code>x = 999</code> sin importar lo que haya en <code>foo.dat</code>:</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> </span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;foo.dat&quot; limit(0) if_empty(999)</span></span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true" tabindex="-1"></a><span class="op">;</span></span></code></pre></div>
<p></p>
<h3 data-number="19.9.4" id="parámetros-prefix-y-suffix."><span class="header-section-number">19.9.4</span> Parámetros <code>prefix()</code> y <code>suffix()</code>.</h3>
<p> </p>
<p>Esta es una manera de anteponer algunos datos en el embed.</p>
<p>Tenga en cuenta que esto sólo afecta a los datos que no están vacíos. Si el fichero está vacío, ni <code>prefix</code> ni <code>suffix</code> tienen efecto.</p>
<p>Aquí hay un ejemplo en el que incrustamos tres números aleatorios, pero les ponemos como prefijo <code>11,</code> y como sufijo <code>,99</code>:</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb404-1"><a href="#cb404-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb404-2"><a href="#cb404-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;/dev/urandom&quot; limit(3) prefix(11,) suffix(,99)</span></span>
<span id="cb404-3"><a href="#cb404-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Ejemplo de resultado:</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span><span class="dv">135</span><span class="op">,</span><span class="dv">116</span><span class="op">,</span><span class="dv">220</span><span class="op">,</span><span class="dv">99</span><span class="op">};</span></span></code></pre></div>
<p>No es obligatorio utilizar tanto <code>prefix</code> como <code>suffix</code>. Puedes usar ambos, uno, el otro, o ninguno.</p>
<p>Podemos hacer uso de la característica de que estos sólo se aplican a los archivos no vacíos para un efecto limpio, como se muestra en el siguiente ejemplo descaradamente robado de la especificación.</p>
<p>Supongamos que tenemos un archivo <code>foo.dat</code> que contiene algunos datos. Y queremos usar esto para inicializar un array, y entonces queremos un sufijo en el array que sea un elemento cero.</p>
<p>No hay problema, ¿verdad?</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb406-2"><a href="#cb406-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;foo.dat&quot; suffix(,0)</span></span>
<span id="cb406-3"><a href="#cb406-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Si <code>foo.dat</code> tiene 11, 22 y 33, obtendríamos:</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span><span class="dv">22</span><span class="op">,</span><span class="dv">33</span><span class="op">,</span><span class="dv">0</span><span class="op">};</span></span></code></pre></div>
<p>Pero, ¡espera! ¿Y si <code>foo.dat</code> está vacío? Entonces obtenemos:</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{};</span></span></code></pre></div>
<p>y eso no es bueno.</p>
<p>Pero podemos arreglarlo así:</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb409-2"><a href="#cb409-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;foo.dat&quot; suffix(,)</span></span>
<span id="cb409-3"><a href="#cb409-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span></span>
<span id="cb409-4"><a href="#cb409-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Dado que el parámetro <code>suffix</code> se omite si el archivo está vacío, esto se convertiría simplemente en:</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span></code></pre></div>
<p>lo cual está bien.</p>
<p> </p>
<h3 data-number="19.9.5" id="el-identificador-__has_embed."><span class="header-section-number">19.9.5</span> El identificador <code>__has_embed()</code>.</h3>
<p></p>
<p>Esta es una gran manera de comprobar si un archivo en particular está disponible para ser incrustado, y también si está vacío o no.</p>
<p>Se usa con la directiva <code>#if</code>.</p>
<p>Aquí hay un trozo de código que obtendrá 5 números aleatorios del dispositivo de caracteres generador de números aleatorios. Si no existen, intenta obtenerlos de un fichero <code>myrandoms.dat</code>. Si no existe, utiliza algunos valores codificados:</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> random_nums<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb411-2"><a href="#cb411-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#if __has_embed(&quot;/dev/urandom&quot;)</span></span>
<span id="cb411-3"><a href="#cb411-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#embed &quot;/dev/urandom&quot; limit(5)</span></span>
<span id="cb411-4"><a href="#cb411-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#elif __has_embed(&quot;myrandoms.dat&quot;)</span></span>
<span id="cb411-5"><a href="#cb411-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#embed &quot;myrandoms.dat&quot; limit(5)</span></span>
<span id="cb411-6"><a href="#cb411-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb411-7"><a href="#cb411-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">140</span><span class="op">,</span><span class="dv">178</span><span class="op">,</span><span class="dv">92</span><span class="op">,</span><span class="dv">167</span><span class="op">,</span><span class="dv">120</span></span>
<span id="cb411-8"><a href="#cb411-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb411-9"><a href="#cb411-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>Técnicamente, el identificador <code>__has_embed()</code> resuelve a uno de tres valores:</p>
<table>
<thead>
<tr class="header">
<th><code>__has_embed()</code> Result</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__STDC_EMBED_NOT_FOUND__</code></td>
<td>Si no se encuentra el archivo.</td>
</tr>
<tr class="even">
<td><code>__STDC_EMBED_FOUND__</code></td>
<td>Si se encuentra el archivo y no está vacío.</td>
</tr>
<tr class="odd">
<td><code>__STDC_EMBED_EMPTY</code></td>
<td>Si se encuentra el archivo y está vacío.</td>
</tr>
</tbody>
</table>
<p>Tengo buenas razones para creer que <code>__STDC_EMBED_NOT_FOUND__</code> es <code>0</code> y los otros no son cero (porque está implícito en la propuesta y tiene sentido lógico), pero tengo problemas para encontrarlo en esta versión del borrador de la especificación.</p>
<p></p>
<p>TODO</p>
<h3 data-number="19.9.6" id="otros-parámetros"><span class="header-section-number">19.9.6</span> Otros parámetros</h3>
<p>La implementación de un compilador puede definir otros parámetros incrustados todo lo que quiera—busque estos parámetros no estándar en la documentación de su compilador.</p>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb412"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;foo.bin&quot; limit(12) frotz(lamp)</span></span></code></pre></div>
<p>Normalmente llevan un prefijo para facilitar el espaciado entre nombres:</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#embed &quot;foo.bin&quot; limit(12) fmc::frotz(lamp)</span></span></code></pre></div>
<p>Puede ser sensato intentar detectar si están disponibles antes de usarlos, y por suerte podemos usar <code>__has_embed</code> para ayudarnos aquí.</p>
<p>Normalmente, <code>__has_embed()</code> nos dirá si el fichero está ahí o no. Pero, y aquí viene lo divertido, ¡también devolverá false si algún parámetro adicional no está soportado!</p>
<p>Así que si le damos un fichero que <em>sabemos</em> que existe y un parámetro cuya existencia queremos comprobar, nos dirá efectivamente si ese parámetro está soportado.</p>
<p>Pero, ¿qué fichero existe <em>siempre</em>? Resulta que podemos usar la macro <code>__FILE__</code>, que se expande al nombre del fichero fuente que lo referencia. Ese fichero <em>debe</em> existir, o algo va muy mal en el departamento del huevo y la gallina.</p>
<p>Probemos el parámetro <code>frotz</code> para ver si podemos usarlo:</p>
<div class="sourceCode" id="cb414"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if __has_embed(__FILE__ fmc::frotz(lamp))</span></span>
<span id="cb414-2"><a href="#cb414-2" aria-hidden="true" tabindex="-1"></a>    puts<span class="op">(</span><span class="st">&quot;fmc::frotz(lamp) is supported!&quot;</span><span class="op">);</span></span>
<span id="cb414-3"><a href="#cb414-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb414-4"><a href="#cb414-4" aria-hidden="true" tabindex="-1"></a>    puts<span class="op">(</span><span class="st">&quot;fmc::frotz(lamp) is NOT supported!&quot;</span><span class="op">);</span></span>
<span id="cb414-5"><a href="#cb414-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h3 data-number="19.9.7" id="incrustación-de-valores-multibyte"><span class="header-section-number">19.9.7</span> Incrustación de valores multibyte</h3>
<p>¿Qué tal si en lugar de bytes individuales se introducen <code>int</code>s? ¿Qué pasa con los valores multibyte en el archivo incrustado?</p>
<p>El estándar C23 no lo admite, pero en el futuro podrían definirse extensiones de implementación para ello.</p>
<p></p>
<h2 data-number="19.10" id="la-directiva-pragma"><span class="header-section-number">19.10</span> La directiva <code id="pragma">#pragma</code></h2>
<p></p>
<p>Se trata de una directiva peculiar, abreviatura de “pragmática”. Puedes usarla para hacer… bueno, cualquier cosa que tu compilador te permita hacer con ella.</p>
<p>Básicamente la única vez que vas a añadir esto a tu código es si alguna documentación te dice que lo hagas.</p>
<h3 data-number="19.10.1" id="pragmas-no-estándar"><span class="header-section-number">19.10.1</span> Pragmas no estándar</h3>
<p></p>
<p>He aquí un ejemplo no estándar de uso de <code>#pragma</code> para hacer que el compilador ejecute un bucle <code>for</code> en paralelo con múltiples hilos (si el compilador soporta la extensión <a href="https://www.openmp.org/">OpenMP</a><a href="#fn132" class="footnote-ref" id="fnref132" role="doc-noteref"><sup>132</sup></a>):</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma omp parallel for</span></span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>Hay todo tipo de directivas <code>#pragma</code> documentadas en las cuatro esquinas del globo.</p>
<p>Todos los <code>#pragma</code>s no reconocidos son ignorados por el compilador.</p>
<p></p>
<h3 data-number="19.10.2" id="pragmas-estándar"><span class="header-section-number">19.10.2</span> Pragmas estándar</h3>
<p>También hay algunas estándar, que empiezan por <code>STDC</code> y siguen la misma forma:</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma STDC pragma_name on-off</span></span></code></pre></div>
<p>La parte <code>on-off</code> puede ser <code>ON</code>, <code>OFF</code>, o <code>DEFAULT</code>.</p>
<p>Y el <code>pragma_name</code> puede ser uno de estos:</p>
<p> </p>
<p></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre del pragma</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>FP_CONTRACT</code></td>
<td>Permitir que las expresiones en coma flotante se contraigan en una sola operación para evitar los errores de redondeo que podrían producirse por múltiples operaciones.</td>
</tr>
<tr class="even">
<td><code>FENV_ACCESS</code></td>
<td>Póngalo a <code>ON</code> si planea acceder a las banderas de estado de coma flotante. Si está <code>OFF</code>, el compilador puede realizar optimizaciones que causen que los valores de las banderas sean inconsistentes o inválidos.</td>
</tr>
<tr class="odd">
<td><code>CX_LIMITED_RANGE</code></td>
<td>Establezca a <code>ON</code> para permitir que el compilador omita las comprobaciones de desbordamiento al realizar aritmética compleja. Por defecto es <code>OFF</code>.</td>
</tr>
</tbody>
</table>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma STDC FP_CONTRACT OFF</span></span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma STDC CX_LIMITED_RANGE ON</span></span></code></pre></div>
<p></p>
<p>En cuanto a <code>CX_LIMITED_RANGE</code>, la especificación señala:</p>
<blockquote>
<p>El propósito del pragma es permitir a la implementación utilizar las fórmulas:</p>
<p><span class="math inline">\((x+iy)\times(u+iv) = (xu-yv)+i(yu+xv)\)</span></p>
<p><span class="math inline">\((x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u^2+v^2)\)</span></p>
<p><span class="math inline">\(|x+iy|=\sqrt{x^2+y^2}\)</span></p>
<p>donde el programador puede determinar que son seguros.</p>
</blockquote>
<p></p>
<h3 data-number="19.10.3" id="operador-_pragma"><span class="header-section-number">19.10.3</span> Operador <code>_Pragma</code></h3>
<p></p>
<p>Esta es otra forma de declarar un pragma que podría utilizar en una macro.</p>
<p>Son equivalentes:</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma &quot;Unnecessary&quot; quotes</span></span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true" tabindex="-1"></a>_Pragma<span class="op">(</span><span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">Unnecessary</span><span class="sc">\&quot;</span><span class="st"> quotes&quot;</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>Esto se puede utilizar en una macro, si es necesario:</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define PRAGMA</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> _Pragma</span><span class="op">(#</span><span class="pp">x</span><span class="op">)</span></span></code></pre></div>
<p> </p>
<h2 data-number="19.11" id="la-directiva-line"><span class="header-section-number">19.11</span> La directiva <code>#line</code></h2>
<p> </p>
<p>Esto le permite anular los valores de <code>__LINE__</code> y <code>__FILE__</code>. Si lo desea.</p>
<p>Nunca he querido hacer esto, pero en K&amp;R2, escriben:</p>
<blockquote>
<p>Para el beneficio de otros preprocesadores que generan programas C […]</p>
</blockquote>
<p>Así que tal vez haya eso.</p>
<p>Para anular el número de línea a, digamos 300:</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#line 300</span></span></code></pre></div>
<p>y <code>__LINE__</code> seguirá contando a partir de ahí.</p>
<p></p>
<p>Para anular el número de línea y el nombre de fichero:</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#line 300 &quot;newfilename&quot;</span></span></code></pre></div>
<p></p>
<h2 data-number="19.12" id="la-directiva-nula"><span class="header-section-number">19.12</span> La Directiva Nula (<code>#</code>)</h2>
<p></p>
<p>Un <code>#</code> en una línea por sí mismo es ignorado por el preprocesador. Ahora, para ser totalmente honesto, no sé cuál es el caso de uso para esto.</p>
<p>He visto ejemplos como este:</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef FOO</span></span>
<span id="cb422-2"><a href="#cb422-2" aria-hidden="true" tabindex="-1"></a>    <span class="er">#</span></span>
<span id="cb422-3"><a href="#cb422-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb422-4"><a href="#cb422-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Something&quot;</span><span class="op">);</span></span>
<span id="cb422-5"><a href="#cb422-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p>que es sólo cosmético; la línea con el solitario <code>#</code> puede ser eliminado sin ningún efecto nocivo.</p>
<p>O tal vez por coherencia cosmética, así:</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true" tabindex="-1"></a><span class="er">#</span></span>
<span id="cb423-2"><a href="#cb423-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef FOO</span></span>
<span id="cb423-3"><a href="#cb423-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb423-4"><a href="#cb423-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb423-5"><a href="#cb423-5" aria-hidden="true" tabindex="-1"></a><span class="er">#</span></span>
<span id="cb423-6"><a href="#cb423-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#if BAR == 17</span></span>
<span id="cb423-7"><a href="#cb423-7" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb423-8"><a href="#cb423-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb423-9"><a href="#cb423-9" aria-hidden="true" tabindex="-1"></a><span class="er">#</span></span></code></pre></div>
<p>Pero, con respecto a la cosmética, eso es simplemente feo.</p>
<p>Otro post menciona la eliminación de comentarios—que en GCC, un comentario después de un <code>#</code> no será visto por el compilador. No lo dudo, pero la especificación no parece decir que este sea el comportamiento estándar.</p>
<p>Mis búsquedas de fundamentos no están dando muchos frutos. Así que voy a decir que esto es algo de esoterismo de C.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="20" id="structs-ii-más-diversión-con-structs"><span class="header-section-number">20</span> <code>struct</code>s II: Más diversión con <code>struct</code>s</h1>
<p></p>
<p>Resulta que hay mucho más que puedes hacer con <code>struct</code>s de lo que hemos hablado, pero es sólo un gran montón de cosas varias. Así que las incluiremos en este capítulo.</p>
<p>Si eres bueno con lo básico de <code>struct</code>s, puedes completar tus conocimientos aquí.</p>
<h2 data-number="20.1" id="inicializadores-de-structs-anidadas-y-matrices"><span class="header-section-number">20.1</span> Inicializadores de <code>struct</code>s anidadas y matrices</h2>
<p></p>
<p>¿Recuerdas cómo podías <a href="#struct-initializers">inicializar los miembros de la estructura siguiendo estas líneas</a>?</p>
<div class="sourceCode" id="cb424"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb424-1"><a href="#cb424-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo x <span class="op">=</span> <span class="op">{.</span>a<span class="op">=</span><span class="dv">12</span><span class="op">,</span> <span class="op">.</span>b<span class="op">=</span><span class="fl">3.14</span><span class="op">};</span></span></code></pre></div>
<p>Resulta que tenemos más potencia en estos inicializadores de la que habíamos compartido en un principio. ¡Interesante!</p>
<p>Por un lado, si tienes una subestructura anidada como la siguiente, puedes inicializar miembros de esa subestructura siguiendo los nombres de las variables línea abajo:</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb425-1"><a href="#cb425-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo x <span class="op">=</span> <span class="op">{.</span>a<span class="op">.</span>b<span class="op">.</span>c<span class="op">=</span><span class="dv">12</span><span class="op">};</span></span></code></pre></div>
<p>Veamos un ejemplo:</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb426-1"><a href="#cb426-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb426-2"><a href="#cb426-2"></a></span>
<span id="cb426-3"><a href="#cb426-3"></a><span class="kw">struct</span> cabin_information <span class="op">{</span></span>
<span id="cb426-4"><a href="#cb426-4"></a>    <span class="dt">int</span> window_count<span class="op">;</span></span>
<span id="cb426-5"><a href="#cb426-5"></a>    <span class="dt">int</span> o2level<span class="op">;</span></span>
<span id="cb426-6"><a href="#cb426-6"></a><span class="op">};</span></span>
<span id="cb426-7"><a href="#cb426-7"></a></span>
<span id="cb426-8"><a href="#cb426-8"></a><span class="kw">struct</span> spaceship <span class="op">{</span></span>
<span id="cb426-9"><a href="#cb426-9"></a>    <span class="dt">char</span> <span class="op">*</span>manufacturer<span class="op">;</span></span>
<span id="cb426-10"><a href="#cb426-10"></a>    <span class="kw">struct</span> cabin_information ci<span class="op">;</span></span>
<span id="cb426-11"><a href="#cb426-11"></a><span class="op">};</span></span>
<span id="cb426-12"><a href="#cb426-12"></a></span>
<span id="cb426-13"><a href="#cb426-13"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb426-14"><a href="#cb426-14"></a><span class="op">{</span></span>
<span id="cb426-15"><a href="#cb426-15"></a>    <span class="kw">struct</span> spaceship s <span class="op">=</span> <span class="op">{</span></span>
<span id="cb426-16"><a href="#cb426-16"></a>        <span class="op">.</span>manufacturer<span class="op">=</span><span class="st">&quot;General Products&quot;</span><span class="op">,</span></span>
<span id="cb426-17"><a href="#cb426-17"></a>        <span class="op">.</span>ci<span class="op">.</span>window_count <span class="op">=</span> <span class="dv">8</span><span class="op">,</span>   <span class="co">// &lt;-- ¡INICIALIZADOR ANIDADO!</span></span>
<span id="cb426-18"><a href="#cb426-18"></a>        <span class="op">.</span>ci<span class="op">.</span>o2level <span class="op">=</span> <span class="dv">21</span></span>
<span id="cb426-19"><a href="#cb426-19"></a>    <span class="op">};</span></span>
<span id="cb426-20"><a href="#cb426-20"></a></span>
<span id="cb426-21"><a href="#cb426-21"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">: </span><span class="sc">%d</span><span class="st"> seats, </span><span class="sc">%d%%</span><span class="st"> oxygen</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb426-22"><a href="#cb426-22"></a>        s<span class="op">.</span>manufacturer<span class="op">,</span> s<span class="op">.</span>ci<span class="op">.</span>window_count<span class="op">,</span> s<span class="op">.</span>ci<span class="op">.</span>o2level<span class="op">);</span></span>
<span id="cb426-23"><a href="#cb426-23"></a><span class="op">}</span></span></code></pre></div>
<p>Fíjate en las líneas 16-17. Ahí es donde estamos inicializando los miembros de la <code>struct cabin_information</code> en la definición de <code>s</code>, nuestra <code>struct spaceship</code>.</p>
<p>Y aquí hay otra opción para ese mismo inicializador - esta vez vamos a hacer algo más estándar, pero cualquiera de los enfoques funciona:</p>
<div class="sourceCode" id="cb427" data-startFrom="15"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 14;"><span id="cb427-15"><a href="#cb427-15"></a>    <span class="kw">struct</span> spaceship s <span class="op">=</span> <span class="op">{</span></span>
<span id="cb427-16"><a href="#cb427-16"></a>        <span class="op">.</span>manufacturer<span class="op">=</span><span class="st">&quot;General Products&quot;</span><span class="op">,</span></span>
<span id="cb427-17"><a href="#cb427-17"></a>        <span class="op">.</span>ci<span class="op">={</span></span>
<span id="cb427-18"><a href="#cb427-18"></a>            <span class="op">.</span>window_count <span class="op">=</span> <span class="dv">8</span><span class="op">,</span></span>
<span id="cb427-19"><a href="#cb427-19"></a>            <span class="op">.</span>o2level <span class="op">=</span> <span class="dv">21</span></span>
<span id="cb427-20"><a href="#cb427-20"></a>        <span class="op">}</span></span>
<span id="cb427-21"><a href="#cb427-21"></a>    <span class="op">};</span></span></code></pre></div>
<p>Como si la información anterior no fuera lo suficientemente espectacular, también podemos mezclar inicializadores de matrices.</p>
<p>Vamos a cambiar esto para obtener una matriz de información de pasajeros allí, y podemos comprobar cómo los inicializadores trabajan allí, también.</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb428-1"><a href="#cb428-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb428-2"><a href="#cb428-2"></a></span>
<span id="cb428-3"><a href="#cb428-3"></a><span class="kw">struct</span> passenger <span class="op">{</span></span>
<span id="cb428-4"><a href="#cb428-4"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb428-5"><a href="#cb428-5"></a>    <span class="dt">int</span> covid_vaccinated<span class="op">;</span> <span class="co">// Booleano</span></span>
<span id="cb428-6"><a href="#cb428-6"></a><span class="op">};</span></span>
<span id="cb428-7"><a href="#cb428-7"></a></span>
<span id="cb428-8"><a href="#cb428-8"></a><span class="pp">#define MAX_PASSENGERS </span><span class="dv">8</span></span>
<span id="cb428-9"><a href="#cb428-9"></a></span>
<span id="cb428-10"><a href="#cb428-10"></a><span class="kw">struct</span> spaceship <span class="op">{</span></span>
<span id="cb428-11"><a href="#cb428-11"></a>    <span class="dt">char</span> <span class="op">*</span>manufacturer<span class="op">;</span></span>
<span id="cb428-12"><a href="#cb428-12"></a>    <span class="kw">struct</span> passenger passenger<span class="op">[</span>MAX_PASSENGERS<span class="op">];</span></span>
<span id="cb428-13"><a href="#cb428-13"></a><span class="op">};</span></span>
<span id="cb428-14"><a href="#cb428-14"></a></span>
<span id="cb428-15"><a href="#cb428-15"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb428-16"><a href="#cb428-16"></a><span class="op">{</span></span>
<span id="cb428-17"><a href="#cb428-17"></a>    <span class="kw">struct</span> spaceship s <span class="op">=</span> <span class="op">{</span></span>
<span id="cb428-18"><a href="#cb428-18"></a>        <span class="op">.</span>manufacturer<span class="op">=</span><span class="st">&quot;General Products&quot;</span><span class="op">,</span></span>
<span id="cb428-19"><a href="#cb428-19"></a>        <span class="op">.</span>passenger <span class="op">=</span> <span class="op">{</span></span>
<span id="cb428-20"><a href="#cb428-20"></a>            <span class="co">// Inicializar un campo cada vez</span></span>
<span id="cb428-21"><a href="#cb428-21"></a>            <span class="op">[</span><span class="dv">0</span><span class="op">].</span>name <span class="op">=</span> <span class="st">&quot;Gridley, Lewis&quot;</span><span class="op">,</span></span>
<span id="cb428-22"><a href="#cb428-22"></a>            <span class="op">[</span><span class="dv">0</span><span class="op">].</span>covid_vaccinated <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb428-23"><a href="#cb428-23"></a></span>
<span id="cb428-24"><a href="#cb428-24"></a>            <span class="co">// O todos a la vez</span></span>
<span id="cb428-25"><a href="#cb428-25"></a>            <span class="op">[</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Brown, Teela&quot;</span><span class="op">,</span> <span class="op">.</span>covid_vaccinated<span class="op">=</span><span class="dv">1</span><span class="op">},</span></span>
<span id="cb428-26"><a href="#cb428-26"></a>        <span class="op">}</span></span>
<span id="cb428-27"><a href="#cb428-27"></a>    <span class="op">};</span></span>
<span id="cb428-28"><a href="#cb428-28"></a></span>
<span id="cb428-29"><a href="#cb428-29"></a>    printf<span class="op">(</span><span class="st">&quot;Passengers for </span><span class="sc">%s</span><span class="st"> ship:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">.</span>manufacturer<span class="op">);</span></span>
<span id="cb428-30"><a href="#cb428-30"></a></span>
<span id="cb428-31"><a href="#cb428-31"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> MAX_PASSENGERS<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb428-32"><a href="#cb428-32"></a>        <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span>passenger<span class="op">[</span>i<span class="op">].</span>name <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb428-33"><a href="#cb428-33"></a>            printf<span class="op">(</span><span class="st">&quot;    </span><span class="sc">%s</span><span class="st"> (</span><span class="sc">%s</span><span class="st">vaccinated)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb428-34"><a href="#cb428-34"></a>                s<span class="op">.</span>passenger<span class="op">[</span>i<span class="op">].</span>name<span class="op">,</span></span>
<span id="cb428-35"><a href="#cb428-35"></a>                s<span class="op">.</span>passenger<span class="op">[</span>i<span class="op">].</span>covid_vaccinated<span class="op">?</span> <span class="st">&quot;&quot;</span><span class="op">:</span> <span class="st">&quot;not &quot;</span><span class="op">);</span></span>
<span id="cb428-36"><a href="#cb428-36"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h2 data-number="20.2" id="structs-anonimas"><span class="header-section-number">20.2</span> <code>struct</code>s anonimas</h2>
<p></p>
<p>Son las “estructuras sin nombre”. También las mencionamos en la sección <a href="#typedef-struct"><code>typedef</code></a>, pero las refrescaremos aquí.</p>
<p>Aquí tenemos una <code>struct</code> normal:</p>
<div class="sourceCode" id="cb429"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb429-1"><a href="#cb429-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> animal <span class="op">{</span></span>
<span id="cb429-2"><a href="#cb429-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb429-3"><a href="#cb429-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> leg_count<span class="op">,</span> speed<span class="op">;</span></span>
<span id="cb429-4"><a href="#cb429-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Y aquí está el equivalente anónimo:</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb430-1"><a href="#cb430-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="op">{</span>              <span class="co">// &lt;-- Sin nombre</span></span>
<span id="cb430-2"><a href="#cb430-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb430-3"><a href="#cb430-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> leg_count<span class="op">,</span> speed<span class="op">;</span></span>
<span id="cb430-4"><a href="#cb430-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Okaaaaay. ¿Así que tenemos una “estructura”, pero no tiene nombre, por lo que no tenemos manera de utilizarla más tarde? Parece bastante inútil.</p>
<p>Es cierto que en ese ejemplo lo es. Pero todavía podemos hacer uso de ella de un par de maneras.</p>
<p>Una es rara, pero como la <code>struct</code> anónima representa un tipo, podemos simplemente poner algunos nombres de variables después de ella y usarlos.</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb431-1"><a href="#cb431-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="op">{</span>                   <span class="co">// &lt;-- ¡Sin nombre!</span></span>
<span id="cb431-2"><a href="#cb431-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb431-3"><a href="#cb431-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> leg_count<span class="op">,</span> speed<span class="op">;</span></span>
<span id="cb431-4"><a href="#cb431-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span>                 <span class="co">// 3 variables de este tipo struct</span></span>
<span id="cb431-5"><a href="#cb431-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb431-6"><a href="#cb431-6" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span>name <span class="op">=</span> <span class="st">&quot;antelope&quot;</span><span class="op">;</span></span>
<span id="cb431-7"><a href="#cb431-7" aria-hidden="true" tabindex="-1"></a>c<span class="op">.</span>leg_count <span class="op">=</span> <span class="dv">4</span><span class="op">;</span>           <span class="co">// Por ejemplo</span></span></code></pre></div>
<p>Pero sigue sin ser muy útil.</p>
<p>Mucho más común es el uso de <code>struct</code>s anónimas con un <code>typedef</code> para que podamos usarlo más tarde (por ejemplo, para pasar variables a funciones).</p>
<div class="sourceCode" id="cb432"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb432-1"><a href="#cb432-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span>                   <span class="co">// &lt;-- ¡Sin nombre!</span></span>
<span id="cb432-2"><a href="#cb432-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb432-3"><a href="#cb432-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> leg_count<span class="op">,</span> speed<span class="op">;</span></span>
<span id="cb432-4"><a href="#cb432-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> animal<span class="op">;</span>                          <span class="co">// Nuevo tipo: animal</span></span>
<span id="cb432-5"><a href="#cb432-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-6"><a href="#cb432-6" aria-hidden="true" tabindex="-1"></a>animal a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb432-7"><a href="#cb432-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-8"><a href="#cb432-8" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span>name <span class="op">=</span> <span class="st">&quot;antelope&quot;</span><span class="op">;</span></span>
<span id="cb432-9"><a href="#cb432-9" aria-hidden="true" tabindex="-1"></a>c<span class="op">.</span>leg_count <span class="op">=</span> <span class="dv">4</span><span class="op">;</span>           <span class="co">// Por ejemplo</span></span></code></pre></div>
<p>Personalmente, no utilizo muchas <code>struct</code>s anónimas. Creo que es más agradable ver el <code>struct animal</code> completo antes del nombre de la variable en una declaración.</p>
<p>Pero eso es sólo mi opinión.</p>
<p></p>
<h2 data-number="20.3" id="structs-estructuras-autorreferenciales"><span class="header-section-number">20.3</span> <code>struct</code>s (Estructuras autorreferenciales)</h2>
<p></p>
<p>Para cualquier estructura de datos tipo grafo, es útil poder tener punteros a los nodos/vértices conectados. Pero esto significa que en la definición de un nodo, es necesario tener un puntero a un nodo. Es un rollo.</p>
<p>Pero resulta que se puede hacer esto en C sin ningún problema.</p>
<p>Por ejemplo, aquí hay un nodo de lista enlazada:</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb433-1"><a href="#cb433-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> node <span class="op">{</span></span>
<span id="cb433-2"><a href="#cb433-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb433-3"><a href="#cb433-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb433-4"><a href="#cb433-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Es importante tener en cuenta que <code>next</code> es un puntero. Esto es lo que permite todo el asunto incluso construir. A pesar de que el compilador no sabe cómo es el nodo <code>struct</code> completo, todos los punteros tienen el mismo tamaño.</p>
<p>Aquí hay un programa de lista enlazada para probarlo:</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb434-1"><a href="#cb434-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb434-2"><a href="#cb434-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb434-3"><a href="#cb434-3"></a></span>
<span id="cb434-4"><a href="#cb434-4"></a><span class="kw">struct</span> node <span class="op">{</span></span>
<span id="cb434-5"><a href="#cb434-5"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb434-6"><a href="#cb434-6"></a>    <span class="kw">struct</span> node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb434-7"><a href="#cb434-7"></a><span class="op">};</span></span>
<span id="cb434-8"><a href="#cb434-8"></a></span>
<span id="cb434-9"><a href="#cb434-9"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb434-10"><a href="#cb434-10"></a><span class="op">{</span></span>
<span id="cb434-11"><a href="#cb434-11"></a>    <span class="kw">struct</span> node <span class="op">*</span>head<span class="op">;</span></span>
<span id="cb434-12"><a href="#cb434-12"></a></span>
<span id="cb434-13"><a href="#cb434-13"></a>    <span class="co">// Hackishly configurar una lista enlazada (11)-&gt;(22)-&gt;(33)</span></span>
<span id="cb434-14"><a href="#cb434-14"></a>    head <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> node<span class="op">));</span></span>
<span id="cb434-15"><a href="#cb434-15"></a>    head<span class="op">-&gt;</span>data <span class="op">=</span> <span class="dv">11</span><span class="op">;</span></span>
<span id="cb434-16"><a href="#cb434-16"></a>    head<span class="op">-&gt;</span>next <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> node<span class="op">));</span></span>
<span id="cb434-17"><a href="#cb434-17"></a>    head<span class="op">-&gt;</span>next<span class="op">-&gt;</span>data <span class="op">=</span> <span class="dv">22</span><span class="op">;</span></span>
<span id="cb434-18"><a href="#cb434-18"></a>    head<span class="op">-&gt;</span>next<span class="op">-&gt;</span>next <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> node<span class="op">));</span></span>
<span id="cb434-19"><a href="#cb434-19"></a>    head<span class="op">-&gt;</span>next<span class="op">-&gt;</span>next<span class="op">-&gt;</span>data <span class="op">=</span> <span class="dv">33</span><span class="op">;</span></span>
<span id="cb434-20"><a href="#cb434-20"></a>    head<span class="op">-&gt;</span>next<span class="op">-&gt;</span>next<span class="op">-&gt;</span>next <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb434-21"><a href="#cb434-21"></a></span>
<span id="cb434-22"><a href="#cb434-22"></a>    <span class="co">// Atraviésalo</span></span>
<span id="cb434-23"><a href="#cb434-23"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">struct</span> node <span class="op">*</span>cur <span class="op">=</span> head<span class="op">;</span> cur <span class="op">!=</span> NULL<span class="op">;</span> cur <span class="op">=</span> cur<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb434-24"><a href="#cb434-24"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> cur<span class="op">-&gt;</span>data<span class="op">);</span></span>
<span id="cb434-25"><a href="#cb434-25"></a>    <span class="op">}</span></span>
<span id="cb434-26"><a href="#cb434-26"></a><span class="op">}</span></span></code></pre></div>
<p>Corriendo que imprime:</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb435-1"><a href="#cb435-1" aria-hidden="true" tabindex="-1"></a>11</span>
<span id="cb435-2"><a href="#cb435-2" aria-hidden="true" tabindex="-1"></a>22</span>
<span id="cb435-3"><a href="#cb435-3" aria-hidden="true" tabindex="-1"></a>33</span></code></pre></div>
<p></p>
<h2 data-number="20.4" id="miembros-flexibles-de-la-matriz"><span class="header-section-number">20.4</span> Miembros flexibles de la matriz</h2>
<p></p>
<p>En los viejos tiempos, cuando la gente tallaba el código C en madera, algunos pensaban que estaría bien poder asignar <code>struct</code>s que tuvieran arrays de longitud variable al final.</p>
<p>Quiero dejar claro que la primera parte de la sección es la forma antigua de hacer las cosas, y que después vamos a hacer las cosas de la forma nueva.</p>
<p>Por ejemplo, podrías definir una <code>struct</code> para contener cadenas y la longitud de esa cadena. Tendría una longitud y una matriz para contener los datos. Tal vez algo como esto:</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb436-1"><a href="#cb436-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> len_string <span class="op">{</span></span>
<span id="cb436-2"><a href="#cb436-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb436-3"><a href="#cb436-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> data<span class="op">[</span><span class="dv">8</span><span class="op">];</span></span>
<span id="cb436-4"><a href="#cb436-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Pero eso tiene “8” codificados como la longitud máxima de una cadena, y eso no es mucho. ¿Qué pasa si hacemos algo <em>limpio</em> y simplemente <code>malloc()</code> algún espacio extra al final después de la estructura, y luego dejar que los datos se desborden en ese espacio?</p>
<p>Hagamos eso, y luego asignemos otros 40 bytes encima:</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb437-1"><a href="#cb437-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> len_string <span class="op">*</span>s <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>s <span class="op">+</span> <span class="dv">40</span><span class="op">);</span></span></code></pre></div>
<p>Como <code>data</code> es el último campo de la <code>struct</code>, si desbordamos ese campo, ¡se acaba el espacio que ya habíamos asignado! Por esta razón, este truco sólo funciona si el array corto es el <em>último</em> campo de la <code>struct</code>.</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb438-1"><a href="#cb438-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Copie más de 8 bytes</span></span>
<span id="cb438-2"><a href="#cb438-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-3"><a href="#cb438-3" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>s<span class="op">-&gt;</span>data<span class="op">,</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">);</span>  <span class="co">// No se estrellará. Probablemente.</span></span></code></pre></div>
<p></p>
<p>De hecho, existía una solución común en el compilador para hacer esto, en la que se asignaba un array de longitud cero al final:</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb439-1"><a href="#cb439-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> len_string <span class="op">{</span></span>
<span id="cb439-2"><a href="#cb439-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb439-3"><a href="#cb439-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> data<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb439-4"><a href="#cb439-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Y entonces cada byte extra que asignaste estaba listo para ser usado en esa cadena.</p>
<p>Como <code>data</code> es el último campo de la <code>struct</code>, si desbordamos ese campo, ¡se acaba el espacio que ya habíamos asignado!</p>
<div class="sourceCode" id="cb440"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb440-1"><a href="#cb440-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Copie más de 8 bytes</span></span>
<span id="cb440-2"><a href="#cb440-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb440-3"><a href="#cb440-3" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>s<span class="op">-&gt;</span>data<span class="op">,</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">);</span>  <span class="co">// No se estrellará. Probablemente.</span></span></code></pre></div>
<p>Pero, por supuesto, acceder a los datos más allá del final de la matriz es un comportamiento indefinido. En estos tiempos modernos, ya no nos dignamos a recurrir a semejante salvajada.</p>
<p></p>
<p>Por suerte para nosotros, todavía podemos conseguir el mismo efecto con C99 y posteriores, pero ahora es legal.</p>
<p>Cambiemos nuestra definición anterior para que el array no tenga tamaño<a href="#fn133" class="footnote-ref" id="fnref133" role="doc-noteref"><sup>133</sup></a>:</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb441-1"><a href="#cb441-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> len_string <span class="op">{</span></span>
<span id="cb441-2"><a href="#cb441-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb441-3"><a href="#cb441-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> data<span class="op">[];</span></span>
<span id="cb441-4"><a href="#cb441-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>De nuevo, esto sólo funciona si el miembro del array flexible es el <em>último</em> campo de la <code>struct</code>.</p>
<p>Y entonces podemos asignar todo el espacio que queramos para esas cadenas haciendo <code>malloc()</code>mayor que la <code>struct len_string</code> de <code>construcción</code>, como hacemos en este ejemplo que hace una nueva <code>struct len_string</code> a partir de una cadena C:</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb442-1"><a href="#cb442-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> len_string <span class="op">*</span>len_string_from_c_string<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb442-2"><a href="#cb442-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb442-3"><a href="#cb442-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len <span class="op">=</span> strlen<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb442-4"><a href="#cb442-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb442-5"><a href="#cb442-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Asignar &quot;len&quot; más bytes de los que normalmente necesitaríamos</span></span>
<span id="cb442-6"><a href="#cb442-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> len_string <span class="op">*</span>ls <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>ls <span class="op">+</span> len<span class="op">);</span></span>
<span id="cb442-7"><a href="#cb442-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb442-8"><a href="#cb442-8" aria-hidden="true" tabindex="-1"></a>    ls<span class="op">-&gt;</span>length <span class="op">=</span> len<span class="op">;</span></span>
<span id="cb442-9"><a href="#cb442-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb442-10"><a href="#cb442-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Copia la cadena en esos bytes extra</span></span>
<span id="cb442-11"><a href="#cb442-11" aria-hidden="true" tabindex="-1"></a>    memcpy<span class="op">(</span>ls<span class="op">-&gt;</span>data<span class="op">,</span> s<span class="op">,</span> len<span class="op">);</span></span>
<span id="cb442-12"><a href="#cb442-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb442-13"><a href="#cb442-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ls<span class="op">;</span></span>
<span id="cb442-14"><a href="#cb442-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h2 data-number="20.5" id="struct-padding-bytes"><span class="header-section-number">20.5</span> Bytes de relleno</h2>
<p></p>
<p>Tenga en cuenta que C puede añadir bytes de relleno dentro o después de una <code>struct</code> según le convenga. No puedes confiar en que estarán directamente adyacentes en memoria<a href="#fn134" class="footnote-ref" id="fnref134" role="doc-noteref"><sup>134</sup></a>.</p>
<p>Echemos un vistazo a este programa. Obtenemos dos números. Uno es la suma del <code>tamaño de</code> los tipos de campo individuales. El otro es el tamaño de toda la estructura.</p>
<p>Es de esperar que sean iguales. El tamaño del total es el tamaño de la suma de sus partes, ¿verdad?</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb443-1"><a href="#cb443-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb443-2"><a href="#cb443-2"></a></span>
<span id="cb443-3"><a href="#cb443-3"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb443-4"><a href="#cb443-4"></a>    <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb443-5"><a href="#cb443-5"></a>    <span class="dt">char</span> b<span class="op">;</span></span>
<span id="cb443-6"><a href="#cb443-6"></a>    <span class="dt">int</span> c<span class="op">;</span></span>
<span id="cb443-7"><a href="#cb443-7"></a>    <span class="dt">char</span> d<span class="op">;</span></span>
<span id="cb443-8"><a href="#cb443-8"></a><span class="op">};</span></span>
<span id="cb443-9"><a href="#cb443-9"></a></span>
<span id="cb443-10"><a href="#cb443-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb443-11"><a href="#cb443-11"></a><span class="op">{</span></span>
<span id="cb443-12"><a href="#cb443-12"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">+</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">)</span> <span class="op">+</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">+</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">));</span></span>
<span id="cb443-13"><a href="#cb443-13"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> foo<span class="op">));</span></span>
<span id="cb443-14"><a href="#cb443-14"></a><span class="op">}</span></span></code></pre></div>
<p>Pero en mi sistema, esto sale:</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb444-1"><a href="#cb444-1" aria-hidden="true" tabindex="-1"></a>10</span>
<span id="cb444-2"><a href="#cb444-2" aria-hidden="true" tabindex="-1"></a>16</span></code></pre></div>
<p>No son iguales. El compilador ha añadido 6 bytes de relleno para mejorar el rendimiento. Puede que tu compilador te dé un resultado diferente, pero a menos que lo fuerces, no puedes estar seguro de que no haya relleno.</p>
<p></p>
<h2 data-number="20.6" id="offsetof"><span class="header-section-number">20.6</span> <code>offsetof</code></h2>
<p></p>
<p>En la sección anterior, vimos que el compilador podía inyectar bytes de relleno a voluntad dentro de una estructura.</p>
<p>¿Y si necesitáramos saber dónde están? Podemos medirlo con <code>offsetof</code>, definido en <code>&lt;stddef.h&gt;</code>.</p>
<p>Modifiquemos el código anterior para imprimir los desplazamientos de los campos individuales en la <code>struct</code>:</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb445-1"><a href="#cb445-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb445-2"><a href="#cb445-2"></a><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span></span>
<span id="cb445-3"><a href="#cb445-3"></a></span>
<span id="cb445-4"><a href="#cb445-4"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb445-5"><a href="#cb445-5"></a>    <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb445-6"><a href="#cb445-6"></a>    <span class="dt">char</span> b<span class="op">;</span></span>
<span id="cb445-7"><a href="#cb445-7"></a>    <span class="dt">int</span> c<span class="op">;</span></span>
<span id="cb445-8"><a href="#cb445-8"></a>    <span class="dt">char</span> d<span class="op">;</span></span>
<span id="cb445-9"><a href="#cb445-9"></a><span class="op">};</span></span>
<span id="cb445-10"><a href="#cb445-10"></a></span>
<span id="cb445-11"><a href="#cb445-11"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb445-12"><a href="#cb445-12"></a><span class="op">{</span></span>
<span id="cb445-13"><a href="#cb445-13"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> offsetof<span class="op">(</span><span class="kw">struct</span> foo<span class="op">,</span> a<span class="op">));</span></span>
<span id="cb445-14"><a href="#cb445-14"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> offsetof<span class="op">(</span><span class="kw">struct</span> foo<span class="op">,</span> b<span class="op">));</span></span>
<span id="cb445-15"><a href="#cb445-15"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> offsetof<span class="op">(</span><span class="kw">struct</span> foo<span class="op">,</span> c<span class="op">));</span></span>
<span id="cb445-16"><a href="#cb445-16"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> offsetof<span class="op">(</span><span class="kw">struct</span> foo<span class="op">,</span> d<span class="op">));</span></span>
<span id="cb445-17"><a href="#cb445-17"></a><span class="op">}</span></span></code></pre></div>
<p>Para mí, estas salidas:</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb446-1"><a href="#cb446-1" aria-hidden="true" tabindex="-1"></a>0</span>
<span id="cb446-2"><a href="#cb446-2" aria-hidden="true" tabindex="-1"></a>4</span>
<span id="cb446-3"><a href="#cb446-3" aria-hidden="true" tabindex="-1"></a>8</span>
<span id="cb446-4"><a href="#cb446-4" aria-hidden="true" tabindex="-1"></a>12</span></code></pre></div>
<p>indicando que estamos utilizando 4 bytes para cada uno de los campos. Es un poco raro, porque <code>char</code> es sólo 1 byte, ¿verdad? El compilador está poniendo 3 bytes de relleno después de cada <code>char</code> para que todos los campos tengan 4 bytes. Presumiblemente esto se ejecutará más rápido en mi CPU.</p>
<p></p>
<!--

6.7.2.1

15 Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.

6.2.7 Compatible type and composite type

1 Two types have compatible type if their types are the same.

6.5

7 An object shall have its stored value accessed only by an lvalue expression that has one of the following types:

- a type compatible with the effective type of the object

-->
<h2 data-number="20.7" id="fake-oop"><span class="header-section-number">20.7</span> Falsa OOP</h2>
<p>Hay una cosa un poco abusiva que es una especie de OOP-como que se puede hacer con <code>struct</code>s.</p>
<p>Dado que el puntero a la <code>struct</code> es el mismo que un puntero al primer elemento de la <code>struct</code>, puedes lanzar libremente un puntero a la <code>struct</code> a un puntero al primer elemento.</p>
<p>Esto significa que podemos crear una situación como la siguiente:</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb447-1"><a href="#cb447-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> parent <span class="op">{</span></span>
<span id="cb447-2"><a href="#cb447-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb447-3"><a href="#cb447-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb447-4"><a href="#cb447-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb447-5"><a href="#cb447-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> child <span class="op">{</span></span>
<span id="cb447-6"><a href="#cb447-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> parent super<span class="op">;</span>  <span class="co">// DEBE ser el primero</span></span>
<span id="cb447-7"><a href="#cb447-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c<span class="op">,</span> d<span class="op">;</span></span>
<span id="cb447-8"><a href="#cb447-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Entonces podemos pasar un puntero a una <code>struct hija</code> a una función que espera o bien eso <em>o</em> ¡un puntero a una <code>struct padre</code>!</p>
<p>Como <code>struct padre super</code> es el primer elemento de <code>struct hijo</code>, un puntero a cualquier <code>struct hijo</code> es lo mismo que un puntero a ese campo <code>super</code><a href="#fn135" class="footnote-ref" id="fnref135" role="doc-noteref"><sup>135</sup></a>.</p>
<p>Pongamos un ejemplo. Haremos <code>struct</code>s como arriba, pero luego pasaremos un puntero a una <code>struct hija</code> a una función que necesita un puntero a una <code>struct padre</code>… y seguirá funcionando.</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb448-1"><a href="#cb448-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb448-2"><a href="#cb448-2"></a></span>
<span id="cb448-3"><a href="#cb448-3"></a><span class="kw">struct</span> parent <span class="op">{</span></span>
<span id="cb448-4"><a href="#cb448-4"></a>    <span class="dt">int</span> a<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb448-5"><a href="#cb448-5"></a><span class="op">};</span></span>
<span id="cb448-6"><a href="#cb448-6"></a></span>
<span id="cb448-7"><a href="#cb448-7"></a><span class="kw">struct</span> child <span class="op">{</span></span>
<span id="cb448-8"><a href="#cb448-8"></a>    <span class="kw">struct</span> parent super<span class="op">;</span>  <span class="co">// DEBE ser el primero</span></span>
<span id="cb448-9"><a href="#cb448-9"></a>    <span class="dt">int</span> c<span class="op">,</span> d<span class="op">;</span></span>
<span id="cb448-10"><a href="#cb448-10"></a><span class="op">};</span></span>
<span id="cb448-11"><a href="#cb448-11"></a></span>
<span id="cb448-12"><a href="#cb448-12"></a><span class="co">// Haciendo el argumento `void*` para que podamos pasarle cualquier tipo</span></span>
<span id="cb448-13"><a href="#cb448-13"></a><span class="co">// (es decir, un struct padre o struct hijo)</span></span>
<span id="cb448-14"><a href="#cb448-14"></a><span class="dt">void</span> print_parent<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>p<span class="op">)</span></span>
<span id="cb448-15"><a href="#cb448-15"></a><span class="op">{</span></span>
<span id="cb448-16"><a href="#cb448-16"></a>    <span class="co">// Espera una estructura padre--pero una estructura hijo también funcionará</span></span>
<span id="cb448-17"><a href="#cb448-17"></a>    <span class="co">// porque el puntero apunta al struct padre en el primer</span></span>
<span id="cb448-18"><a href="#cb448-18"></a>    <span class="co">// campo:</span></span>
<span id="cb448-19"><a href="#cb448-19"></a>    <span class="kw">struct</span> parent <span class="op">*</span>self <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb448-20"><a href="#cb448-20"></a></span>
<span id="cb448-21"><a href="#cb448-21"></a>    printf<span class="op">(</span><span class="st">&quot;Parent: </span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> self<span class="op">-&gt;</span>a<span class="op">,</span> self<span class="op">-&gt;</span>b<span class="op">);</span></span>
<span id="cb448-22"><a href="#cb448-22"></a><span class="op">}</span></span>
<span id="cb448-23"><a href="#cb448-23"></a></span>
<span id="cb448-24"><a href="#cb448-24"></a><span class="dt">void</span> print_child<span class="op">(</span><span class="kw">struct</span> child <span class="op">*</span>self<span class="op">)</span></span>
<span id="cb448-25"><a href="#cb448-25"></a><span class="op">{</span></span>
<span id="cb448-26"><a href="#cb448-26"></a>    printf<span class="op">(</span><span class="st">&quot;Child: </span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> self<span class="op">-&gt;</span>c<span class="op">,</span> self<span class="op">-&gt;</span>d<span class="op">);</span></span>
<span id="cb448-27"><a href="#cb448-27"></a><span class="op">}</span></span>
<span id="cb448-28"><a href="#cb448-28"></a></span>
<span id="cb448-29"><a href="#cb448-29"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb448-30"><a href="#cb448-30"></a><span class="op">{</span></span>
<span id="cb448-31"><a href="#cb448-31"></a>    <span class="kw">struct</span> child c <span class="op">=</span> <span class="op">{.</span>super<span class="op">.</span>a<span class="op">=</span><span class="dv">1</span><span class="op">,</span> <span class="op">.</span>super<span class="op">.</span>b<span class="op">=</span><span class="dv">2</span><span class="op">,</span> <span class="op">.</span>c<span class="op">=</span><span class="dv">3</span><span class="op">,</span> <span class="op">.</span>d<span class="op">=</span><span class="dv">4</span><span class="op">};</span></span>
<span id="cb448-32"><a href="#cb448-32"></a></span>
<span id="cb448-33"><a href="#cb448-33"></a>    print_child<span class="op">(&amp;</span>c<span class="op">);</span></span>
<span id="cb448-34"><a href="#cb448-34"></a>    print_parent<span class="op">(&amp;</span>c<span class="op">);</span>  <span class="co">// ¡También funciona aunque sea un struct hijo!</span></span>
<span id="cb448-35"><a href="#cb448-35"></a><span class="op">}</span></span></code></pre></div>
<p>¿Ves lo que hemos hecho en la última línea de <code>main()</code>? Llamamos a <code>print_parent()</code> pero pasamos una <code>struct child*</code> como argumento. Aunque <code>print_parent()</code> necesita que el argumento apunte a una <code>struct padre</code>, nos estamos <em>saliendo con la nuestra</em> porque el primer campo de la <code>struct hija</code> es una <code>struct padre</code>.</p>
<p>De nuevo, esto funciona porque un puntero a una <code>struct</code> tiene el mismo valor que un puntero al primer campo de esa <code>struct</code>.</p>
<p>Todo depende de esta parte de la especificación:</p>
<blockquote>
<p><strong>§6.7.2.1¶15</strong> […] Un puntero a un objeto estructura, convenientemente convertido, apunta a su miembro inicial […], y viceversa.</p>
</blockquote>
<p>y</p>
<p>§§6.5¶7** Sólo se puede acceder al valor almacenado de un objeto mediante una expresión &gt; expresión lvalue que tenga uno de los siguientes tipos: &gt; &gt; * un tipo compatible con el tipo efectivo del objeto &gt; * […]</p>
<p>y mi suposición de que “convenientemente convertido” significa “moldeado al tipo efectivo del miembro inicial”.</p>
<h2 data-number="20.8" id="campos-de-bits"><span class="header-section-number">20.8</span> Campos de bits</h2>
<p></p>
<p>En mi experiencia, rara vez se utilizan, pero puede que los veas por ahí de vez en cuando, especialmente en aplicaciones de bajo nivel que empaquetan bits en espacios más grandes.</p>
<p>Echemos un vistazo a algo de código para demostrar un caso de uso:</p>
<div class="sourceCode" id="cb449"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb449-1"><a href="#cb449-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb449-2"><a href="#cb449-2"></a></span>
<span id="cb449-3"><a href="#cb449-3"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb449-4"><a href="#cb449-4"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb449-5"><a href="#cb449-5"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> b<span class="op">;</span></span>
<span id="cb449-6"><a href="#cb449-6"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> c<span class="op">;</span></span>
<span id="cb449-7"><a href="#cb449-7"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> d<span class="op">;</span></span>
<span id="cb449-8"><a href="#cb449-8"></a><span class="op">};</span></span>
<span id="cb449-9"><a href="#cb449-9"></a></span>
<span id="cb449-10"><a href="#cb449-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb449-11"><a href="#cb449-11"></a><span class="op">{</span></span>
<span id="cb449-12"><a href="#cb449-12"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> foo<span class="op">));</span></span>
<span id="cb449-13"><a href="#cb449-13"></a><span class="op">}</span></span></code></pre></div>
<p>Para mí, esto imprime <code>16</code>. Lo cual tiene sentido, ya que <code>unsigned</code>s son 4 bytes en mi sistema.</p>
<p>Pero, ¿y si supiéramos que todos los valores que se van a almacenar en <code>a</code> y <code>b</code> se pueden almacenar en 5 bits, y los valores en <code>c</code>, y <code>d</code> se pueden almacenar en 3 bits? Eso es sólo un total de 16 bits. ¿Por qué tener 128 bits reservados para ellos si sólo vamos a usar 16?</p>
<p>Bueno, podemos decirle a C que por favor intente empaquetar estos valores. Podemos especificar el número máximo de bits que pueden tener los valores (desde 1 hasta el tamaño del tipo que los contiene).</p>
<p>Esto se hace poniendo dos puntos después del nombre del campo, seguido del ancho del campo en bits.</p>
<div class="sourceCode" id="cb450" data-startFrom="3"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 2;"><span id="cb450-3"><a href="#cb450-3"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb450-4"><a href="#cb450-4"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> a<span class="op">:</span><span class="dv">5</span><span class="op">;</span></span>
<span id="cb450-5"><a href="#cb450-5"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> b<span class="op">:</span><span class="dv">5</span><span class="op">;</span></span>
<span id="cb450-6"><a href="#cb450-6"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> c<span class="op">:</span><span class="dv">3</span><span class="op">;</span></span>
<span id="cb450-7"><a href="#cb450-7"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> d<span class="op">:</span><span class="dv">3</span><span class="op">;</span></span>
<span id="cb450-8"><a href="#cb450-8"></a><span class="op">};</span></span></code></pre></div>
<p>Ahora, cuando le pregunto a C cuánto mide mi <code>estructura foo</code>, ¡me dice 4! Eran 16 bytes, pero ahora son sólo 4. Ha “empaquetado” esos 4 valores en 4 bytes, lo que supone un ahorro de memoria cuatro veces mayor.</p>
<p>La contrapartida es, por supuesto, que los campos de 5 bits sólo pueden contener valores del 0 al 31 y los de 3 bits sólo pueden contener valores del 0 al 7. Pero la vida es así. Pero, al fin y al cabo, la vida es un compromiso.</p>
<h3 data-number="20.8.1" id="campos-de-bits-no-adyacentes"><span class="header-section-number">20.8.1</span> Campos de bits no adyacentes</h3>
<p>Un inconveniente: C sólo combinará campos de bits <strong>adyacentes</strong>. Si están interrumpidos por campos que no son de bits, no se ahorra nada:</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb451-1"><a href="#cb451-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span> <span class="co">// sizeof(struct foo) == 16 (para mí)</span></span>
<span id="cb451-2"><a href="#cb451-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> a<span class="op">:</span><span class="dv">1</span><span class="op">;</span> <span class="co">// ya que a no es adyacente a c.</span></span>
<span id="cb451-3"><a href="#cb451-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> b<span class="op">;</span></span>
<span id="cb451-4"><a href="#cb451-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> c<span class="op">:</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb451-5"><a href="#cb451-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> d<span class="op">;</span></span>
<span id="cb451-6"><a href="#cb451-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>En ese ejemplo, como “a” no es adyacente a “c”, ambas están “empaquetadas” en sus propios “int”.</p>
<p>Así que tenemos un <code>int</code> para <code>a</code>, <code>b</code>, <code>c</code> y <code>d</code>. Como mis <code>int</code>s son de 4 bytes, hay un total de 16 bytes.</p>
<p>Una rápida reorganización nos permite ahorrar espacio, de 16 a 12 bytes (en mi sistema):</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb452-1"><a href="#cb452-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span>            <span class="co">// sizeof(struct foo) == 12 (para mí)</span></span>
<span id="cb452-2"><a href="#cb452-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> a<span class="op">:</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb452-3"><a href="#cb452-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> c<span class="op">:</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb452-4"><a href="#cb452-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> b<span class="op">;</span></span>
<span id="cb452-5"><a href="#cb452-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> d<span class="op">;</span></span>
<span id="cb452-6"><a href="#cb452-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Y ahora, como <code>a</code> está junto a <code>c</code>, el compilador los junta en un único <code>int</code>.</p>
<p>Así que tenemos un <code>int</code> para <code>a</code> y <code>c</code> combinados, y un <code>int</code> para <code>b</code> y <code>d</code>. Para un total de 3 <code>int</code>s, o 12 bytes.</p>
<p>Pon todos tus campos de bits juntos para que el compilador los combine.</p>
<h3 data-number="20.8.2" id="ints-con-signo-o-sin-signo"><span class="header-section-number">20.8.2</span> <code>int</code>s con signo o sin signo</h3>
<p>Si simplemente declaras un campo de bits como <code>int</code>, los diferentes compiladores lo tratarán como <code>signed</code> o <code>unsigned</code>. Igual que ocurre con <code>char</code>.</p>
<p>Sea específico sobre el signo cuando utilice campos de bits.</p>
<h3 data-number="20.8.3" id="campos-de-bits-sin-nombre"><span class="header-section-number">20.8.3</span> Campos de bits sin nombre</h3>
<p>En algunas circunstancias concretas, puede que necesites reservar algunos bits por razones de hardware, pero no necesites utilizarlos en código.</p>
<p>Por ejemplo, supongamos que tenemos un byte en el que los 2 bits superiores tienen un significado, el bit inferior tiene un significado, pero los 5 bits centrales no los usamos<a href="#fn136" class="footnote-ref" id="fnref136" role="doc-noteref"><sup>136</sup></a>.</p>
<p>Podríamos hacer algo así:</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb453-1"><a href="#cb453-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb453-2"><a href="#cb453-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> a<span class="op">:</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb453-3"><a href="#cb453-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> dummy<span class="op">:</span><span class="dv">5</span><span class="op">;</span></span>
<span id="cb453-4"><a href="#cb453-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> b<span class="op">:</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb453-5"><a href="#cb453-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Y eso funciona–en nuestro código usamos <code>a</code> y <code>b</code>, pero nunca <code>dummy</code>. Sólo está ahí para consumir 5 bits y asegurarse de que “a” y “b” están en las posiciones “requeridas” (por este ejemplo artificial) dentro del byte.</p>
<p>C nos permite una forma de limpiar esto: campos de bits sin nombre. Puedes omitir el nombre (<code>dummy</code>) en este caso, y C está perfectamente satisfecho con el mismo efecto:</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb454-1"><a href="#cb454-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb454-2"><a href="#cb454-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> a<span class="op">:</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb454-3"><a href="#cb454-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">:</span><span class="dv">5</span><span class="op">;</span>   <span class="co">// &lt;--  campo de bits sin nombre</span></span>
<span id="cb454-4"><a href="#cb454-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> b<span class="op">:</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb454-5"><a href="#cb454-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 data-number="20.8.4" id="campos-de-bits-sin-nombre-de-ancho-cero"><span class="header-section-number">20.8.4</span> Campos de bits sin nombre de ancho cero</h3>
<p>Algo más de esoterismo por aquí… Digamos que estás empaquetando bits en un <code>unsigned int</code>, y necesitas algunos campos de bits adyacentes para empaquetarlos en el <em>siguiente</em> <code>unsigned int</code>.</p>
<p>Es decir, si haces esto:</p>
<div class="sourceCode" id="cb455"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb455-1"><a href="#cb455-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb455-2"><a href="#cb455-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> a<span class="op">:</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb455-3"><a href="#cb455-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> b<span class="op">:</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb455-4"><a href="#cb455-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> c<span class="op">:</span><span class="dv">3</span><span class="op">;</span></span>
<span id="cb455-5"><a href="#cb455-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> d<span class="op">:</span><span class="dv">4</span><span class="op">;</span></span>
<span id="cb455-6"><a href="#cb455-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>el compilador los empaqueta todos en un único <code>unsigned int</code>. ¿Pero qué pasa si necesitas <code>a</code> y <code>b</code> en un <code>int</code>, y <code>c</code> y <code>d</code> en otro diferente?</p>
<p>Hay una solución para eso: poner un campo de bits sin nombre de ancho <code>0</code> donde quieras que el compilador empiece de nuevo a empaquetar bits en un <code>int</code> diferente:</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb456-1"><a href="#cb456-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb456-2"><a href="#cb456-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> a<span class="op">:</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb456-3"><a href="#cb456-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> b<span class="op">:</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb456-4"><a href="#cb456-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> <span class="op">:</span><span class="dv">0</span><span class="op">;</span>   <span class="co">// &lt;--Campo de bits sin nombre de ancho cero</span></span>
<span id="cb456-5"><a href="#cb456-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> c<span class="op">:</span><span class="dv">3</span><span class="op">;</span></span>
<span id="cb456-6"><a href="#cb456-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> d<span class="op">:</span><span class="dv">4</span><span class="op">;</span></span>
<span id="cb456-7"><a href="#cb456-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Es análogo a un salto de página explícito en un procesador de textos. Le estás diciendo al compilador: “Deja de empaquetar bits en este <code>unsigned</code>, y empieza a empaquetarlos en el siguiente”.</p>
<p>Añadiendo el campo de bits sin nombre de ancho cero en ese lugar, el compilador pone <code>a</code> y <code>b</code> en un <code>unsigned int</code>, y <code>c</code> y <code>d</code> en otro <code>unsigned int</code>. Dos en total, para un tamaño de 8 bytes en mi sistema (<code>unsigned int</code>s son 4 bytes cada uno).</p>
<p></p>
<h2 data-number="20.9" id="uniones-unions"><span class="header-section-number">20.9</span> Uniones (Unions)</h2>
<p></p>
<p>Son básicamente como <code>struct</code>s, excepto que los campos se solapan en memoria. La <code>union</code> sólo será lo suficientemente grande para el campo más grande, y sólo se puede utilizar un campo a la vez.</p>
<p>Es una forma de reutilizar el mismo espacio de memoria para distintos tipos de datos.</p>
<p>Los declaras como <code>struct</code>s, excepto que es <code>union</code>. Echa un vistazo a esto:</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb457-1"><a href="#cb457-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> foo <span class="op">{</span></span>
<span id="cb457-2"><a href="#cb457-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">,</span> d<span class="op">,</span> e<span class="op">,</span> f<span class="op">;</span></span>
<span id="cb457-3"><a href="#cb457-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> g<span class="op">,</span> h<span class="op">;</span></span>
<span id="cb457-4"><a href="#cb457-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">,</span> l<span class="op">;</span></span>
<span id="cb457-5"><a href="#cb457-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Eso son muchos campos. Si esto fuera una <code>estructura</code>, mi sistema me diría que se necesitan 36 bytes para contenerlo todo.</p>
<p>Pero es una <code>union</code>, así que todos esos campos se solapan en el mismo espacio de memoria. El más grande es <code>int</code> (o <code>float</code>), que ocupa 4 bytes en mi sistema. Y, de hecho, si pregunto por el <code>sizeof</code> de la <code>unión foo</code>, ¡me dice 4!</p>
<p>El inconveniente es que sólo se puede utilizar uno de esos campos a la vez. Pero…</p>
<h3 data-number="20.9.1" id="union-type-punning"><span class="header-section-number">20.9.1</span> Unions y Tipo Punning</h3>
<p></p>
<p>Se puede escribir de forma no portátil en un campo <code>union</code> y leer de otro.</p>
<p>Esto se llama <a href="https://en.wikipedia.org/wiki/Type_punning">type punning</a><a href="#fn137" class="footnote-ref" id="fnref137" role="doc-noteref"><sup>137</sup></a>, y lo usarías si realmente supieras lo que estás haciendo, normalmente con algún tipo de programación de bajo nivel.</p>
<p>Dado que los miembros de una unión comparten la misma memoria, escribir en un miembro afecta necesariamente a los demás. Y si se lee de uno lo que se ha escrito en otro, se obtienen efectos extraños.</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb458-1"><a href="#cb458-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb458-2"><a href="#cb458-2"></a></span>
<span id="cb458-3"><a href="#cb458-3"></a><span class="kw">union</span> foo <span class="op">{</span></span>
<span id="cb458-4"><a href="#cb458-4"></a>    <span class="dt">float</span> b<span class="op">;</span></span>
<span id="cb458-5"><a href="#cb458-5"></a>    <span class="dt">short</span> a<span class="op">;</span></span>
<span id="cb458-6"><a href="#cb458-6"></a><span class="op">};</span></span>
<span id="cb458-7"><a href="#cb458-7"></a></span>
<span id="cb458-8"><a href="#cb458-8"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb458-9"><a href="#cb458-9"></a><span class="op">{</span></span>
<span id="cb458-10"><a href="#cb458-10"></a>    <span class="kw">union</span> foo x<span class="op">;</span></span>
<span id="cb458-11"><a href="#cb458-11"></a></span>
<span id="cb458-12"><a href="#cb458-12"></a>    x<span class="op">.</span>b <span class="op">=</span> <span class="fl">3.14159</span><span class="op">;</span></span>
<span id="cb458-13"><a href="#cb458-13"></a></span>
<span id="cb458-14"><a href="#cb458-14"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">.</span>b<span class="op">);</span>  <span class="co">// 3.14159, bastante justo</span></span>
<span id="cb458-15"><a href="#cb458-15"></a></span>
<span id="cb458-16"><a href="#cb458-16"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">.</span>a<span class="op">);</span>  <span class="co">// Pero, ¿y esto?</span></span>
<span id="cb458-17"><a href="#cb458-17"></a><span class="op">}</span></span></code></pre></div>
<p>En mi sistema, esto se imprime:</p>
<pre><code>3.141590
4048</code></pre>
<p>porque bajo el capó, la representación del objeto para el float <code>3.14159</code> era la misma que la representación del objeto para el short <code>4048</code>. En mi sistema. Tus resultados pueden variar.</p>
<p></p>
<h3 data-number="20.9.2" id="punteros-a-unions"><span class="header-section-number">20.9.2</span> Punteros a <code>union</code>s</h3>
<p></p>
<p>Si tienes un puntero a una <code>union</code>, puedes convertir ese puntero a cualquiera de los tipos de los campos de esa <code>union</code> y obtener los valores de esa forma.</p>
<p>En este ejemplo, vemos que la <code>union</code> tiene <code>int</code>s y <code>float</code>s en ella. Y obtenemos punteros a la <code>union</code>, pero los convertimos a los tipos <code>int*</code> y <code>float*</code> (la conversión silencia las advertencias del compilador). Y si los desreferenciamos, vemos que tienen los valores que almacenamos directamente en la “unión”.</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb460-1"><a href="#cb460-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb460-2"><a href="#cb460-2"></a></span>
<span id="cb460-3"><a href="#cb460-3"></a><span class="kw">union</span> foo <span class="op">{</span></span>
<span id="cb460-4"><a href="#cb460-4"></a>    <span class="dt">int</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">,</span> d<span class="op">,</span> e<span class="op">,</span> f<span class="op">;</span></span>
<span id="cb460-5"><a href="#cb460-5"></a>    <span class="dt">float</span> g<span class="op">,</span> h<span class="op">;</span></span>
<span id="cb460-6"><a href="#cb460-6"></a>    <span class="dt">char</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">,</span> l<span class="op">;</span></span>
<span id="cb460-7"><a href="#cb460-7"></a><span class="op">};</span></span>
<span id="cb460-8"><a href="#cb460-8"></a></span>
<span id="cb460-9"><a href="#cb460-9"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb460-10"><a href="#cb460-10"></a><span class="op">{</span></span>
<span id="cb460-11"><a href="#cb460-11"></a>    <span class="kw">union</span> foo x<span class="op">;</span></span>
<span id="cb460-12"><a href="#cb460-12"></a></span>
<span id="cb460-13"><a href="#cb460-13"></a>    <span class="dt">int</span> <span class="op">*</span>foo_int_p <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)&amp;</span>x<span class="op">;</span></span>
<span id="cb460-14"><a href="#cb460-14"></a>    <span class="dt">float</span> <span class="op">*</span>foo_float_p <span class="op">=</span> <span class="op">(</span><span class="dt">float</span> <span class="op">*)&amp;</span>x<span class="op">;</span></span>
<span id="cb460-15"><a href="#cb460-15"></a></span>
<span id="cb460-16"><a href="#cb460-16"></a>    x<span class="op">.</span>a <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb460-17"><a href="#cb460-17"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">.</span>a<span class="op">);</span>           <span class="co">// 12</span></span>
<span id="cb460-18"><a href="#cb460-18"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>foo_int_p<span class="op">);</span>    <span class="co">// 12, nuevamente</span></span>
<span id="cb460-19"><a href="#cb460-19"></a></span>
<span id="cb460-20"><a href="#cb460-20"></a>    x<span class="op">.</span>g <span class="op">=</span> <span class="fl">3.141592</span><span class="op">;</span></span>
<span id="cb460-21"><a href="#cb460-21"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">.</span>g<span class="op">);</span>           <span class="co">// 3.141592</span></span>
<span id="cb460-22"><a href="#cb460-22"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>foo_float_p<span class="op">);</span>  <span class="co">// 3.141592, nuevamente</span></span>
<span id="cb460-23"><a href="#cb460-23"></a><span class="op">}</span></span></code></pre></div>
<p>Lo contrario también es cierto. Si tenemos un puntero a un tipo dentro de <code>union</code>, podemos convertirlo en un puntero a <code>union</code> y acceder a sus miembros.</p>
<div class="sourceCode" id="cb461"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb461-1"><a href="#cb461-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> foo x<span class="op">;</span></span>
<span id="cb461-2"><a href="#cb461-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>foo_int_p <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)&amp;</span>x<span class="op">;</span>             <span class="co">// Puntero a campo int</span></span>
<span id="cb461-3"><a href="#cb461-3" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> foo <span class="op">*</span>p <span class="op">=</span> <span class="op">(</span><span class="kw">union</span> foo <span class="op">*)</span>foo_int_p<span class="op">;</span>  <span class="co">// Volver al puntero de la unión</span></span>
<span id="cb461-4"><a href="#cb461-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb461-5"><a href="#cb461-5" aria-hidden="true" tabindex="-1"></a>p<span class="op">-&gt;</span>a <span class="op">=</span> <span class="dv">12</span><span class="op">;</span>  <span class="co">// Esta línea es la misma que...</span></span>
<span id="cb461-6"><a href="#cb461-6" aria-hidden="true" tabindex="-1"></a>x<span class="op">.</span>a <span class="op">=</span> <span class="dv">12</span><span class="op">;</span>   <span class="co">// este.</span></span></code></pre></div>
<p>Todo esto sólo te permite saber que, bajo el capó, todos estos valores en un <code>union</code> comienzan en el mismo lugar en la memoria, y eso es lo mismo que donde todo el `union es.</p>
<p></p>
<h3 data-number="20.9.3" id="secuencias-iniciales-comunes-en-las-uniones"><span class="header-section-number">20.9.3</span> Secuencias iniciales comunes en las uniones</h3>
<p></p>
<p>Si tienes una <code>union</code> de <code>struct</code>s, y todas esas <code>struct</code>s empiezan con una <em>secuencia inicial común</em>, es válido acceder a miembros de esa secuencia desde cualquiera de los miembros de la <code>union</code>.</p>
<p>¿Cómo?</p>
<p>Aquí hay dos <code>struct</code>s con una secuencia inicial común:</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb462-1"><a href="#cb462-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> a <span class="op">{</span></span>
<span id="cb462-2"><a href="#cb462-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span>     <span class="co">//</span></span>
<span id="cb462-3"><a href="#cb462-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> y<span class="op">;</span>   <span class="co">// Secuencia inicial común</span></span>
<span id="cb462-4"><a href="#cb462-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb462-5"><a href="#cb462-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb462-6"><a href="#cb462-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb462-7"><a href="#cb462-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb462-8"><a href="#cb462-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> b <span class="op">{</span></span>
<span id="cb462-9"><a href="#cb462-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span>     <span class="co">//</span></span>
<span id="cb462-10"><a href="#cb462-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> y<span class="op">;</span>   <span class="co">// Secuencia inicial común</span></span>
<span id="cb462-11"><a href="#cb462-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb462-12"><a href="#cb462-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb462-13"><a href="#cb462-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">short</span> z<span class="op">;</span></span>
<span id="cb462-14"><a href="#cb462-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>¿Lo ves? Es que empiezan con <code>int</code> seguido de <code>float</code>—esa es la secuencia inicial común. Los miembros en la secuencia de las <code>struct</code>s tienen que ser tipos compatibles. Y lo vemos con <code>x</code> y <code>y</code>, que son <code>int</code> y <code>float</code> respectivamente.</p>
<p>Ahora vamos a construir una unión de estos:</p>
<div class="sourceCode" id="cb463"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb463-1"><a href="#cb463-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> foo <span class="op">{</span></span>
<span id="cb463-2"><a href="#cb463-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> a sa<span class="op">;</span></span>
<span id="cb463-3"><a href="#cb463-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> b sb<span class="op">;</span></span>
<span id="cb463-4"><a href="#cb463-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Lo que nos dice esta regla es que tenemos garantizado que los miembros de las secuencias iniciales comunes son intercambiables en código. Es decir:</p>
<ul>
<li><code>f.sa.x</code> es lo mismo que <code>f.sb.x</code>.</li>
</ul>
<p>y</p>
<ul>
<li><code>f.sa.y</code> es lo mismo que <code>f.sb.y</code>.</li>
</ul>
<p>Porque los campos <code>x</code> e <code>y</code> están ambos en la secuencia inicial común.</p>
<p>Además, los nombres de los miembros de la secuencia inicial común no importan. todo lo que importa es que los tipos son los mismos.</p>
<p>En conjunto, esto nos permite añadir de forma segura alguna información compartida entre <code>struct</code>s en la <code>union</code>. El mejor ejemplo de esto es probablemente el uso de un campo para determinar el tipo de <code>struct</code> de todas las <code>struct</code>s en la <code>union</code> que está actualmente “en uso”.</p>
<p>Es decir, si no se nos permitiera esto y pasáramos la <code>union</code> a alguna función, ¿cómo sabría esa función qué miembro de la <code>union</code> es el que debería mirar?</p>
<p>Echa un vistazo a estas <code>struct</code>s. Observa la secuencia inicial común:</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb464-1"><a href="#cb464-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb464-2"><a href="#cb464-2"></a></span>
<span id="cb464-3"><a href="#cb464-3"></a><span class="kw">struct</span> common <span class="op">{</span></span>
<span id="cb464-4"><a href="#cb464-4"></a>    <span class="dt">int</span> type<span class="op">;</span>   <span class="co">// secuencia inicial común</span></span>
<span id="cb464-5"><a href="#cb464-5"></a><span class="op">};</span></span>
<span id="cb464-6"><a href="#cb464-6"></a></span>
<span id="cb464-7"><a href="#cb464-7"></a><span class="kw">struct</span> antelope <span class="op">{</span></span>
<span id="cb464-8"><a href="#cb464-8"></a>    <span class="dt">int</span> type<span class="op">;</span>   <span class="co">// secuencia inicial común</span></span>
<span id="cb464-9"><a href="#cb464-9"></a></span>
<span id="cb464-10"><a href="#cb464-10"></a>    <span class="dt">int</span> loudness<span class="op">;</span></span>
<span id="cb464-11"><a href="#cb464-11"></a><span class="op">};</span></span>
<span id="cb464-12"><a href="#cb464-12"></a></span>
<span id="cb464-13"><a href="#cb464-13"></a><span class="kw">struct</span> octopus <span class="op">{</span></span>
<span id="cb464-14"><a href="#cb464-14"></a>    <span class="dt">int</span> type<span class="op">;</span>   <span class="co">// secuencia inicial común</span></span>
<span id="cb464-15"><a href="#cb464-15"></a></span>
<span id="cb464-16"><a href="#cb464-16"></a>    <span class="dt">int</span> sea_creature<span class="op">;</span></span>
<span id="cb464-17"><a href="#cb464-17"></a>    <span class="dt">float</span> intelligence<span class="op">;</span></span>
<span id="cb464-18"><a href="#cb464-18"></a><span class="op">};</span></span></code></pre></div>
<p>Ahora vamos a meterlos en un <code>union</code>:</p>
<div class="sourceCode" id="cb465" data-startFrom="20"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 19;"><span id="cb465-20"><a href="#cb465-20"></a><span class="kw">union</span> animal <span class="op">{</span></span>
<span id="cb465-21"><a href="#cb465-21"></a>    <span class="kw">struct</span> common common<span class="op">;</span></span>
<span id="cb465-22"><a href="#cb465-22"></a>    <span class="kw">struct</span> antelope antelope<span class="op">;</span></span>
<span id="cb465-23"><a href="#cb465-23"></a>    <span class="kw">struct</span> octopus octopus<span class="op">;</span></span>
<span id="cb465-24"><a href="#cb465-24"></a><span class="op">};</span></span></code></pre></div>
<p>También, permítanme estos dos <code>#define</code>s para la demo:</p>
<div class="sourceCode" id="cb466" data-startFrom="26"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 25;"><span id="cb466-26"><a href="#cb466-26"></a><span class="pp">#define ANTELOPE </span><span class="dv">1</span></span>
<span id="cb466-27"><a href="#cb466-27"></a><span class="pp">#define OCTOPUS  </span><span class="dv">2</span></span></code></pre></div>
<p>Hasta ahora, aquí no ha pasado nada especial. Parece que el campo <code>type</code> es completamente inútil.</p>
<p>Pero ahora hagamos una función genérica que imprima un <code>union animal</code>. De alguna manera tiene que ser capaz de decir si está mirando un <code>struct antílope</code> o un <code>struct pulpo</code>.</p>
<p>Gracias a la magia de las secuencias iniciales comunes, puede buscar el tipo de animal en cualquiera de estos lugares para un <code>animal de unión x</code> en particular:</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb467-1"><a href="#cb467-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> type <span class="op">=</span> x<span class="op">.</span>common<span class="op">.</span>type<span class="op">;</span>    \\ or<span class="op">...</span></span>
<span id="cb467-2"><a href="#cb467-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> type <span class="op">=</span> x<span class="op">.</span>antelope<span class="op">.</span>type<span class="op">;</span>  \\ or<span class="op">...</span></span>
<span id="cb467-3"><a href="#cb467-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> type <span class="op">=</span> x<span class="op">.</span>octopus<span class="op">.</span>type<span class="op">;</span></span></code></pre></div>
<p>Todos ellos se refieren al mismo valor en memoria.</p>
<p>Y, como habrás adivinado, el <code>struct common</code> está ahí para que el código pueda mirar agnósticamente el tipo sin mencionar un animal en particular.</p>
<p>Veamos el código para imprimir un <code>union animal</code>:</p>
<div class="sourceCode" id="cb468" data-startFrom="29"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 28;"><span id="cb468-29"><a href="#cb468-29"></a><span class="dt">void</span> print_animal<span class="op">(</span><span class="kw">union</span> animal <span class="op">*</span>x<span class="op">)</span></span>
<span id="cb468-30"><a href="#cb468-30"></a><span class="op">{</span></span>
<span id="cb468-31"><a href="#cb468-31"></a>    <span class="cf">switch</span> <span class="op">(</span>x<span class="op">-&gt;</span>common<span class="op">.</span>type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb468-32"><a href="#cb468-32"></a>        <span class="cf">case</span> ANTELOPE<span class="op">:</span></span>
<span id="cb468-33"><a href="#cb468-33"></a>            printf<span class="op">(</span><span class="st">&quot;Antelope: loudness=</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">-&gt;</span>antelope<span class="op">.</span>loudness<span class="op">);</span></span>
<span id="cb468-34"><a href="#cb468-34"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb468-35"><a href="#cb468-35"></a></span>
<span id="cb468-36"><a href="#cb468-36"></a>        <span class="cf">case</span> OCTOPUS<span class="op">:</span></span>
<span id="cb468-37"><a href="#cb468-37"></a>            printf<span class="op">(</span><span class="st">&quot;Octopus : sea_creature=</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">-&gt;</span>octopus<span class="op">.</span>sea_creature<span class="op">);</span></span>
<span id="cb468-38"><a href="#cb468-38"></a>            printf<span class="op">(</span><span class="st">&quot;          intelligence=</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">-&gt;</span>octopus<span class="op">.</span>intelligence<span class="op">);</span></span>
<span id="cb468-39"><a href="#cb468-39"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb468-40"><a href="#cb468-40"></a>        </span>
<span id="cb468-41"><a href="#cb468-41"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb468-42"><a href="#cb468-42"></a>            printf<span class="op">(</span><span class="st">&quot;Unknown animal type</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb468-43"><a href="#cb468-43"></a>    <span class="op">}</span></span>
<span id="cb468-44"><a href="#cb468-44"></a></span>
<span id="cb468-45"><a href="#cb468-45"></a><span class="op">}</span></span>
<span id="cb468-46"><a href="#cb468-46"></a></span>
<span id="cb468-47"><a href="#cb468-47"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb468-48"><a href="#cb468-48"></a><span class="op">{</span></span>
<span id="cb468-49"><a href="#cb468-49"></a>    <span class="kw">union</span> animal a <span class="op">=</span> <span class="op">{.</span>antelope<span class="op">.</span>type<span class="op">=</span>ANTELOPE<span class="op">,</span> <span class="op">.</span>antelope<span class="op">.</span>loudness<span class="op">=</span><span class="dv">12</span><span class="op">};</span></span>
<span id="cb468-50"><a href="#cb468-50"></a>    <span class="kw">union</span> animal b <span class="op">=</span> <span class="op">{.</span>octopus<span class="op">.</span>type<span class="op">=</span>OCTOPUS<span class="op">,</span> <span class="op">.</span>octopus<span class="op">.</span>sea_creature<span class="op">=</span><span class="dv">1</span><span class="op">,</span></span>
<span id="cb468-51"><a href="#cb468-51"></a>                                       <span class="op">.</span>octopus<span class="op">.</span>intelligence<span class="op">=</span><span class="fl">12.8</span><span class="op">};</span></span>
<span id="cb468-52"><a href="#cb468-52"></a></span>
<span id="cb468-53"><a href="#cb468-53"></a>    print_animal<span class="op">(&amp;</span>a<span class="op">);</span></span>
<span id="cb468-54"><a href="#cb468-54"></a>    print_animal<span class="op">(&amp;</span>b<span class="op">);</span></span>
<span id="cb468-55"><a href="#cb468-55"></a><span class="op">}</span></span></code></pre></div>
<p>Mira cómo en la línea 29 sólo estamos pasando la <code>union</code> –no tenemos ni idea de qué tipo de animal <code>struct</code> está en uso dentro de ella.</p>
<p>Pero no pasa nada. Porque en la línea 31 comprobamos el tipo para ver si es un antílope o un pulpo. Y entonces podemos mirar en la <code>struct</code> apropiada para obtener los miembros.</p>
<p>Definitivamente es posible conseguir este mismo efecto usando sólo <code>struct</code>s, pero puedes hacerlo de esta manera si quieres los efectos de ahorro de memoria de una <code>union</code>. </p>
<h2 data-number="20.10" id="uniones-y-estructuras-sin-nombre"><span class="header-section-number">20.10</span> Uniones y estructuras sin nombre</h2>
<p></p>
<p>Usted sabe cómo puede tener un <code>struct</code> sin nombre, así:</p>
<div class="sourceCode" id="cb469"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb469-1"><a href="#cb469-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb469-2"><a href="#cb469-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb469-3"><a href="#cb469-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> s<span class="op">;</span></span></code></pre></div>
<p>Eso define una variable <code>s</code> que es de tipo <code>struct</code> anónimo (porque la <code>struct</code> no tiene etiqueta de nombre), con los miembros <code>x</code> e <code>y</code>.</p>
<p>Así que cosas como esta son válidas:</p>
<div class="sourceCode" id="cb470"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb470-1"><a href="#cb470-1" aria-hidden="true" tabindex="-1"></a>s<span class="op">.</span>x <span class="op">=</span> <span class="dv">34</span><span class="op">;</span></span>
<span id="cb470-2"><a href="#cb470-2" aria-hidden="true" tabindex="-1"></a>s<span class="op">.</span>y <span class="op">=</span> <span class="dv">90</span><span class="op">;</span></span>
<span id="cb470-3"><a href="#cb470-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb470-4"><a href="#cb470-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">.</span>x<span class="op">,</span> s<span class="op">.</span>y<span class="op">);</span></span></code></pre></div>
<p>Resulta que puedes soltar esas <code>struct</code>s sin nombre en <code>union</code>s tal y como cabría esperar:</p>
<div class="sourceCode" id="cb471"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb471-1"><a href="#cb471-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> foo <span class="op">{</span></span>
<span id="cb471-2"><a href="#cb471-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <span class="op">{</span>       <span class="co">// sin nombre!</span></span>
<span id="cb471-3"><a href="#cb471-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb471-4"><a href="#cb471-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> a<span class="op">;</span></span>
<span id="cb471-5"><a href="#cb471-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb471-6"><a href="#cb471-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <span class="op">{</span>       <span class="co">// sin nombre!</span></span>
<span id="cb471-7"><a href="#cb471-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> z<span class="op">,</span> w<span class="op">;</span></span>
<span id="cb471-8"><a href="#cb471-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> b<span class="op">;</span></span>
<span id="cb471-9"><a href="#cb471-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Y luego acceder a ellos con normalidad:</p>
<div class="sourceCode" id="cb472"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb472-1"><a href="#cb472-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> foo f<span class="op">;</span></span>
<span id="cb472-2"><a href="#cb472-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb472-3"><a href="#cb472-3" aria-hidden="true" tabindex="-1"></a>f<span class="op">.</span>a<span class="op">.</span>x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb472-4"><a href="#cb472-4" aria-hidden="true" tabindex="-1"></a>f<span class="op">.</span>a<span class="op">.</span>y <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb472-5"><a href="#cb472-5" aria-hidden="true" tabindex="-1"></a>f<span class="op">.</span>b<span class="op">.</span>z <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb472-6"><a href="#cb472-6" aria-hidden="true" tabindex="-1"></a>f<span class="op">.</span>b<span class="op">.</span>w <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span></code></pre></div>
<p>No hay problema.</p>
<p></p>
<h2 data-number="20.11" id="pasar-y-devolver-structs-y-unions"><span class="header-section-number">20.11</span> Pasar y devolver <code>struct</code>s y <code>union</code>s</h2>
<p> </p>
<p>Puede pasar una <code>struct</code> o <code>union</code> a una función por valor (en lugar de un puntero a la misma)—se hará una copia de ese objeto al parámetro como si fuera por asignación como de costumbre.</p>
<p>También puedes devolver una <code>struct</code> o <code>union</code> de una función y también se devuelve por valor.</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb473-1"><a href="#cb473-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb473-2"><a href="#cb473-2"></a></span>
<span id="cb473-3"><a href="#cb473-3"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb473-4"><a href="#cb473-4"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb473-5"><a href="#cb473-5"></a><span class="op">};</span></span>
<span id="cb473-6"><a href="#cb473-6"></a></span>
<span id="cb473-7"><a href="#cb473-7"></a><span class="kw">struct</span> foo f<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb473-8"><a href="#cb473-8"></a><span class="op">{</span></span>
<span id="cb473-9"><a href="#cb473-9"></a>    <span class="cf">return</span> <span class="op">(</span><span class="kw">struct</span> foo<span class="op">){.</span>x<span class="op">=</span><span class="dv">34</span><span class="op">,</span> <span class="op">.</span>y<span class="op">=</span><span class="dv">90</span><span class="op">};</span></span>
<span id="cb473-10"><a href="#cb473-10"></a><span class="op">}</span></span>
<span id="cb473-11"><a href="#cb473-11"></a></span>
<span id="cb473-12"><a href="#cb473-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb473-13"><a href="#cb473-13"></a><span class="op">{</span></span>
<span id="cb473-14"><a href="#cb473-14"></a>    <span class="kw">struct</span> foo a <span class="op">=</span> f<span class="op">();</span>  <span class="co">// Se realiza la copia</span></span>
<span id="cb473-15"><a href="#cb473-15"></a></span>
<span id="cb473-16"><a href="#cb473-16"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">.</span>x<span class="op">,</span> a<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb473-17"><a href="#cb473-17"></a><span class="op">}</span></span></code></pre></div>
<p>Dato curioso: si haces esto, puedes utilizar el operador <code>.</code> justo después de la llamada a la función:</p>
<div class="sourceCode" id="cb474" data-startFrom="16"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 15;"><span id="cb474-16"><a href="#cb474-16"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> f<span class="op">().</span>x<span class="op">,</span> f<span class="op">().</span>y<span class="op">);</span></span></code></pre></div>
<p>(Por supuesto, ese ejemplo llama a la función dos veces, de forma ineficiente).</p>
<p>Y lo mismo vale para devolver punteros a <code>struct</code>s y <code>union</code>s—sólo asegúrate de usar el operador de flecha <code>-&gt;</code> en ese caso.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="21" id="caracteres-y-strings-ii"><span class="header-section-number">21</span> Caracteres y Strings II</h1>
<p>Ya hemos hablado de cómo los tipos <code>char</code> son en realidad tipos de enteros pequeños… pero es lo mismo para un carácter entre comillas simples.</p>
<p>Pero una cadena entre comillas dobles es del tipo <code>const char *</code>.</p>
<p>Resulta que hay algunos tipos más de cadenas y caracteres, y esto nos lleva a uno de los agujeros de conejo más infames del lenguaje: todo el asunto multibyte/ancho/Unicode/localización.</p>
<p>Vamos a asomarnos a esa madriguera de conejo, pero sin entrar. …¡Todavía!</p>
<h2 data-number="21.1" id="secuencias-de-escape"><span class="header-section-number">21.1</span> Secuencias de escape</h2>
<p></p>
<p>Estamos acostumbrados a cadenas y caracteres con letras, signos de puntuación y números normales:</p>
<div class="sourceCode" id="cb475"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb475-1"><a href="#cb475-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello!&quot;</span><span class="op">;</span></span>
<span id="cb475-2"><a href="#cb475-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> t <span class="op">=</span> <span class="ch">&#39;c&#39;</span><span class="op">;</span></span></code></pre></div>
<p>Pero, ¿y si queremos introducir algún carácter especial que no podemos escribir con el teclado porque no existe (por ejemplo, “€”), o incluso si queremos un carácter que sea una comilla simple? Está claro que no podemos hacerlo:</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb476-1"><a href="#cb476-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> t <span class="op">=</span> <span class="ch">&#39;</span><span class="er">&#39;</span><span class="ch">&#39;;</span></span></code></pre></div>
<p></p>
<p>Para hacer estas cosas, utilizamos algo llamado <em>secuencias de escape</em>. Se trata del carácter barra invertida (<code>\</code>) seguido de otro carácter. Los dos (o más) caracteres juntos tienen un significado especial.</p>
<p>Para nuestro ejemplo de carácter de comilla simple, podemos poner un escape (es decir, <code>\</code>) delante de la comilla simple central para resolverlo:</p>
<p></p>
<div class="sourceCode" id="cb477"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb477-1"><a href="#cb477-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> t <span class="op">=</span> <span class="ch">&#39;</span><span class="sc">\&#39;</span><span class="ch">&#39;</span><span class="op">;</span></span></code></pre></div>
<p>Ahora C sabe que <code>\'</code> significa sólo una comilla normal que queremos imprimir, no el final de la secuencia de caracteres.</p>
<p></p>
<p>Puedes decir “barra invertida” o “escape” en este contexto (“escape esa comilla”) y los desarrolladores de C sabrán de qué estás hablando. Además, “escape” en este contexto es diferente de la tecla <code>Esc</code> o del código ASCII <code>ESC</code>.</p>
<h3 data-number="21.1.1" id="escapes-de-uso-frecuente"><span class="header-section-number">21.1.1</span> Escapes de uso frecuente</h3>
<p>En mi humilde opinión, estos caracteres de escape constituyen el 99,2%<a href="#fn138" class="footnote-ref" id="fnref138" role="doc-noteref"><sup>138</sup></a> de todos los escapes.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Codigo</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\n</code></td>
<td>Carácter de nueva línea—cuando se imprime, continúa la salida subsiguiente en la línea siguiente</td>
</tr>
<tr class="even">
<td><code>\'</code></td>
<td>Comilla simple: se utiliza para una constante de carácter de comilla simple.</td>
</tr>
<tr class="odd">
<td><code>\"</code></td>
<td>Comilla doble: se utiliza para una comilla doble en una cadena literal.</td>
</tr>
<tr class="even">
<td><code>\\</code></td>
<td>Barra diagonal inversa—utilizada para un literal <code>\</code> en una cadena o carácter</td>
</tr>
</tbody>
</table>
<p>Estos son algunos ejemplos de los escapes y lo que muestran cuando se imprimen.</p>
<div class="sourceCode" id="cb478"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb478-1"><a href="#cb478-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Use </span><span class="sc">\\</span><span class="st">n for newline</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// Usar \n para nueva línea</span></span>
<span id="cb478-2"><a href="#cb478-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Say </span><span class="sc">\&quot;</span><span class="st">hello</span><span class="sc">\&quot;</span><span class="st">!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>       <span class="co">// Diga &quot;hello&quot;!</span></span>
<span id="cb478-3"><a href="#cb478-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="ch">&#39;</span><span class="sc">\&#39;</span><span class="ch">&#39;</span><span class="op">);</span>             <span class="co">// &#39;</span></span></code></pre></div>
<h3 data-number="21.1.2" id="escapes-poco-utilizados"><span class="header-section-number">21.1.2</span> Escapes poco utilizados</h3>
<p>Pero hay más escapes. Sólo que no se ven tan a menudo.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Código</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\a</code></td>
<td>Alerta. Esto hace que el terminal emita un sonido o un destello, ¡o ambos!</td>
</tr>
<tr class="even">
<td><code>\b</code></td>
<td>Retroceso. Desplaza el cursor un carácter hacia atrás. No borra el carácter.</td>
</tr>
<tr class="odd">
<td><code>\f</code></td>
<td>Alimentar formulario. Esto se mueve a la siguiente “página”, pero eso no tiene mucho significado moderno. En mi sistema, esto se comporta como <code>\v</code>.</td>
</tr>
<tr class="even">
<td><code>\r</code></td>
<td>Volver. Desplazarse al principio de la misma línea.</td>
</tr>
<tr class="odd">
<td><code>\t</code></td>
<td>Tabulador horizontal. Se mueve al siguiente tabulador horizontal. En mi máquina, esto se alinea en columnas que son múltiplos de 8, pero YMMV.</td>
</tr>
<tr class="even">
<td><code>\v</code></td>
<td>Tabulación vertical. Se mueve al siguiente tabulador vertical. En mi máquina, esto se mueve a la misma columna en la línea siguiente.</td>
</tr>
<tr class="odd">
<td><code>\?</code></td>
<td>Signo de interrogación literal. A veces es necesario para evitar los trígrafos, como se muestra a continuación.</td>
</tr>
</tbody>
</table>
<h4 data-number="21.1.2.1" id="actualizaciones-de-estado-de-línea-única"><span class="header-section-number">21.1.2.1</span> Actualizaciones de estado de línea única</h4>
<p> </p>
<p>Un caso de uso para <code>\b</code> o <code>\r</code> es mostrar actualizaciones de estado que aparecen en la misma línea en la pantalla y no causan que la pantalla se desplace. Aquí hay un ejemplo que hace una cuenta atrás desde 10. (Si tu compilador no soporta threading, puedes usar la función POSIX no estándar <code>sleep()</code> de <code>&lt;unistd.h&gt;</code>—si no estás en un Unix-like, busca tu plataforma y <code>sleep</code> para el equivalente).</p>
<div class="sourceCode" id="cb479"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb479-1"><a href="#cb479-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb479-2"><a href="#cb479-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb479-3"><a href="#cb479-3"></a></span>
<span id="cb479-4"><a href="#cb479-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb479-5"><a href="#cb479-5"></a><span class="op">{</span></span>
<span id="cb479-6"><a href="#cb479-6"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb479-7"><a href="#cb479-7"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\r</span><span class="st">T minutos </span><span class="sc">%d</span><span class="st"> segundo</span><span class="sc">%s</span><span class="st">... </span><span class="sc">\b</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> i <span class="op">!=</span> <span class="dv">1</span><span class="op">?</span> <span class="st">&quot;s&quot;</span><span class="op">:</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb479-8"><a href="#cb479-8"></a></span>
<span id="cb479-9"><a href="#cb479-9"></a>        fflush<span class="op">(</span>stdout<span class="op">);</span>  <span class="co">// Forzar la actualización de la salida</span></span>
<span id="cb479-10"><a href="#cb479-10"></a></span>
<span id="cb479-11"><a href="#cb479-11"></a>        <span class="co">// Sleep for 1 second</span></span>
<span id="cb479-12"><a href="#cb479-12"></a>        thrd_sleep<span class="op">(&amp;(</span><span class="kw">struct</span> timespec<span class="op">){.</span>tv_sec<span class="op">=</span><span class="dv">1</span><span class="op">},</span> NULL<span class="op">);</span></span>
<span id="cb479-13"><a href="#cb479-13"></a>    <span class="op">}</span></span>
<span id="cb479-14"><a href="#cb479-14"></a></span>
<span id="cb479-15"><a href="#cb479-15"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\r</span><span class="st">Liftoff!             </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb479-16"><a href="#cb479-16"></a><span class="op">}</span></span></code></pre></div>
<p>En la línea 7 ocurren varias cosas. En primer lugar, empezamos con un <code>\r</code> para llegar al principio de la línea actual, luego sobrescribimos lo que haya allí con la cuenta atrás actual. (Hay un operador ternario para asegurarnos de que imprimimos <code>1 segundo</code> en lugar de <code>1 segundos</code>).</p>
<p>Además, hay un espacio después de <code>...</code> Eso es para que sobrescribamos correctamente el último <code>.</code> cuando <code>i</code> baje de <code>10</code> a <code>9</code> y tengamos una columna más estrecha. Pruébalo sin el espacio para ver a qué me refiero.</p>
<p>Y lo envolvemos con un <code>\b</code> para retroceder sobre ese espacio para que el cursor se sitúe en el final exacto de la línea de una manera estéticamente agradable.</p>
<p></p>
<p>Observe que la línea 14 también tiene un montón de espacios al final para sobrescribir los caracteres que ya estaban allí desde la cuenta atrás.</p>
<p>Finalmente, tenemos un extraño <code>fflush(stdout)</code> ahí, sea lo que sea lo que signifique. La respuesta corta es que la mayoría de los terminales están <em>line buffered</em> por defecto, lo que significa que no muestran nada hasta que se encuentra un carácter de nueva línea. Dado que no tenemos una nueva línea (sólo tenemos <code>\r</code>), sin esta línea, el programa se quedaría ahí hasta <code>¡Liftoff!</code> y entonces imprimiría todo en un instante. <code>fflush()</code> anula este comportamiento y fuerza la salida a suceder <em>ahora</em>.</p>
<p></p>
<h4 data-number="21.1.2.2" id="la-fuga-de-los-signos-de-interrogación"><span class="header-section-number">21.1.2.2</span> La fuga de los signos de interrogación</h4>
<p></p>
<p>¿Por qué molestarse con esto? Al fin y al cabo, esto funciona muy bien:</p>
<div class="sourceCode" id="cb480"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb480-1"><a href="#cb480-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Doesn&#39;t it?</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Y también funciona bien con el escape:</p>
<div class="sourceCode" id="cb481"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb481-1"><a href="#cb481-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Doesn&#39;t it</span><span class="sc">\?\n</span><span class="st">&quot;</span><span class="op">);</span>   <span class="co">// Note \?</span></span></code></pre></div>
<p>Entonces, ¿qué sentido tiene?</p>
<p></p>
<p>Seamos más enfáticos con otro signo de interrogación y exclamación:</p>
<div class="sourceCode" id="cb482"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb482-1"><a href="#cb482-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Doesn&#39;t it??!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Cuando compilo esto, recibo esta advertencia:</p>
<div class="sourceCode" id="cb483"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb483-1"><a href="#cb483-1" aria-hidden="true" tabindex="-1"></a><span class="ex">foo.c:</span> In function ‘main’:</span>
<span id="cb483-2"><a href="#cb483-2" aria-hidden="true" tabindex="-1"></a><span class="ex">foo.c:5:23:</span> warning: trigraph <span class="pp">??</span>! converted to <span class="kw">|</span> <span class="ex">[-Wtrigraphs]</span></span>
<span id="cb483-3"><a href="#cb483-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">5</span> <span class="kw">|</span>     <span class="bu">printf</span><span class="op">(</span><span class="st">&quot;Doesn&#39;t it??!\n&quot;</span><span class="op">)</span><span class="kw">;</span></span>
<span id="cb483-4"><a href="#cb483-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">|</span>    </span></code></pre></div>
<p>Y ejecutarlo da este resultado improbable:</p>
<div class="sourceCode" id="cb484"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb484-1"><a href="#cb484-1" aria-hidden="true" tabindex="-1"></a>Doesn&#39;t it|</span></code></pre></div>
<p>¿Así que <em>trigrafías</em>? ¿Qué diablos es esto?</p>
<p>Estoy seguro de que volveremos sobre este rincón polvoriento del lenguaje más adelante, pero el resumen es que el compilador busca ciertas tripletas de caracteres que empiezan por <code>??</code> y las sustituye por otros caracteres. Así que si estás en un terminal antiguo sin el símbolo de la tubería (<code>|</code>) en el teclado, puedes escribir <code>??!</code> en su lugar.</p>
<p>Puedes arreglar esto escapando el segundo signo de interrogación, así:</p>
<div class="sourceCode" id="cb485"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb485-1"><a href="#cb485-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Doesn&#39;t it?</span><span class="sc">\?</span><span class="st">!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Y entonces se compila y funciona como se esperaba.</p>
<p>Hoy en día, por supuesto, nadie utiliza los trígrafos. Pero ese <code>??!</code> completo aparece a veces si decides usarlo en una cadena para darle énfasis. </p>
<h3 data-number="21.1.3" id="escapes-numéricos"><span class="header-section-number">21.1.3</span> Escapes numéricos</h3>
<p>Además, hay formas de especificar constantes numéricas u otros valores de caracteres dentro de cadenas o constantes de caracteres.</p>
<p>Si conoce la representación octal o hexadecimal de un byte, puede incluirla en una cadena o constante de caracteres.</p>
<p>La siguiente tabla contiene números de ejemplo, pero se puede utilizar cualquier número hexadecimal u octal. Rellene con ceros a la izquierda si es necesario para leer el recuento de dígitos correcto.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Código</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\123</code></td>
<td>Incrusta el byte con valor octal <code>123</code>, 3 dígitos exactamente.</td>
</tr>
<tr class="even">
<td><code>\x4D</code></td>
<td>Incrusta el byte con valor hexadecimal <code>4D</code>, 2 dígitos.</td>
</tr>
<tr class="odd">
<td><code>\u2620</code></td>
<td>Incrusta el carácter Unicode en el punto de código con valor hexadecimal <code>2620</code>, 4 dígitos.</td>
</tr>
<tr class="even">
<td><code>\U0001243F</code></td>
<td>Incrusta el carácter Unicode en el punto de código con valor hexadecimal <code>1243F</code>, 8 dígitos.</td>
</tr>
</tbody>
</table>
<p>He aquí un ejemplo de la notación octal, menos utilizada, para representar la letra “B” entre “A” y “C”. Normalmente esto se usaría para algún tipo de carácter especial no imprimible, pero tenemos otras formas de hacerlo, más abajo, y esto es sólo una demostración octal:</p>
<p></p>
<div class="sourceCode" id="cb486"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb486-1"><a href="#cb486-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;A</span><span class="er">\1</span><span class="st">02C</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// 102 es `B` en ASCII/UTF-8</span></span></code></pre></div>
<p>Tenga en cuenta que no hay cero a la izquierda en el número octal cuando se incluye de esta manera. Pero tiene que tener tres caracteres, así que rellénalo con ceros a la izquierda si es necesario.</p>
<p></p>
<p></p>
<p>Pero mucho más común es utilizar constantes hexadecimales en estos días. Aquí tienes una demostración que no deberías usar, pero que muestra cómo incrustar los bytes UTF-8 0xE2, 0x80 y 0xA2 en una cadena, lo que corresponde al carácter Unicode “bullet” (-).</p>
<div class="sourceCode" id="cb487"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb487-1"><a href="#cb487-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\xE2\x80\xA2</span><span class="st"> Bullet 1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb487-2"><a href="#cb487-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\xE2\x80\xA2</span><span class="st"> Bullet 2</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb487-3"><a href="#cb487-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\xE2\x80\xA2</span><span class="st"> Bullet 3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Produce la siguiente salida si estás en una consola UTF-8 (o probablemente basura si no lo estás):</p>
<div class="sourceCode" id="cb488"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb488-1"><a href="#cb488-1" aria-hidden="true" tabindex="-1"></a>• Bullet 1</span>
<span id="cb488-2"><a href="#cb488-2" aria-hidden="true" tabindex="-1"></a>• Bullet 2</span>
<span id="cb488-3"><a href="#cb488-3" aria-hidden="true" tabindex="-1"></a>• Bullet 3</span></code></pre></div>
<p></p>
<p> </p>
<p>Pero esa es una forma deficiente de hacer Unicode. Puedes usar los escapes <code>\u</code> (16 bits) o <code>\U</code> (32 bits) para referirte a Unicode por el número de punto de código. La viñeta es <code>2022</code> (hexadecimal) en Unicode, así que puedes hacer esto y obtener resultados más portables:</p>
<div class="sourceCode" id="cb489"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb489-1"><a href="#cb489-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\u2022</span><span class="st"> Bullet 1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb489-2"><a href="#cb489-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\u2022</span><span class="st"> Bullet 2</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb489-3"><a href="#cb489-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\u2022</span><span class="st"> Bullet 3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Asegúrese de rellenar “u” con suficientes ceros a la izquierda para llegar a cuatro caracteres, y “U” con suficientes ceros a la izquierda para llegar a ocho.</p>
<p></p>
<p>Por ejemplo, esa viñeta podría hacerse con “U” y cuatro ceros a la izquierda:</p>
<div class="sourceCode" id="cb490"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb490-1"><a href="#cb490-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\U00002022</span><span class="st"> Bullet 1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p></p>
<p>Pero, ¿quién tiene tiempo para ser tan verborreico?</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="22" id="tipos-enumerados-enum"><span class="header-section-number">22</span> Tipos Enumerados: <code>enum</code></h1>
<p></p>
<p>C nos ofrece otra forma de tener valores enteros constantes por nombre: <code>enum</code>.</p>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb491"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb491-1"><a href="#cb491-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb491-2"><a href="#cb491-2" aria-hidden="true" tabindex="-1"></a>  ONE<span class="op">=</span><span class="dv">1</span><span class="op">,</span></span>
<span id="cb491-3"><a href="#cb491-3" aria-hidden="true" tabindex="-1"></a>  TWO<span class="op">=</span><span class="dv">2</span></span>
<span id="cb491-4"><a href="#cb491-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb491-5"><a href="#cb491-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb491-6"><a href="#cb491-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> ONE<span class="op">,</span> TWO<span class="op">);</span>  <span class="co">// 1 2</span></span></code></pre></div>
<p>En algunos aspectos, puede ser mejor –o diferente– que usar un <code>#define</code>. Diferencias clave:</p>
<ul>
<li>Los <code>enum</code>s sólo pueden ser tipos enteros.</li>
<li><code>#define</code> puede definir cualquier cosa.</li>
<li>Los <code>enum</code>s se muestran a menudo por su nombre de identificador simbólico en un depurador.</li>
<li>Los números definidos con <code>#define</code> se muestran como números brutos que son más difíciles de conocer mientras se depura.</li>
</ul>
<p>Ya que son tipos enteros, pueden ser usados en cualquier lugar donde se puedan usar enteros, incluyendo en dimensiones de arreglos y sentencias <code>case</code>.</p>
<p>Vamos a profundizar en esto.</p>
<h2 data-number="22.1" id="comportamiento-de-enum"><span class="header-section-number">22.1</span> Comportamiento de <code>enum</code></h2>
<h3 data-number="22.1.1" id="numeración"><span class="header-section-number">22.1.1</span> Numeración</h3>
<p></p>
<p>Los <code>enum</code>s se numeran automáticamente a menos que los anules.</p>
<p>Empiezan en <code>0</code>, y se autoincrementan desde ahí, por defecto:</p>
<div class="sourceCode" id="cb492"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb492-1"><a href="#cb492-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb492-2"><a href="#cb492-2" aria-hidden="true" tabindex="-1"></a>    SHEEP<span class="op">,</span>  <span class="co">// El Valor es 0</span></span>
<span id="cb492-3"><a href="#cb492-3" aria-hidden="true" tabindex="-1"></a>    WHEAT<span class="op">,</span>  <span class="co">// El Valor es 1</span></span>
<span id="cb492-4"><a href="#cb492-4" aria-hidden="true" tabindex="-1"></a>    WOOD<span class="op">,</span>   <span class="co">// El Valor es 2</span></span>
<span id="cb492-5"><a href="#cb492-5" aria-hidden="true" tabindex="-1"></a>    BRICK<span class="op">,</span>  <span class="co">// El Valor es 3</span></span>
<span id="cb492-6"><a href="#cb492-6" aria-hidden="true" tabindex="-1"></a>    ORE     <span class="co">// El Valor es 4</span></span>
<span id="cb492-7"><a href="#cb492-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb492-8"><a href="#cb492-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb492-9"><a href="#cb492-9" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> SHEEP<span class="op">,</span> BRICK<span class="op">);</span>  <span class="co">// 0 3</span></span></code></pre></div>
<p>Puede forzar determinados valores enteros, como vimos anteriormente:</p>
<div class="sourceCode" id="cb493"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb493-1"><a href="#cb493-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb493-2"><a href="#cb493-2" aria-hidden="true" tabindex="-1"></a>  X<span class="op">=</span><span class="dv">2</span><span class="op">,</span></span>
<span id="cb493-3"><a href="#cb493-3" aria-hidden="true" tabindex="-1"></a>  Y<span class="op">=</span><span class="dv">18</span><span class="op">,</span></span>
<span id="cb493-4"><a href="#cb493-4" aria-hidden="true" tabindex="-1"></a>  Z<span class="op">=-</span><span class="dv">2</span></span>
<span id="cb493-5"><a href="#cb493-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Los duplicados no son un problema:</p>
<div class="sourceCode" id="cb494"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb494-1"><a href="#cb494-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb494-2"><a href="#cb494-2" aria-hidden="true" tabindex="-1"></a>  X<span class="op">=</span><span class="dv">2</span><span class="op">,</span></span>
<span id="cb494-3"><a href="#cb494-3" aria-hidden="true" tabindex="-1"></a>  Y<span class="op">=</span><span class="dv">2</span><span class="op">,</span></span>
<span id="cb494-4"><a href="#cb494-4" aria-hidden="true" tabindex="-1"></a>  Z<span class="op">=</span><span class="dv">2</span></span>
<span id="cb494-5"><a href="#cb494-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>si se omiten los valores, la numeración continúa contando en sentido positivo a partir del último valor especificado. Por ejemplo:</p>
<div class="sourceCode" id="cb495"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb495-1"><a href="#cb495-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb495-2"><a href="#cb495-2" aria-hidden="true" tabindex="-1"></a>  A<span class="op">,</span>    <span class="co">// 0, valor inicial por defecto</span></span>
<span id="cb495-3"><a href="#cb495-3" aria-hidden="true" tabindex="-1"></a>  B<span class="op">,</span>    <span class="co">// 1</span></span>
<span id="cb495-4"><a href="#cb495-4" aria-hidden="true" tabindex="-1"></a>  C<span class="op">=</span><span class="dv">4</span><span class="op">,</span>  <span class="co">// 4, ajustar manualmente</span></span>
<span id="cb495-5"><a href="#cb495-5" aria-hidden="true" tabindex="-1"></a>  D<span class="op">,</span>    <span class="co">// 5</span></span>
<span id="cb495-6"><a href="#cb495-6" aria-hidden="true" tabindex="-1"></a>  E<span class="op">,</span>    <span class="co">// 6</span></span>
<span id="cb495-7"><a href="#cb495-7" aria-hidden="true" tabindex="-1"></a>  F<span class="op">=</span><span class="dv">3</span>   <span class="co">// 3, ajustar manualmente</span></span>
<span id="cb495-8"><a href="#cb495-8" aria-hidden="true" tabindex="-1"></a>  G<span class="op">,</span>    <span class="co">// 4</span></span>
<span id="cb495-9"><a href="#cb495-9" aria-hidden="true" tabindex="-1"></a>  H     <span class="co">// 5</span></span>
<span id="cb495-10"><a href="#cb495-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h3 data-number="22.1.2" id="comas-finales"><span class="header-section-number">22.1.2</span> Comas finales</h3>
<p>Esto está perfectamente bien, si ese es tu estilo:</p>
<div class="sourceCode" id="cb496"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb496-1"><a href="#cb496-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb496-2"><a href="#cb496-2" aria-hidden="true" tabindex="-1"></a>  X<span class="op">=</span><span class="dv">2</span><span class="op">,</span></span>
<span id="cb496-3"><a href="#cb496-3" aria-hidden="true" tabindex="-1"></a>  Y<span class="op">=</span><span class="dv">18</span><span class="op">,</span></span>
<span id="cb496-4"><a href="#cb496-4" aria-hidden="true" tabindex="-1"></a>  Z<span class="op">=-</span><span class="dv">2</span><span class="op">,</span>   <span class="co">// &lt;-- Coma final</span></span>
<span id="cb496-5"><a href="#cb496-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Se ha hecho más popular en los idiomas de las últimas décadas, así que puede que te alegre verlo.</p>
<h3 data-number="22.1.3" id="alcance-1"><span class="header-section-number">22.1.3</span> Alcance</h3>
<p></p>
<p><code>enum</code>s scope como era de esperar. Si está en el ámbito del fichero, todo el fichero puede verlo. Si está en un bloque, es local a ese bloque.</p>
<p>Es muy común que los <code>enum</code>s se definan en ficheros de cabecera para que puedan ser <code>#include</code> en el ámbito del fichero.</p>
<p></p>
<h3 data-number="22.1.4" id="estilo"><span class="header-section-number">22.1.4</span> Estilo</h3>
<p>Como habrás notado, es común declarar los símbolos <code>enum</code> en mayúsculas (con guiones bajos).</p>
<p>Esto no es un requisito, pero es un modismo muy, muy común.</p>
<h2 data-number="22.2" id="su-enum-es-un-tipo"><span class="header-section-number">22.2</span> Su <code>enum</code> es un Tipo</h2>
<p>Esto es algo importante que hay que saber sobre los <code>enum</code>: son un tipo, de forma análoga a como una <code>struct</code> es un tipo.</p>
<p>Puedes darles un nombre de etiqueta para poder referirte al tipo más tarde y declarar variables de ese tipo.</p>
<p>Ahora bien, dado que los <code>enum</code>s son tipos enteros, ¿por qué no usar simplemente <code>int</code>?</p>
<p>En C, la mejor razón para esto es la claridad del código–es una forma agradable y tipada de describir tu pensamiento en el código. C (a diferencia de C++) no obliga a que ningún valor esté dentro del rango de un <code>enum</code> en particular.</p>
<p>Hagamos un ejemplo donde declaramos una variable <code>r</code> de tipo <code>enum resource</code> que puede contener esos valores:</p>
<div class="sourceCode" id="cb497"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb497-1"><a href="#cb497-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Nombrado enum, el tipo es &quot;enum resource&quot;</span></span>
<span id="cb497-2"><a href="#cb497-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb497-3"><a href="#cb497-3" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> resource <span class="op">{</span></span>
<span id="cb497-4"><a href="#cb497-4" aria-hidden="true" tabindex="-1"></a>    SHEEP<span class="op">,</span></span>
<span id="cb497-5"><a href="#cb497-5" aria-hidden="true" tabindex="-1"></a>    WHEAT<span class="op">,</span></span>
<span id="cb497-6"><a href="#cb497-6" aria-hidden="true" tabindex="-1"></a>    WOOD<span class="op">,</span></span>
<span id="cb497-7"><a href="#cb497-7" aria-hidden="true" tabindex="-1"></a>    BRICK<span class="op">,</span></span>
<span id="cb497-8"><a href="#cb497-8" aria-hidden="true" tabindex="-1"></a>    ORE</span>
<span id="cb497-9"><a href="#cb497-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb497-10"><a href="#cb497-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb497-11"><a href="#cb497-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Declarar una variable &quot;r&quot; de tipo &quot;enum resource&quot;</span></span>
<span id="cb497-12"><a href="#cb497-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb497-13"><a href="#cb497-13" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> resource r <span class="op">=</span> BRICK<span class="op">;</span></span>
<span id="cb497-14"><a href="#cb497-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb497-15"><a href="#cb497-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>r <span class="op">==</span> BRICK<span class="op">)</span> <span class="op">{</span></span>
<span id="cb497-16"><a href="#cb497-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;ll trade you a brick for two sheep.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb497-17"><a href="#cb497-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>También puede <code>typedef</code> estos, por supuesto, aunque yo personalmente no me gusta hacerlo.</p>
<div class="sourceCode" id="cb498"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb498-1"><a href="#cb498-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb498-2"><a href="#cb498-2" aria-hidden="true" tabindex="-1"></a>    SHEEP<span class="op">,</span></span>
<span id="cb498-3"><a href="#cb498-3" aria-hidden="true" tabindex="-1"></a>    WHEAT<span class="op">,</span></span>
<span id="cb498-4"><a href="#cb498-4" aria-hidden="true" tabindex="-1"></a>    WOOD<span class="op">,</span></span>
<span id="cb498-5"><a href="#cb498-5" aria-hidden="true" tabindex="-1"></a>    BRICK<span class="op">,</span></span>
<span id="cb498-6"><a href="#cb498-6" aria-hidden="true" tabindex="-1"></a>    ORE</span>
<span id="cb498-7"><a href="#cb498-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> RESOURCE<span class="op">;</span></span>
<span id="cb498-8"><a href="#cb498-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb498-9"><a href="#cb498-9" aria-hidden="true" tabindex="-1"></a>RESOURCE r <span class="op">=</span> BRICK<span class="op">;</span></span></code></pre></div>
<p>Otro atajo que es legal pero raro es declarar variables cuando declaras el <code>enum</code>:</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb499-1"><a href="#cb499-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declara un enum y algunas variables inicializadas de ese tipo:</span></span>
<span id="cb499-2"><a href="#cb499-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb499-3"><a href="#cb499-3" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb499-4"><a href="#cb499-4" aria-hidden="true" tabindex="-1"></a>    SHEEP<span class="op">,</span></span>
<span id="cb499-5"><a href="#cb499-5" aria-hidden="true" tabindex="-1"></a>    WHEAT<span class="op">,</span></span>
<span id="cb499-6"><a href="#cb499-6" aria-hidden="true" tabindex="-1"></a>    WOOD<span class="op">,</span></span>
<span id="cb499-7"><a href="#cb499-7" aria-hidden="true" tabindex="-1"></a>    BRICK<span class="op">,</span></span>
<span id="cb499-8"><a href="#cb499-8" aria-hidden="true" tabindex="-1"></a>    ORE</span>
<span id="cb499-9"><a href="#cb499-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> r <span class="op">=</span> BRICK<span class="op">,</span> s <span class="op">=</span> WOOD<span class="op">;</span></span></code></pre></div>
<p>También puedes dar un nombre al <code>enum</code> para poder utilizarlo más tarde, que es probablemente lo que quieres hacer en la mayoría de los casos:</p>
<div class="sourceCode" id="cb500"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb500-1"><a href="#cb500-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declara un enum y algunas variables inicializadas de ese tipo:</span></span>
<span id="cb500-2"><a href="#cb500-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb500-3"><a href="#cb500-3" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> resource <span class="op">{</span>   <span class="co">// &lt;-- es ahora &quot;enum resource&quot;</span></span>
<span id="cb500-4"><a href="#cb500-4" aria-hidden="true" tabindex="-1"></a>    SHEEP<span class="op">,</span></span>
<span id="cb500-5"><a href="#cb500-5" aria-hidden="true" tabindex="-1"></a>    WHEAT<span class="op">,</span></span>
<span id="cb500-6"><a href="#cb500-6" aria-hidden="true" tabindex="-1"></a>    WOOD<span class="op">,</span></span>
<span id="cb500-7"><a href="#cb500-7" aria-hidden="true" tabindex="-1"></a>    BRICK<span class="op">,</span></span>
<span id="cb500-8"><a href="#cb500-8" aria-hidden="true" tabindex="-1"></a>    ORE</span>
<span id="cb500-9"><a href="#cb500-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> r <span class="op">=</span> BRICK<span class="op">,</span> s <span class="op">=</span> WOOD<span class="op">;</span></span></code></pre></div>
<p>En resumen, los <code>enum</code>s son una gran manera de escribir código limpio, tipado, de alcance y agradable.</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="23" id="punteros-iii-punteros-a-punteros-y-más"><span class="header-section-number">23</span> Punteros III: Punteros a punteros y más</h1>
<p>Aquí es donde cubrimos algunos usos intermedios y avanzados de los punteros. Si no conoces bien los punteros, repasa los capítulos anteriores sobre <a href="#pointers">punteros</a> y <a href="#pointers2">aritmética de punteros</a> antes de empezar con esto.</p>
<h2 data-number="23.1" id="punteros-a-punteros"><span class="header-section-number">23.1</span> Punteros a punteros</h2>
<p></p>
<p>Si puedes tener un puntero a una variable, y una variable puede ser un puntero, ¿puedes tener un puntero a una variable que a su vez sea un puntero?</p>
<p>Sí. Esto es un puntero a un puntero, y se mantiene en una variable de tipo puntero-puntero.</p>
<p>Antes de entrar en materia, quiero que te hagas una idea de cómo funcionan los punteros a punteros.</p>
<p>Recuerda que un puntero es sólo un número. Es un número que representa un índice en la memoria del ordenador, que normalmente contiene un valor que nos interesa.</p>
<p>Ese puntero, que es un número, tiene que ser almacenado en algún lugar. Y ese lugar es la memoria, como todo lo demás<a href="#fn139" class="footnote-ref" id="fnref139" role="doc-noteref"><sup>139</sup></a>.</p>
<p>Pero como está almacenado en memoria, debe tener un índice en el que está almacenado, ¿no? El puntero debe tener un índice en la memoria donde se almacena. Y ese índice es un número. Es la dirección del puntero. Es un puntero al puntero.</p>
<p>Empecemos con un puntero regular a un <code>int</code>, de los capítulos anteriores:</p>
<div class="sourceCode" id="cb501"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb501-1"><a href="#cb501-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb501-2"><a href="#cb501-2"></a></span>
<span id="cb501-3"><a href="#cb501-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb501-4"><a href="#cb501-4"></a><span class="op">{</span></span>
<span id="cb501-5"><a href="#cb501-5"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span> <span class="co">// Tipo: int</span></span>
<span id="cb501-6"><a href="#cb501-6"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span> <span class="co">// Tipo: puntero a un int</span></span>
<span id="cb501-7"><a href="#cb501-7"></a></span>
<span id="cb501-8"><a href="#cb501-8"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// 3490</span></span>
<span id="cb501-9"><a href="#cb501-9"></a><span class="op">}</span></span></code></pre></div>
<p>Bastante sencillo, ¿verdad? Tenemos dos tipos representados: <code>int</code> e <code>int*</code>, y configuramos <code>p</code> para que apunte a <code>x</code>. Entonces podemos desreferenciar <code>p</code> en la línea 8 e imprimir el valor <code>3490</code>.</p>
<p>Pero, como hemos dicho, podemos tener un puntero a cualquier variable… ¿eso significa que podemos tener un puntero a <code>p</code>?</p>
<p>En otras palabras, ¿de qué tipo es esta expresión?</p>
<div class="sourceCode" id="cb502"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb502-1"><a href="#cb502-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span> <span class="co">// Tipo: int</span></span>
<span id="cb502-2"><a href="#cb502-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span> <span class="co">// Tipo: puntero a un int</span></span>
<span id="cb502-3"><a href="#cb502-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb502-4"><a href="#cb502-4" aria-hidden="true" tabindex="-1"></a><span class="op">&amp;</span>p <span class="co">// &lt;-- ¿De qué tipo es la dirección de p? ¿Un puntero a p?</span></span></code></pre></div>
<p>Si <code>x</code> es un <code>int</code>, entonces <code>&amp;x</code> es un puntero a un <code>int</code> que hemos almacenado en <code>p</code> que es de tipo <code>int*</code>. ¿Entiendes? (¡Repite este párrafo hasta que lo hagas!)</p>
<p>Y por tanto <code>&amp;p</code> es un puntero a un <code>int*</code>, alias “puntero a un puntero a un <code>int</code>”. También conocido como “<code>int</code>-pointer-pointer”.</p>
<p>¿Lo ha entendido? (¡Repite el párrafo anterior hasta que lo entiendas!)</p>
<p>Escribimos este tipo con dos asteriscos: <code>int **</code>. Veámoslo en acción.</p>
<div class="sourceCode" id="cb503"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb503-1"><a href="#cb503-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb503-2"><a href="#cb503-2"></a></span>
<span id="cb503-3"><a href="#cb503-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb503-4"><a href="#cb503-4"></a><span class="op">{</span></span>
<span id="cb503-5"><a href="#cb503-5"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span> <span class="co">// Tipo: int</span></span>
<span id="cb503-6"><a href="#cb503-6"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span> <span class="co">// Tipo: puntero a un int</span></span>
<span id="cb503-7"><a href="#cb503-7"></a>    <span class="dt">int</span> <span class="op">**</span>q <span class="op">=</span> <span class="op">&amp;</span>p<span class="op">;</span> <span class="co">// Tipo: puntero a puntero a int</span></span>
<span id="cb503-8"><a href="#cb503-8"></a></span>
<span id="cb503-9"><a href="#cb503-9"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">,</span> <span class="op">**</span>q<span class="op">);</span>  <span class="co">// 3490 3490</span></span>
<span id="cb503-10"><a href="#cb503-10"></a><span class="op">}</span></span></code></pre></div>
<p>Vamos a inventar algunas direcciones ficticias para los valores anteriores como ejemplos y ver lo que estas tres variables podrían parecer en la memoria. Los valores de dirección, a continuación son sólo inventados por mí para fines de ejemplo:</p>
<table>
<thead>
<tr class="header">
<th>Variable</th>
<th>Almacenada en la dirección</th>
<th>Valor almacenado allí</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>x</code></td>
<td><code>28350</code></td>
<td><code>3490</code>—el valor del código</td>
</tr>
<tr class="even">
<td><code>p</code></td>
<td><code>29122</code></td>
<td><code>28350</code>—¡la dirección de <code>x</code>!</td>
</tr>
<tr class="odd">
<td><code>q</code></td>
<td><code>30840</code></td>
<td><code>29122</code>—¡la dirección de <code>p</code>!</td>
</tr>
</tbody>
</table>
<p>De hecho, vamos a probarlo de verdad en mi ordenador<a href="#fn140" class="footnote-ref" id="fnref140" role="doc-noteref"><sup>140</sup></a> e imprimir los valores de los punteros con <code>%p</code> y volveré a hacer la misma tabla con las referencias reales (impresas en hexadecimal).</p>
<table>
<thead>
<tr class="header">
<th>Variable</th>
<th>Almacenada en la dirección</th>
<th>Valor almacenado allí</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>x</code></td>
<td><code>0x7ffd96a07b94</code></td>
<td><code>3490</code>—el valor del código</td>
</tr>
<tr class="even">
<td><code>p</code></td>
<td><code>0x7ffd96a07b98</code></td>
<td><code>0x7ffd96a07b94</code>—la dirección de <code>x</code>!</td>
</tr>
<tr class="odd">
<td><code>q</code></td>
<td><code>0x7ffd96a07ba0</code></td>
<td><code>0x7ffd96a07b98</code>—la dirección de <code>p</code>!</td>
</tr>
</tbody>
</table>
<p>Puedes ver que esas direcciones son las mismas excepto el último byte, así que céntrate en ellas.</p>
<p>En mi sistema, los <code>int</code>s son de 4 bytes, por lo que vemos que la dirección aumenta en 4 de <code>x</code> a <code>p</code><a href="#fn141" class="footnote-ref" id="fnref141" role="doc-noteref"><sup>141</sup></a> y luego aumenta en 8 de <code>p</code> a <code>q</code>. En mi sistema, todos los punteros son de 8 bytes.</p>
<p>¿Importa si es un <code>int*</code> o un <code>int**</code>? ¿Es uno más bytes que el otro? No. Recuerda que todos los punteros son direcciones, es decir, índices de memoria. Y en mi máquina puedes representar un índice con 8 bytes… no importa lo que esté almacenado en ese índice.</p>
<p>Fíjate en lo que hicimos en la línea 9 del ejemplo anterior: hicimos <em>doble dereferencia</em> <code>q</code> para volver a nuestro <code>3490</code>.</p>
<p>Esta es la parte importante sobre punteros y punteros a punteros:</p>
<ul>
<li>Puedes obtener un puntero a cualquier cosa con <code>&amp;</code> (¡incluyendo a un puntero!)</li>
<li>Puedes obtener la cosa a la que apunta un puntero con <code>*</code> (¡incluyendo un puntero!)</li>
</ul>
<p>Así que puedes pensar que <code>&amp;</code> se usa para hacer punteros, y que <code>*</code> es la inversa–va en la dirección opuesta a <code>&amp;</code>–para llegar a la cosa apuntada.</p>
<p>En términos de tipo, cada vez que <code>&amp;</code>, se añade otro nivel de puntero al tipo.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Si tiene</th>
<th style="text-align: center;">Entonces ejecuta</th>
<th style="text-align: left;">El tipo de resultado es</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int x</code></td>
<td style="text-align: center;"><code>&amp;x</code></td>
<td style="text-align: left;"><code>int *</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int *x</code></td>
<td style="text-align: center;"><code>&amp;x</code></td>
<td style="text-align: left;"><code>int **</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int **x</code></td>
<td style="text-align: center;"><code>&amp;x</code></td>
<td style="text-align: left;"><code>int ***</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int ***x</code></td>
<td style="text-align: center;"><code>&amp;x</code></td>
<td style="text-align: left;"><code>int ****</code></td>
</tr>
</tbody>
</table>
<p>Y cada vez que se utiliza la desreferencia (<code>*</code>), hace lo contrario:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Si tiene</th>
<th style="text-align: center;">Entonces ejecuta</th>
<th style="text-align: left;">El tipo de resultado es</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int ****x</code></td>
<td style="text-align: center;"><code>*x</code></td>
<td style="text-align: left;"><code>int ***</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int ***x</code></td>
<td style="text-align: center;"><code>*x</code></td>
<td style="text-align: left;"><code>int **</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int **x</code></td>
<td style="text-align: center;"><code>*x</code></td>
<td style="text-align: left;"><code>int *</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int *x</code></td>
<td style="text-align: center;"><code>*x</code></td>
<td style="text-align: left;"><code>int</code></td>
</tr>
</tbody>
</table>
<p>Tenga en cuenta que puede utilizar varias <code>*</code>s seguidas para realizar una desreferencia rápida, como vimos en el código de ejemplo con <code>**q</code>, más arriba. Cada uno elimina un nivel de indirección.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Si tiene</th>
<th style="text-align: center;">Entonces ejecuta</th>
<th style="text-align: left;">El tipo de resultado es</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int ****x</code></td>
<td style="text-align: center;"><code>***x</code></td>
<td style="text-align: left;"><code>int *</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int ***x</code></td>
<td style="text-align: center;"><code>**x</code></td>
<td style="text-align: left;"><code>int *</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int **x</code></td>
<td style="text-align: center;"><code>**x</code></td>
<td style="text-align: left;"><code>int</code></td>
</tr>
</tbody>
</table>
<p>En general, <code>&amp;*E == E</code><a href="#fn142" class="footnote-ref" id="fnref142" role="doc-noteref"><sup>142</sup></a>. La desreferencia “deshace” la dirección-de.</p>
<p>Pero <code>&amp;</code> no funciona de la misma manera—sólo puedes hacerlos de uno en uno, y tienes que almacenar el resultado en una variable intermedia:</p>
<div class="sourceCode" id="cb504"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb504-1"><a href="#cb504-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span> <span class="co">// Tipo: int</span></span>
<span id="cb504-2"><a href="#cb504-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span> <span class="co">// Tipo: int *, puntero a un int</span></span>
<span id="cb504-3"><a href="#cb504-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">**</span>q <span class="op">=</span> <span class="op">&amp;</span>p<span class="op">;</span> <span class="co">// Tipo: int **, puntero a puntero a int</span></span>
<span id="cb504-4"><a href="#cb504-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">***</span>r <span class="op">=</span> <span class="op">&amp;</span>q<span class="op">;</span> <span class="co">// Tipo: int ***, puntero a puntero a puntero a int</span></span>
<span id="cb504-5"><a href="#cb504-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">****</span>s <span class="op">=</span> <span class="op">&amp;</span>r<span class="op">;</span> <span class="co">// Tipo: int ****, se entiende la idea</span></span>
<span id="cb504-6"><a href="#cb504-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*****</span>t <span class="op">=</span> <span class="op">&amp;</span>s<span class="op">;</span> <span class="co">// Tipo: int *****</span></span></code></pre></div>
<p></p>
<h3 data-number="23.1.1" id="puntero-punteros-y-const."><span class="header-section-number">23.1.1</span> Puntero Punteros y <code>const</code>.</h3>
<p></p>
<p>Si recuerdas, declarando un puntero como este:</p>
<div class="sourceCode" id="cb505"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb505-1"><a href="#cb505-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p<span class="op">;</span></span></code></pre></div>
<p>significa que no puedes modificar <code>p</code>. Intentar <code>p++</code> daría un error de compilación.</p>
<p>¿Pero cómo funciona eso con <code>int **</code> o <code>int ***</code>? ¿Dónde va <code>const</code> y qué significa?</p>
<p>Empecemos por lo más sencillo. El símbolo <code>const</code> que aparece junto al nombre de la variable se refiere a esa variable. Así que si quieres un <code>int***</code> que no puedas cambiar, puedes hacer esto:</p>
<div class="sourceCode" id="cb506"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb506-1"><a href="#cb506-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">***</span><span class="dt">const</span> p<span class="op">;</span></span>
<span id="cb506-2"><a href="#cb506-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb506-3"><a href="#cb506-3" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>  <span class="co">// No autorizado</span></span></code></pre></div>
<p>Pero aquí es donde las cosas se ponen un poco raras.</p>
<p>¿Y si tuviéramos esta situación:</p>
<div class="sourceCode" id="cb507"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb507-1"><a href="#cb507-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb507-2"><a href="#cb507-2"></a><span class="op">{</span></span>
<span id="cb507-3"><a href="#cb507-3"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb507-4"><a href="#cb507-4"></a>    <span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb507-5"><a href="#cb507-5"></a>    <span class="dt">int</span> <span class="op">**</span>q <span class="op">=</span> <span class="op">&amp;</span>p<span class="op">;</span></span>
<span id="cb507-6"><a href="#cb507-6"></a><span class="op">}</span></span></code></pre></div>
<p>Cuando construyo eso, recibo una advertencia:</p>
<div class="sourceCode" id="cb508"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb508-1"><a href="#cb508-1" aria-hidden="true" tabindex="-1"></a>warning: initialization discards ‘const’ qualifier from pointer target type</span>
<span id="cb508-2"><a href="#cb508-2" aria-hidden="true" tabindex="-1"></a>    7 |     int **q = &amp;p;</span>
<span id="cb508-3"><a href="#cb508-3" aria-hidden="true" tabindex="-1"></a>      |               ^</span></code></pre></div>
<p>¿Qué es lo que ocurre? El compilador nos está diciendo aquí que teníamos una variable que era <code>const</code>, y estamos asignando su valor a otra variable que no es <code>const</code>. La “constancia” se descarta, que probablemente no es lo que queríamos hacer.</p>
<p>El tipo de <code>p</code> es <code>int *const p</code>, y <code>&amp;p</code> es del tipo <code>int *const *</code>. E intentamos asignarlo a <code>q</code>.</p>
<p>¡Pero <code>q</code> es <code>int **</code>! ¡Un tipo con diferente <code>const</code>ness en el primer <code>*</code>! Así que recibimos un aviso de que el <code>const</code> en <code>int *const *</code> de <code>p</code> está siendo ignorado y desechado.</p>
<p>Podemos arreglarlo asegurándonos de que el tipo de <code>q</code> es al menos tan <code>const</code> como <code>p</code>.</p>
<div class="sourceCode" id="cb509"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb509-1"><a href="#cb509-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb509-2"><a href="#cb509-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb509-3"><a href="#cb509-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> <span class="op">*</span>q <span class="op">=</span> <span class="op">&amp;</span>p<span class="op">;</span></span></code></pre></div>
<p>Y ahora estamos contentos.</p>
<p>Podríamos hacer <code>q</code> aún más <code>constante</code>. Tal como está, arriba, estamos diciendo, “<code>q</code> no es en sí <code>const</code>, pero la cosa a la que apunta es <code>const</code>”. Pero podríamos hacer que ambos sean <code>const</code>:</p>
<div class="sourceCode" id="cb510"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb510-1"><a href="#cb510-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb510-2"><a href="#cb510-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb510-3"><a href="#cb510-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> <span class="op">*</span><span class="dt">const</span> q <span class="op">=</span> <span class="op">&amp;</span>p<span class="op">;</span>  <span class="co">// ¡Más const!</span></span></code></pre></div>
<p>Y eso también funciona. Ahora no podemos modificar <code>q</code>, o el puntero <code>q</code> apunta a.</p>
<p></p>
<h2 data-number="23.2" id="multibyte-values"><span class="header-section-number">23.2</span> Valores multibyte</h2>
<p></p>
<p>Ya lo hemos insinuado en varias ocasiones, pero está claro que no todos los valores pueden almacenarse en un solo byte de memoria. Las cosas ocupan varios bytes de memoria (suponiendo que no sean <code>char</code>s). Puedes saber cuántos bytes usando <code>sizeof</code>. Y puedes saber qué dirección de memoria es el <em>primer</em> byte del objeto usando el operador estándar <code>&amp;</code>, que siempre devuelve la dirección del primer byte.</p>
<p>Y aquí tienes otro dato curioso. Si iteras sobre los bytes de cualquier objeto, obtienes su <em>representación de objeto</em>. Dos cosas con la misma representación de objeto en memoria son iguales.</p>
<p>Si quieres iterar sobre la representación del objeto, debes hacerlo con punteros a <code>unsigned char</code>.</p>
<p>Hagamos nuestra propia versión de <a href="https://beej.us%20guide/bgclr/html/split/stringref.html#man-memcpy"><code>memcpy()</code></a><a href="#fn143" class="footnote-ref" id="fnref143" role="doc-noteref"><sup>143</sup></a> que hace exactamente esto:</p>
<div class="sourceCode" id="cb511"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb511-1"><a href="#cb511-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>my_memcpy<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>src<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">)</span></span>
<span id="cb511-2"><a href="#cb511-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb511-3"><a href="#cb511-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Crear variables locales para src y dest, pero de tipo unsigned char</span></span>
<span id="cb511-4"><a href="#cb511-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-5"><a href="#cb511-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> src<span class="op">;</span></span>
<span id="cb511-6"><a href="#cb511-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>d <span class="op">=</span> dest<span class="op">;</span></span>
<span id="cb511-7"><a href="#cb511-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-8"><a href="#cb511-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>n<span class="op">--</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="co">// Para el número de bytes dado</span></span>
<span id="cb511-9"><a href="#cb511-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>d<span class="op">++</span> <span class="op">=</span> <span class="op">*</span>s<span class="op">++;</span> <span class="co">// Copia el byte origen al byte dest</span></span>
<span id="cb511-10"><a href="#cb511-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-11"><a href="#cb511-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// La mayoría de las funciones de copia devuelven un puntero</span></span>
<span id="cb511-12"><a href="#cb511-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// al dest como conveniencia al que llama</span></span>
<span id="cb511-13"><a href="#cb511-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-14"><a href="#cb511-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dest<span class="op">;</span></span>
<span id="cb511-15"><a href="#cb511-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>(También hay algunos buenos ejemplos de post-incremento y post-decremento para que los estudies).</p>
<p>Es importante tener en cuenta que la versión anterior es probablemente menos eficiente que la que viene con su sistema.</p>
<p>Pero puedes pasarle punteros a cualquier cosa, y copiará esos objetos. Puede ser <code>int*</code>, <code>struct animal*</code>, o cualquier cosa.</p>
<p>Hagamos otro ejemplo que imprima los bytes de representación del objeto de una <code>struct</code> para que podamos ver si hay algún relleno ahí y qué valores tiene<a href="#fn144" class="footnote-ref" id="fnref144" role="doc-noteref"><sup>144</sup></a>.</p>
<div class="sourceCode" id="cb512"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb512-1"><a href="#cb512-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb512-2"><a href="#cb512-2"></a></span>
<span id="cb512-3"><a href="#cb512-3"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb512-4"><a href="#cb512-4"></a>    <span class="dt">char</span> a<span class="op">;</span></span>
<span id="cb512-5"><a href="#cb512-5"></a>    <span class="dt">int</span> b<span class="op">;</span></span>
<span id="cb512-6"><a href="#cb512-6"></a><span class="op">};</span></span>
<span id="cb512-7"><a href="#cb512-7"></a></span>
<span id="cb512-8"><a href="#cb512-8"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb512-9"><a href="#cb512-9"></a><span class="op">{</span></span>
<span id="cb512-10"><a href="#cb512-10"></a>    <span class="kw">struct</span> foo x <span class="op">=</span> <span class="op">{</span><span class="bn">0x12</span><span class="op">,</span> <span class="bn">0x12345678</span><span class="op">};</span></span>
<span id="cb512-11"><a href="#cb512-11"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*)&amp;</span>x<span class="op">;</span></span>
<span id="cb512-12"><a href="#cb512-12"></a></span>
<span id="cb512-13"><a href="#cb512-13"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span> x<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb512-14"><a href="#cb512-14"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%02X\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb512-15"><a href="#cb512-15"></a>    <span class="op">}</span></span>
<span id="cb512-16"><a href="#cb512-16"></a><span class="op">}</span></span></code></pre></div>
<p>Lo que tenemos ahí es una <code>estructura foo</code> que está construida de tal manera que debería animar al compilador a inyectar bytes de relleno (aunque no tiene por qué). Y entonces obtenemos un <code>unsigned char *</code> en el primer byte de la variable <code>x</code> de la <code>struct foo</code>.</p>
<p>A partir de ahí, todo lo que necesitamos saber es el <code>sizeof x</code> y podemos hacer un bucle a través de esa cantidad de bytes, imprimiendo los valores (en hexadecimal para mayor facilidad).</p>
<p>Ejecutar esto da un montón de números como salida. He anotado a continuación para identificar donde se almacenan los valores:</p>
<div class="sourceCode" id="cb513"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb513-1"><a href="#cb513-1" aria-hidden="true" tabindex="-1"></a>12  | x.a == 0x12</span>
<span id="cb513-2"><a href="#cb513-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb513-3"><a href="#cb513-3" aria-hidden="true" tabindex="-1"></a>AB  |</span>
<span id="cb513-4"><a href="#cb513-4" aria-hidden="true" tabindex="-1"></a>BF  | padding bytes with &quot;random&quot; value</span>
<span id="cb513-5"><a href="#cb513-5" aria-hidden="true" tabindex="-1"></a>26  |</span>
<span id="cb513-6"><a href="#cb513-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb513-7"><a href="#cb513-7" aria-hidden="true" tabindex="-1"></a>78  |</span>
<span id="cb513-8"><a href="#cb513-8" aria-hidden="true" tabindex="-1"></a>56  | x.b == 0x12345678</span>
<span id="cb513-9"><a href="#cb513-9" aria-hidden="true" tabindex="-1"></a>34  |</span>
<span id="cb513-10"><a href="#cb513-10" aria-hidden="true" tabindex="-1"></a>12  |</span></code></pre></div>
<p>En todos los sistemas, <code>sizeof(char)</code> es 1, y vemos que el primer byte en la parte superior de la salida contiene el valor <code>0x12</code> que almacenamos allí.</p>
<p>Luego tenemos algunos bytes de relleno–para mí, estos variaron de una ejecución a otra.</p>
<p>Finalmente, en mi sistema, <code>sizeof(int)</code> es 4, y podemos ver esos 4 bytes al final. Observa que son los mismos bytes que hay en el valor hexadecimal <code>0x12345678</code>, pero extrañamente en orden inverso<a href="#fn145" class="footnote-ref" id="fnref145" role="doc-noteref"><sup>145</sup></a>.</p>
<p>Esto es un pequeño vistazo a los bytes de una entidad más compleja en memoria.</p>
<p></p>
<h2 data-number="23.3" id="el-puntero-null-y-el-cero"><span class="header-section-number">23.3</span> El puntero <code>NULL</code> y el cero</h2>
<p></p>
<p>Estas cosas pueden usarse indistintamente:</p>
<ul>
<li><code>NULL</code></li>
<li><code>0</code></li>
<li><code>'\0'</code></li>
<li><code>(void *)0</code></li>
</ul>
<p>Personalmente, siempre utilizo <code>NULL</code> cuando me refiero a <code>NULL</code>, pero puede que veas otras variantes de vez en cuando. Aunque <code>'\0'</code> (un byte con todos los bits a cero) también se compara igual, es <em>raro</em> compararlo con un puntero; deberías comparar <code>NULL</code> contra el puntero. (Por supuesto, muchas veces en el procesamiento de cadenas, estás comparando <em>la cosa a la que apunta el puntero</em> con <code>'\0</code>, y eso es correcto).</p>
<p>A <code>0</code> se le llama la <em>constante de puntero nulo</em>, y, cuando se compara o se asigna a otro puntero, se convierte en un puntero nulo del mismo tipo. </p>
<h2 data-number="23.4" id="punteros-como-enteros"><span class="header-section-number">23.4</span> Punteros como enteros</h2>
<p></p>
<p>Los punteros se pueden convertir en enteros y viceversa (ya que un puntero no es más que un índice de memoria), pero probablemente sólo sea necesario hacerlo si se realizan operaciones de hardware de bajo nivel. Los resultados de tales maquinaciones están definidos por la implementación, por lo que no son portables. Y pueden ocurrir <em>cosas raras</em>.</p>
<p>Sin embargo, C ofrece una garantía: puedes convertir un puntero a un tipo <code>uintptr_t</code> y podrás volver a convertirlo en puntero sin perder ningún dato.</p>
<p><code>uintptr_t</code> está definido en <code>&lt;stdint.h&gt;</code><a href="#fn146" class="footnote-ref" id="fnref146" role="doc-noteref"><sup>146</sup></a>.</p>
<p>Además, si te apetece que te firmen, puedes usar <code>intptr_t</code> con el mismo efecto.</p>
<p></p>
<h2 data-number="23.5" id="asignación-de-punteros-a-otros-punteros"><span class="header-section-number">23.5</span> Asignación de punteros a otros punteros</h2>
<p></p>
<p>Sólo hay una conversión de puntero segura:</p>
<ol type="1">
<li>Convertir a <code>intptr_t</code> o <code>uintptr_t</code>.</li>
<li>Convertir a y desde <code>void*</code>.</li>
</ol>
<p>¡DOS! Dos conversiones de punteros seguras.</p>
<ol start="3" type="1">
<li>Conversión a y desde <code>char*</code> (o <code>signed char*</code>/<code>unsigned char*</code>).</li>
</ol>
<p>¡TRES! ¡Tres conversiones seguras!</p>
<ol start="4" type="1">
<li>Convertir de y a un puntero a una <code>struct</code> y a un puntero a su primer miembro, y viceversa.</li>
</ol>
<p>¡CUATRO! ¡Cuatro conversiones seguras!</p>
<p>Si convierte a un puntero de otro tipo y luego accede al objeto al que apunta, el comportamiento es indefinido debido a algo llamado <em>aliasing</em> estricto.</p>
<p>El viejo <em>aliasing</em> se refiere a la capacidad de tener más de una forma de acceder al mismo objeto. Los puntos de acceso son alias entre sí.</p>
<p>El <em>aliasing estricto</em> dice que sólo se permite acceder a un objeto a través de punteros a <em>tipos compatibles</em> con ese objeto.</p>
<p>Por ejemplo, esto está definitivamente permitido:</p>
<div class="sourceCode" id="cb514"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb514-1"><a href="#cb514-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb514-2"><a href="#cb514-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">;</span></span></code></pre></div>
<p><code>p</code> es un puntero a un <code>int</code>, y apunta a un tipo compatible–a saber <code>int</code>–así que estamos bien.</p>
<p>Pero lo siguiente no es bueno porque <code>int</code> y <code>float</code> no son tipos compatibles:</p>
<div class="sourceCode" id="cb515"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb515-1"><a href="#cb515-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb515-2"><a href="#cb515-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">(</span><span class="dt">float</span> <span class="op">*)&amp;</span>a<span class="op">;</span></span></code></pre></div>
<p>Aquí hay un programa de demostración que hace algo de aliasing. Toma una variable <code>v</code> de tipo <code>int32_t</code> y la aliasea a un puntero a una <code>struct words</code>. Esa <code>struct</code> tiene dos <code>int16_t</code>s dentro. Estos tipos son incompatibles, por lo que estamos violando las reglas estrictas de aliasing. El compilador asumirá que estos dos punteros nunca apuntan al mismo objeto… pero nosotros estamos haciendo que lo hagan. Lo cual es malo por nuestra parte.</p>
<p>Veamos si podemos romper algo.</p>
<div class="sourceCode" id="cb516"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb516-1"><a href="#cb516-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb516-2"><a href="#cb516-2"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb516-3"><a href="#cb516-3"></a></span>
<span id="cb516-4"><a href="#cb516-4"></a><span class="kw">struct</span> words <span class="op">{</span></span>
<span id="cb516-5"><a href="#cb516-5"></a>    <span class="dt">int16_t</span> v<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb516-6"><a href="#cb516-6"></a><span class="op">};</span></span>
<span id="cb516-7"><a href="#cb516-7"></a></span>
<span id="cb516-8"><a href="#cb516-8"></a><span class="dt">void</span> fun<span class="op">(</span><span class="dt">int32_t</span> <span class="op">*</span>pv<span class="op">,</span> <span class="kw">struct</span> words <span class="op">*</span>pw<span class="op">)</span></span>
<span id="cb516-9"><a href="#cb516-9"></a><span class="op">{</span></span>
<span id="cb516-10"><a href="#cb516-10"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb516-11"><a href="#cb516-11"></a>        <span class="op">(*</span>pv<span class="op">)++;</span></span>
<span id="cb516-12"><a href="#cb516-12"></a></span>
<span id="cb516-13"><a href="#cb516-13"></a>        <span class="co">// Imprime el valor de 32 bits y los valores de 16 bits:</span></span>
<span id="cb516-14"><a href="#cb516-14"></a></span>
<span id="cb516-15"><a href="#cb516-15"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%x</span><span class="st">, </span><span class="sc">%x</span><span class="st">-</span><span class="sc">%x\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>pv<span class="op">,</span> pw<span class="op">-&gt;</span>v<span class="op">[</span><span class="dv">1</span><span class="op">],</span> pw<span class="op">-&gt;</span>v<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb516-16"><a href="#cb516-16"></a>    <span class="op">}</span></span>
<span id="cb516-17"><a href="#cb516-17"></a><span class="op">}</span></span>
<span id="cb516-18"><a href="#cb516-18"></a></span>
<span id="cb516-19"><a href="#cb516-19"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb516-20"><a href="#cb516-20"></a><span class="op">{</span></span>
<span id="cb516-21"><a href="#cb516-21"></a>    <span class="dt">int32_t</span> v <span class="op">=</span> <span class="bn">0x12345678</span><span class="op">;</span></span>
<span id="cb516-22"><a href="#cb516-22"></a></span>
<span id="cb516-23"><a href="#cb516-23"></a>    <span class="kw">struct</span> words <span class="op">*</span>pw <span class="op">=</span> <span class="op">(</span><span class="kw">struct</span> words <span class="op">*)&amp;</span>v<span class="op">;</span>  <span class="co">// Viola el aliasing estricto</span></span>
<span id="cb516-24"><a href="#cb516-24"></a></span>
<span id="cb516-25"><a href="#cb516-25"></a>    fun<span class="op">(&amp;</span>v<span class="op">,</span> pw<span class="op">);</span></span>
<span id="cb516-26"><a href="#cb516-26"></a><span class="op">}</span></span></code></pre></div>
<p>¿Ves cómo paso los dos punteros incompatibles a <code>fun()</code>? Uno de los tipos es <code>int32_t*</code> y el otro es <code>struct words*</code>.</p>
<p>Pero ambos apuntan al mismo objeto: el valor de 32 bits inicializado a <code>0x12345678</code>.</p>
<p>Así que si miramos los campos de <code>struct words</code>, deberíamos ver las dos mitades de 16 bits de ese número. ¿Verdad?</p>
<p>Y en el bucle <code>fun()</code>, incrementamos el puntero al <code>int32_t</code>. Y ya está. Pero como la <code>struct</code> apunta a esa misma memoria, también debería actualizarse al mismo valor.</p>
<p>Así que ejecutémoslo y obtendremos esto, con el valor de 32 bits a la izquierda y las dos porciones de 16 bits a la derecha. Debería coincidir<a href="#fn147" class="footnote-ref" id="fnref147" role="doc-noteref"><sup>147</sup></a>:</p>
<div class="sourceCode" id="cb517"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb517-1"><a href="#cb517-1" aria-hidden="true" tabindex="-1"></a>12345679, 1234-5679</span>
<span id="cb517-2"><a href="#cb517-2" aria-hidden="true" tabindex="-1"></a>1234567a, 1234-567a</span>
<span id="cb517-3"><a href="#cb517-3" aria-hidden="true" tabindex="-1"></a>1234567b, 1234-567b</span>
<span id="cb517-4"><a href="#cb517-4" aria-hidden="true" tabindex="-1"></a>1234567c, 1234-567c</span>
<span id="cb517-5"><a href="#cb517-5" aria-hidden="true" tabindex="-1"></a>1234567d, 1234-567d</span></code></pre></div>
<p>y lo hace… HASTA MAÑANA</p>
<p>Probémoslo compilando GCC con <code>-O3</code> y <code>-fstrict-aliasing</code>:</p>
<div class="sourceCode" id="cb518"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb518-1"><a href="#cb518-1" aria-hidden="true" tabindex="-1"></a>12345679, 1234-5678</span>
<span id="cb518-2"><a href="#cb518-2" aria-hidden="true" tabindex="-1"></a>1234567a, 1234-5679</span>
<span id="cb518-3"><a href="#cb518-3" aria-hidden="true" tabindex="-1"></a>1234567b, 1234-567a</span>
<span id="cb518-4"><a href="#cb518-4" aria-hidden="true" tabindex="-1"></a>1234567c, 1234-567b</span>
<span id="cb518-5"><a href="#cb518-5" aria-hidden="true" tabindex="-1"></a>1234567d, 1234-567c</span></code></pre></div>
<p>¡Están separados por uno! ¡Pero apuntan al mismo recuerdo! ¿Cómo es posible? Respuesta: es un comportamiento indefinido poner alias a la memoria de esa manera. Todo es posible, excepto que no en el buen sentido.</p>
<p>Si tu código viola las estrictas reglas de aliasing, que funcione o no depende de cómo alguien decida compilarlo. Y eso es un fastidio, ya que está fuera de tu control. A menos que seas una especie de deidad omnipotente.</p>
<p>Poco probable, lo siento.</p>
<p>GCC puede ser forzado a no usar las reglas de aliasing estricto con <code>-fno-strict-aliasing</code>. Compilar el programa de demostración, arriba, con <code>-O3</code> y esta bandera hace que la salida sea la esperada.</p>
<p>Por último, <em>type punning</em> es usar punteros de diferentes tipos para ver los mismos datos. Antes del aliasing estricto, este tipo de cosas era bastante común:</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb519-1"><a href="#cb519-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="bn">0x12345678</span><span class="op">;</span></span>
<span id="cb519-2"><a href="#cb519-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> b <span class="op">=</span> <span class="op">*((</span><span class="dt">short</span> <span class="op">*)&amp;</span>a<span class="op">);</span>   <span class="co">// Viola el aliasing estricto</span></span></code></pre></div>
<p>Si desea realizar puntuaciones (relativamente) seguras, consulte la sección sobre <a href="#union-type-punning">Uniones y puntuaciones</a>.</p>
<p></p>
<h2 data-number="23.6" id="ptr_differences"><span class="header-section-number">23.6</span> Diferencias entre punteros</h2>
<p></p>
<p>Como sabes de la sección sobre aritmética de punteros, puedes restar un puntero de otro <a href="#fn148" class="footnote-ref" id="fnref148" role="doc-noteref"><sup>148</sup></a> para obtener la diferencia entre ellos en número de elementos del array.</p>
<p>Ahora el <em>tipo de esa diferencia</em> es algo que depende de la implementación, por lo que podría variar de un sistema a otro.</p>
<p></p>
<p>Para ser más portable, puedes almacenar el resultado en una variable de tipo <code>ptrdiff_t</code> definida en <code>&lt;stddef.h&gt;</code>.</p>
<div class="sourceCode" id="cb520"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb520-1"><a href="#cb520-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cats<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb520-2"><a href="#cb520-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb520-3"><a href="#cb520-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>f <span class="op">=</span> cats <span class="op">+</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb520-4"><a href="#cb520-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>g <span class="op">=</span> cats <span class="op">+</span> <span class="dv">60</span><span class="op">;</span></span>
<span id="cb520-5"><a href="#cb520-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb520-6"><a href="#cb520-6" aria-hidden="true" tabindex="-1"></a><span class="dt">ptrdiff_t</span> d <span class="op">=</span> g <span class="op">-</span> f<span class="op">;</span>  <span class="co">// la diferencia es de 40</span></span></code></pre></div>
<p> Y puede imprimirlo anteponiendo al especificador de formato entero <code>t</code>:</p>
<div class="sourceCode" id="cb521"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb521-1"><a href="#cb521-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%td\n</span><span class="st">&quot;</span><span class="op">,</span> d<span class="op">);</span>  <span class="co">// Imprimir decimal: 40</span></span>
<span id="cb521-2"><a href="#cb521-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%tX\n</span><span class="st">&quot;</span><span class="op">,</span> d<span class="op">);</span>  <span class="co">// Imprimir hex:     28</span></span></code></pre></div>
<p> </p>
<h2 data-number="23.7" id="punteros-a-funciones"><span class="header-section-number">23.7</span> Punteros a funciones</h2>
<p></p>
<p>Las funciones son sólo colecciones de instrucciones de la máquina en la memoria, así que no hay ninguna razón por la que no podamos obtener un puntero a la primera instrucción de la función.</p>
<p>Y luego llamarla.</p>
<p>Esto puede ser útil para pasar, un puntero a una función a otra función como argumento. Entonces la segunda podría llamar a lo que se haya pasado.</p>
<p>La parte complicada de esto, sin embargo, es que C necesita saber el tipo de la variable que es el puntero a la función.</p>
<p>Y realmente le gustaría conocer todos los detalles.</p>
<p>Como “esto es un puntero a una función que toma dos argumentos <code>int</code> y devuelve <code>void</code>”.</p>
<p>¿Cómo se escribe todo eso para poder declarar una variable?</p>
<p>Bueno, resulta que se parece mucho a un prototipo de función, excepto que con algunos paréntesis extra:</p>
<div class="sourceCode" id="cb522"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb522-1"><a href="#cb522-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declara que p es un puntero a una función.</span></span>
<span id="cb522-2"><a href="#cb522-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Esta función devuelve un float, y toma dos ints como argumentos.</span></span>
<span id="cb522-3"><a href="#cb522-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb522-4"><a href="#cb522-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="op">(*</span>p<span class="op">)(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">);</span></span></code></pre></div>
<p>Fíjate también en que no tienes que dar nombres a los parámetros. Pero puedes hacerlo si quieres; simplemente se ignoran.</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb523-1"><a href="#cb523-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declara que p es un puntero a una función.</span></span>
<span id="cb523-2"><a href="#cb523-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Esta función devuelve un float, y toma dos ints como argumentos.</span></span>
<span id="cb523-3"><a href="#cb523-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb523-4"><a href="#cb523-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="op">(*</span>p<span class="op">)(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">);</span></span></code></pre></div>
<p>Ahora que sabemos cómo declarar una variable, ¿cómo sabemos qué asignarle? ¿Cómo obtenemos la dirección de una función?</p>
<p>Resulta que hay un atajo, igual que para obtener un puntero a un array: puedes referirte al nombre de la función sin paréntesis. (Puedes poner un <code>&amp;</code> delante si quieres, pero es innecesario y no es idiomático).</p>
<p>Una vez que tienes un puntero a una función, puedes llamarla simplemente añadiendo paréntesis y una lista de argumentos.</p>
<p>Hagamos un ejemplo simple donde efectivamente hago un alias para una función estableciendo un puntero a ella. Luego la llamaremos.</p>
<p>Este código imprime <code>3490</code>:</p>
<div class="sourceCode" id="cb524"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb524-1"><a href="#cb524-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb524-2"><a href="#cb524-2"></a></span>
<span id="cb524-3"><a href="#cb524-3"></a><span class="dt">void</span> print_int<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb524-4"><a href="#cb524-4"></a><span class="op">{</span></span>
<span id="cb524-5"><a href="#cb524-5"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb524-6"><a href="#cb524-6"></a><span class="op">}</span></span>
<span id="cb524-7"><a href="#cb524-7"></a></span>
<span id="cb524-8"><a href="#cb524-8"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb524-9"><a href="#cb524-9"></a><span class="op">{</span></span>
<span id="cb524-10"><a href="#cb524-10"></a>    <span class="co">// Asigna p a print_int:</span></span>
<span id="cb524-11"><a href="#cb524-11"></a></span>
<span id="cb524-12"><a href="#cb524-12"></a>    <span class="dt">void</span> <span class="op">(*</span>p<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> print_int<span class="op">;</span></span>
<span id="cb524-13"><a href="#cb524-13"></a></span>
<span id="cb524-14"><a href="#cb524-14"></a>    p<span class="op">(</span><span class="dv">3490</span><span class="op">);</span>          <span class="co">// Llamar a print_int a través del puntero</span></span>
<span id="cb524-15"><a href="#cb524-15"></a><span class="op">}</span></span></code></pre></div>
<p>Observa cómo el tipo de <code>p</code> representa el valor de retorno y los tipos de parámetros de <code>print_int</code>. Tiene que ser así, o C se quejará de incompatibilidad de tipos de punteros.</p>
<p>Otro ejemplo muestra cómo podemos pasar un puntero a una función como argumento de otra función.</p>
<p>Escribiremos una función que toma un par de argumentos enteros, más un puntero a una función que opera sobre esos dos argumentos. Luego imprime el resultado.</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb525-1"><a href="#cb525-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb525-2"><a href="#cb525-2"></a></span>
<span id="cb525-3"><a href="#cb525-3"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb525-4"><a href="#cb525-4"></a><span class="op">{</span></span>
<span id="cb525-5"><a href="#cb525-5"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb525-6"><a href="#cb525-6"></a><span class="op">}</span></span>
<span id="cb525-7"><a href="#cb525-7"></a></span>
<span id="cb525-8"><a href="#cb525-8"></a><span class="dt">int</span> mult<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb525-9"><a href="#cb525-9"></a><span class="op">{</span></span>
<span id="cb525-10"><a href="#cb525-10"></a>    <span class="cf">return</span> a <span class="op">*</span> b<span class="op">;</span></span>
<span id="cb525-11"><a href="#cb525-11"></a><span class="op">}</span></span>
<span id="cb525-12"><a href="#cb525-12"></a></span>
<span id="cb525-13"><a href="#cb525-13"></a><span class="dt">void</span> print_math<span class="op">(</span><span class="dt">int</span> <span class="op">(*</span>op<span class="op">)(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">),</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb525-14"><a href="#cb525-14"></a><span class="op">{</span></span>
<span id="cb525-15"><a href="#cb525-15"></a>    <span class="dt">int</span> result <span class="op">=</span> op<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb525-16"><a href="#cb525-16"></a></span>
<span id="cb525-17"><a href="#cb525-17"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> result<span class="op">);</span></span>
<span id="cb525-18"><a href="#cb525-18"></a><span class="op">}</span></span>
<span id="cb525-19"><a href="#cb525-19"></a></span>
<span id="cb525-20"><a href="#cb525-20"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb525-21"><a href="#cb525-21"></a><span class="op">{</span></span>
<span id="cb525-22"><a href="#cb525-22"></a>    print_math<span class="op">(</span>add<span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">);</span>   <span class="co">// 12</span></span>
<span id="cb525-23"><a href="#cb525-23"></a>    print_math<span class="op">(</span>mult<span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">);</span>  <span class="co">// 35</span></span>
<span id="cb525-24"><a href="#cb525-24"></a><span class="op">}</span></span></code></pre></div>
<p>Tómate un momento para asimilarlo. La idea aquí es que vamos a pasar un puntero a una función a <code>print_math()</code>, y va a llamar a esa función para hacer algo de matemáticas.</p>
<p>De esta forma podemos cambiar el comportamiento de <code>print_math()</code> pasándole otra función. Puedes ver que lo hacemos en las líneas 22-23 cuando pasamos punteros a las funciones <code>add</code> y <code>mult</code>, respectivamente.</p>
<p>Ahora, en la línea 13, creo que todos estamos de acuerdo en que la firma de la función <code>print_math()</code> es un espectáculo para la vista. Y, si puedes creerlo, ésta es en realidad bastante sencilla comparada con algunas cosas que puedes construir<a href="#fn149" class="footnote-ref" id="fnref149" role="doc-noteref"><sup>149</sup></a>.</p>
<p>Pero vamos a digerirlo. Resulta que sólo hay tres parámetros, pero son un poco difíciles de ver:</p>
<div class="sourceCode" id="cb526"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb526-1"><a href="#cb526-1" aria-hidden="true" tabindex="-1"></a><span class="co">//                      op             x      y</span></span>
<span id="cb526-2"><a href="#cb526-2" aria-hidden="true" tabindex="-1"></a><span class="co">//              |-----------------|  |---|  |---|</span></span>
<span id="cb526-3"><a href="#cb526-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_math<span class="op">(</span><span class="dt">int</span> <span class="op">(*</span>op<span class="op">)(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">),</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span></code></pre></div>
<p>El primero, <code>op</code>, es un puntero a una función que toma dos <code>int</code> como argumentos y devuelve un <code>int</code>. Esto coincide con las firmas de <code>add()</code> y <code>mult()</code>.</p>
<p>El segundo y el tercero, <code>x</code> e <code>y</code>, son parámetros <code>int</code> estándar.</p>
<p>Deja que tus ojos recorran la firma lenta y deliberadamente mientras identificas las partes que funcionan. Una cosa que siempre me llama la atención es la secuencia <code>(*op)(</code>, los paréntesis y el asterisco. Eso te delata que es un puntero a una función.</p>
<p>Por último, vuelve al capítulo <em>Pointers II</em> para ver un puntero a función <a href="#qsort-example">ejemplo usando la función incorporada <code>qsort()</code></a>.</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="24" id="operaciones-bit-a-bit"><span class="header-section-number">24</span> Operaciones bit a bit</h1>
<p></p>
<p>Estas operaciones numéricas permiten manipular bits individuales de las variables, lo que encaja con el hecho de que C sea un lenguaje de bajo nivel<a href="#fn150" class="footnote-ref" id="fnref150" role="doc-noteref"><sup>150</sup></a>.</p>
<p>Si no estás familiarizado con las operaciones bit a bit, <a href="https://en.wikipedia.org/wiki/Bitwise_operation">Wikipedia tiene un buen artículo sobre operaciones bit a bit</a><a href="#fn151" class="footnote-ref" id="fnref151" role="doc-noteref"><sup>151</sup></a>.</p>
<h2 data-number="24.1" id="and-or-xor-y-not-por-bits"><span class="header-section-number">24.1</span> AND, OR, XOR y NOT por bits</h2>
<p>Para cada uno de ellos, las <a href="#usual-arithmetic-conversions">conversiones aritméticas habituales</a> tienen lugar en los operandos (que en este caso deben ser de tipo entero), y luego se realiza la operación bitwise apropiada.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Operación</th>
<th style="text-align: center;">Operador</th>
<th>Ejemplo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AND</td>
<td style="text-align: center;"><code>&amp;</code></td>
<td><code>a = b &amp; c</code></td>
</tr>
<tr class="even">
<td>OR</td>
<td style="text-align: center;"><code>|</code></td>
<td><code>a = b | c</code></td>
</tr>
<tr class="odd">
<td>XOR</td>
<td style="text-align: center;"><code>^</code></td>
<td><code>a = b ^ c</code></td>
</tr>
<tr class="even">
<td>NOT</td>
<td style="text-align: center;"><code>~</code></td>
<td><code>a = ~c</code></td>
</tr>
</tbody>
</table>
<p>Observe que son similares a los operadores booleanos <code>&amp;&amp;</code> y <code>||</code>.</p>
<p>Éstos tienen variantes abreviadas de asignación similares a <code>+=</code> y <code>-=</code>:</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Operador</th>
<th>Ejemplo</th>
<th>Equivalente taquigráfico</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&amp;=</code></td>
<td><code>a &amp;= c</code></td>
<td><code>a = a &amp; c</code></td>
</tr>
<tr class="even">
<td><code>|=</code></td>
<td><code>a |= c</code></td>
<td><code>a = a | c</code></td>
</tr>
<tr class="odd">
<td><code>^=</code></td>
<td><code>a ^= c</code></td>
<td><code>a = a ^ c</code></td>
</tr>
</tbody>
</table>
<h2 data-number="24.2" id="desplazamiento-bitwise"><span class="header-section-number">24.2</span> Desplazamiento (Bitwise)</h2>
<p>Para ellos, las <a href="#integer-promotions">promociones de enteros</a> se realizan en cada operando (que debe ser de tipo entero) y luego se ejecuta un desplazamiento a nivel de bits. El tipo del resultado es el tipo del operando izquierdo promocionado.</p>
<p>Los nuevos bits se rellenan con ceros, con una posible excepción indicada en el comportamiento definido por la implementación, a continuación.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Operación</th>
<th style="text-align: center;">Operador</th>
<th>Ejemplo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Desplazamiento a la izquierda</td>
<td style="text-align: center;"><code>&lt;&lt;</code></td>
<td><code>a = b &lt;&lt; c</code></td>
</tr>
<tr class="even">
<td>Desplazamiento a la derecha</td>
<td style="text-align: center;"><code>&gt;&gt;</code></td>
<td><code>a = b &gt;&gt; c</code></td>
</tr>
</tbody>
</table>
<p>También existe la misma taquigrafía similar para el desplazamiento:</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Operador</th>
<th>Ejemplo</th>
<th>Equivalente a mano larga</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&gt;&gt;=</code></td>
<td><code>a &gt;&gt;= c</code></td>
<td><code>a = a &gt;&gt; c</code></td>
</tr>
<tr class="even">
<td><code>&lt;&lt;=</code></td>
<td><code>a &lt;&lt;= c</code></td>
<td><code>a = a &lt;&lt; c</code></td>
</tr>
</tbody>
</table>
<p>Tenga cuidado con el comportamiento indefinido: no se permiten desplazamientos negativos ni desplazamientos mayores que el tamaño del operando izquierdo promocionado.</p>
<p>También hay que tener cuidado con el comportamiento definido por la implementación: si se desplaza a la derecha un número negativo, los resultados están definidos por la implementación. (Es perfectamente correcto desplazar a la derecha un <code>int</code> con signo, sólo asegúrese de que es positivo).</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="25" id="funciones-variádicas"><span class="header-section-number">25</span> Funciones variádicas</h1>
<p></p>
<p>Variadic_ es una palabra elegante para referirse a las funciones que toman un número arbitrario de argumentos.</p>
<p>Por ejemplo, una función normal toma un número determinado de argumentos:</p>
<div class="sourceCode" id="cb527"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb527-1"><a href="#cb527-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb527-2"><a href="#cb527-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb527-3"><a href="#cb527-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb527-4"><a href="#cb527-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Sólo se puede llamar con exactamente dos argumentos que corresponden a los parámetros <code>x</code> e <code>y</code>.</p>
<div class="sourceCode" id="cb528"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb528-1"><a href="#cb528-1" aria-hidden="true" tabindex="-1"></a>add<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb528-2"><a href="#cb528-2" aria-hidden="true" tabindex="-1"></a>add<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">12</span><span class="op">);</span></span></code></pre></div>
<p>Pero si lo intentas con más, el compilador no te dejará:</p>
<div class="sourceCode" id="cb529"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb529-1"><a href="#cb529-1" aria-hidden="true" tabindex="-1"></a>add<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span>  <span class="co">// ERROR</span></span>
<span id="cb529-2"><a href="#cb529-2" aria-hidden="true" tabindex="-1"></a>add<span class="op">(</span><span class="dv">5</span><span class="op">);</span>        <span class="co">// ERROR</span></span></code></pre></div>
<p>Las funciones variádicas sortean esta limitación hasta cierto punto.</p>
<p>Ya hemos visto un ejemplo famoso en <code>printf()</code>. Puedes pasarle todo tipo de cosas.</p>
<div class="sourceCode" id="cb530"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb530-1"><a href="#cb530-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb530-2"><a href="#cb530-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;The number is </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb530-3"><a href="#cb530-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;The number is </span><span class="sc">%d</span><span class="st"> and pi is </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="fl">3.14159</span><span class="op">);</span></span></code></pre></div>
<p>Parece no importarle cuántos argumentos le des.</p>
<p>Bueno, eso no es del todo cierto. Cero argumentos le dará un error:</p>
<div class="sourceCode" id="cb531"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb531-1"><a href="#cb531-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">();</span>  <span class="co">// ERROR</span></span></code></pre></div>
<p>Esto nos lleva a una de las limitaciones de las funciones variádicas en C: deben tener al menos un argumento.</p>
<p>Pero aparte de eso, son bastante flexibles, incluso permiten que los argumentos tengan diferentes tipos como hace <code>printf()</code>.</p>
<p>¡Veamos cómo funcionan!</p>
<h2 data-number="25.1" id="elipses-en-firmas-de-funciones"><span class="header-section-number">25.1</span> Elipses en firmas de funciones</h2>
<p>¿Cómo funciona, sintácticamente?</p>
<p></p>
<p>Lo que haces es poner todos los argumentos que <em>deben</em> pasarse primero (y recuerda que tiene que haber al menos uno) y después de eso, pones <code>...</code> .Así:</p>
<div class="sourceCode" id="cb532"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb532-1"><a href="#cb532-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> func<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="op">...)</span>   <span class="co">// Literalmente 3 puntos aquí</span></span></code></pre></div>
<p>Aquí hay algo de código para demostrarlo:</p>
<div class="sourceCode" id="cb533"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb533-1"><a href="#cb533-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb533-2"><a href="#cb533-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb533-3"><a href="#cb533-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> func<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb533-4"><a href="#cb533-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb533-5"><a href="#cb533-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;a is </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// Imprime &quot;a es 2&quot;</span></span>
<span id="cb533-6"><a href="#cb533-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb533-7"><a href="#cb533-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb533-8"><a href="#cb533-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb533-9"><a href="#cb533-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb533-10"><a href="#cb533-10" aria-hidden="true" tabindex="-1"></a>    func<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">);</span></span>
<span id="cb533-11"><a href="#cb533-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Así que, genial, podemos obtener ese primer argumento que está en la variable <code>a</code>, pero ¿qué pasa con el resto de argumentos? ¿Cómo se llega a ellos?</p>
<p>Aquí empieza la diversión.</p>
<h2 data-number="25.2" id="obtener-los-argumentos-adicionales"><span class="header-section-number">25.2</span> Obtener los argumentos adicionales</h2>
<p>Tendrás que incluir <code>&lt;stdarg.h&gt;</code> para que todo esto funcione.</p>
<p></p>
<p>Lo primero es lo primero, vamos a utilizar una variable especial de tipo <code>va_list</code> (lista de argumentos de variables) para llevar la cuenta de a qué variable estamos accediendo en cada momento.</p>
<p> </p>
<p>La idea es que primero comencemos a procesar los argumentos con una llamada a <code>va_start()</code>, procesemos cada argumento a su vez con <code>va_arg()</code>, y luego, cuando hayamos terminado, lo cerremos con <code>va_end()</code>.</p>
<p>Cuando llame a <code>va_start()</code>, necesita pasar el <em>último parámetro con nombre</em> (el que está justo antes de <code>...</code>) para que sepa dónde empezar a buscar los argumentos adicionales.</p>
<p>Y cuando llame a <code>va_arg()</code> para obtener el siguiente argumento, tiene que decirle el tipo de argumento que debe obtener a continuación.</p>
<p>Aquí tienes una demo que suma un número arbitrario de enteros. El primer argumento es el número de enteros a sumar. Lo usaremos para calcular cuántas veces tenemos que llamar a <code>va_arg()</code>.</p>
<div class="sourceCode" id="cb534"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb534-1"><a href="#cb534-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb534-2"><a href="#cb534-2"></a><span class="pp">#include </span><span class="im">&lt;stdarg.h&gt;</span></span>
<span id="cb534-3"><a href="#cb534-3"></a></span>
<span id="cb534-4"><a href="#cb534-4"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> count<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb534-5"><a href="#cb534-5"></a><span class="op">{</span></span>
<span id="cb534-6"><a href="#cb534-6"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb534-7"><a href="#cb534-7"></a>    <span class="dt">va_list</span> va<span class="op">;</span></span>
<span id="cb534-8"><a href="#cb534-8"></a></span>
<span id="cb534-9"><a href="#cb534-9"></a>    va_start<span class="op">(</span>va<span class="op">,</span> count<span class="op">);</span>   <span class="co">// Empezar con argumentos después de &quot;count&quot;</span></span>
<span id="cb534-10"><a href="#cb534-10"></a></span>
<span id="cb534-11"><a href="#cb534-11"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> count<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb534-12"><a href="#cb534-12"></a>        <span class="dt">int</span> n <span class="op">=</span> va_arg<span class="op">(</span>va<span class="op">,</span> <span class="dt">int</span><span class="op">);</span>   <span class="co">// Obtener el siguiente int</span></span>
<span id="cb534-13"><a href="#cb534-13"></a></span>
<span id="cb534-14"><a href="#cb534-14"></a>        total <span class="op">+=</span> n<span class="op">;</span></span>
<span id="cb534-15"><a href="#cb534-15"></a>    <span class="op">}</span></span>
<span id="cb534-16"><a href="#cb534-16"></a></span>
<span id="cb534-17"><a href="#cb534-17"></a>    va_end<span class="op">(</span>va<span class="op">);</span>  <span class="co">// Todo hecho</span></span>
<span id="cb534-18"><a href="#cb534-18"></a></span>
<span id="cb534-19"><a href="#cb534-19"></a>    <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb534-20"><a href="#cb534-20"></a><span class="op">}</span></span>
<span id="cb534-21"><a href="#cb534-21"></a></span>
<span id="cb534-22"><a href="#cb534-22"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb534-23"><a href="#cb534-23"></a><span class="op">{</span></span>
<span id="cb534-24"><a href="#cb534-24"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> add<span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">4</span><span class="op">,</span> <span class="dv">17</span><span class="op">));</span>  <span class="co">// 6 + 2 - 4 + 17 = 21</span></span>
<span id="cb534-25"><a href="#cb534-25"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> add<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">44</span><span class="op">));</span>        <span class="co">// 22 + 44 = 66</span></span>
<span id="cb534-26"><a href="#cb534-26"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>(Tenga en cuenta que cuando se llama a <code>printf()</code>, utiliza el número de <code>%d</code>s (o lo que sea) en la cadena de formato para saber cuántos argumentos más hay).</p>
<p>Si la sintaxis de <code>va_arg()</code> te parece extraña (debido a ese nombre de tipo suelto flotando por ahí), no eres el único. Esto se implementa con macros de preprocesador para conseguir toda la magia apropiada.</p>
<h2 data-number="25.3" id="funcionalidad-de-va_list"><span class="header-section-number">25.3</span> Funcionalidad de <code>va_list</code></h2>
<p>¿Qué es esa variable <code>va_list</code> que estamos usando ahí arriba? Es una variable opaca <a href="#fn152" class="footnote-ref" id="fnref152" role="doc-noteref"><sup>152</sup></a> que contiene información sobre qué argumento vamos a obtener a continuación con <code>va_arg()</code>. ¿Ves cómo llamamos a <code>va_arg()</code> una y otra vez? La variable <code>va_list</code> es un marcador de posición que mantiene un registro del progreso hasta el momento.</p>
<p></p>
<p>Pero tenemos que inicializar esa variable con algún valor razonable. Ahí es donde <code>va_start()</code> entra en juego.</p>
<p>Cuando llamamos a <code>va_start(va, count)</code>, arriba, estábamos diciendo: “Inicializa la variable <code>va</code> para que apunte al argumento variable <em>inmediatamente después</em> de <code>count</code>”.</p>
<p></p>
<p>Y esa es <em>la razón</em> por la que necesitamos tener al menos una variable con nombre en nuestra lista de argumentos<a href="#fn153" class="footnote-ref" id="fnref153" role="doc-noteref"><sup>153</sup></a>.</p>
<p>Una vez que tengas ese puntero al parámetro inicial, puedes obtener fácilmente los valores de los argumentos posteriores llamando repetidamente a <code>va_arg()</code>. Cuando lo hagas, tienes que pasarle tu variable <code>va_list</code> (para que pueda seguirte la pista), así como el tipo de argumento que vas a copiar.</p>
<p>Depende de ti como programador averiguar qué tipo vas a pasar a <code>va_arg()</code>. En el ejemplo anterior, acabamos de hacer <code>int</code>s. Pero en el caso de <code>printf()</code>, utiliza el especificador de formato para determinar qué tipo sacar a continuación.</p>
<p>Y cuando hayas terminado, llama a <code>va_end()</code> para terminar. <strong>Debes</strong> (según la especificación) llamar a esto en una variable <code>va_list</code> en particular antes de decidir llamar a <code>va_start()</code> o <code>va_copy()</code> de nuevo. Sé que aún no hemos hablado de <code>va_copy()</code>.</p>
<ul>
<li><code>va_start()</code> para inicializar tu variable <code>va_list</code></li>
<li>Repetidamente <code>va_arg()</code> para obtener los valores</li>
<li><code>va_end()</code> para desinicializar la variable <code>va_list</code></li>
</ul>
<p> </p>
<p></p>
<p>También mencioné <code>va_copy()</code> ahí arriba; hace una copia de tu variable <code>va_list</code> exactamente en el mismo estado. Es decir, si no has empezado con <code>va_arg()</code> con la variable fuente, la nueva tampoco se iniciará. Si has consumido 5 variables con <code>va_arg()</code> hasta ahora, la copia también lo reflejará.</p>
<p>va_copy()` puede ser útil si necesita recorrer los argumentos pero también necesita recordar su posición actual.</p>
<p></p>
<h2 data-number="25.4" id="funciones-de-biblioteca-que-utilizan-va_lists"><span class="header-section-number">25.4</span> Funciones de biblioteca que utilizan <code>va_list</code>s</h2>
<p></p>
<p>Uno de los otros usos de estos es bastante bueno: escribir tu propia variante personalizada de <code>printf()</code>. Sería un fastidio tener que manejar todos esos especificadores de formato, ¿verdad? ¿Los millones de ellos?</p>
<p>Por suerte, hay variantes de <code>printf()</code> que aceptan una <code>va_list</code> como argumento. Puedes usarlas para crear tus propios <code>printf()</code> personalizados.</p>
<p></p>
<p>Estas funciones empiezan por la letra <code>v</code>, como <code>vprintf()</code>, <code>vfprintf()</code>, <code>vsprintf()</code> y <code>vsnprintf()</code>. Básicamente, todas las funciones <code>printf()</code> de toda la vida, pero con una <code>v</code> delante.</p>
<p>Hagamos una función <code>my_printf()</code> que funcione igual que <code>printf()</code> excepto que toma un argumento extra delante.</p>
<div class="sourceCode" id="cb535"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb535-1"><a href="#cb535-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb535-2"><a href="#cb535-2"></a><span class="pp">#include </span><span class="im">&lt;stdarg.h&gt;</span></span>
<span id="cb535-3"><a href="#cb535-3"></a></span>
<span id="cb535-4"><a href="#cb535-4"></a><span class="dt">int</span> my_printf<span class="op">(</span><span class="dt">int</span> serial<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>format<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb535-5"><a href="#cb535-5"></a><span class="op">{</span></span>
<span id="cb535-6"><a href="#cb535-6"></a>    <span class="dt">va_list</span> va<span class="op">;</span></span>
<span id="cb535-7"><a href="#cb535-7"></a></span>
<span id="cb535-8"><a href="#cb535-8"></a>    <span class="co">// Haz mi trabajo a medida</span></span>
<span id="cb535-9"><a href="#cb535-9"></a>    printf<span class="op">(</span><span class="st">&quot;The serial number is: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> serial<span class="op">);</span></span>
<span id="cb535-10"><a href="#cb535-10"></a></span>
<span id="cb535-11"><a href="#cb535-11"></a>    <span class="co">// Luego pasa el resto a vprintf()</span></span>
<span id="cb535-12"><a href="#cb535-12"></a>    va_start<span class="op">(</span>va<span class="op">,</span> format<span class="op">);</span></span>
<span id="cb535-13"><a href="#cb535-13"></a>    <span class="dt">int</span> rv <span class="op">=</span> vprintf<span class="op">(</span>format<span class="op">,</span> va<span class="op">);</span></span>
<span id="cb535-14"><a href="#cb535-14"></a>    va_end<span class="op">(</span>va<span class="op">);</span></span>
<span id="cb535-15"><a href="#cb535-15"></a></span>
<span id="cb535-16"><a href="#cb535-16"></a>    <span class="cf">return</span> rv<span class="op">;</span></span>
<span id="cb535-17"><a href="#cb535-17"></a><span class="op">}</span></span>
<span id="cb535-18"><a href="#cb535-18"></a></span>
<span id="cb535-19"><a href="#cb535-19"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb535-20"><a href="#cb535-20"></a><span class="op">{</span></span>
<span id="cb535-21"><a href="#cb535-21"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb535-22"><a href="#cb535-22"></a>    <span class="dt">float</span> y <span class="op">=</span> <span class="fl">3.2</span><span class="op">;</span></span>
<span id="cb535-23"><a href="#cb535-23"></a></span>
<span id="cb535-24"><a href="#cb535-24"></a>    my_printf<span class="op">(</span><span class="dv">3490</span><span class="op">,</span> <span class="st">&quot;x is </span><span class="sc">%d</span><span class="st">, y is </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb535-25"><a href="#cb535-25"></a><span class="op">}</span></span></code></pre></div>
<p>¿Ves lo que hemos hecho? En las líneas 12-14 iniciamos una nueva variable <code>va_list</code>, y luego la pasamos directamente a <code>vprintf()</code>. Y sabe lo que tiene que hacer con ella, porque tiene toda la inteligencia de <code>printf()</code> incorporada.</p>
<p></p>
<p>Sin embargo, aún tenemos que llamar a <code>va_end()</code> cuando hayamos terminado, ¡así que no lo olvides!</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="26" id="configuración-regional-e-internacionalización"><span class="header-section-number">26</span> Configuración regional e internacionalización</h1>
<p></p>
<p><em>La localización</em> es el proceso de preparar tu aplicación para que funcione bien en distintas localizaciones (o países).</p>
<p>Como sabrás, no todo el mundo utiliza el mismo carácter para los decimales o para los separadores de miles… o para la moneda.</p>
<p>Estas localizaciones tienen nombres, y puedes seleccionar una para usarla. Por ejemplo, una configuración regional de EE.UU. podría escribir un número como:</p>
<p>100,000.00</p>
<p>Mientras que en Brasil, lo mismo podría escribirse con las comas y los puntos decimales intercambiados:</p>
<p>100.000,00</p>
<p>Así es más fácil escribir el código para que se adapte fácilmente a otras nacionalidades.</p>
<p>Bueno, más o menos. Resulta que C sólo tiene una configuración regional incorporada, y es limitada. La especificación realmente deja mucha ambigüedad aquí; es difícil ser completamente portable.</p>
<p>Pero haremos lo que podamos.</p>
<h2 data-number="26.1" id="configuración-rápida-de-la-localización"><span class="header-section-number">26.1</span> Configuración rápida de la localización</h2>
<p>Para estas llamadas, incluya <code>&lt;locale.h&gt;</code>.</p>
<p>Hay básicamente una cosa que puedes hacer de forma portable aquí en términos de declarar una localización específica. Esto es probablemente lo que quieres hacer si vas a hacer algo de localización:</p>
<p></p>
<div class="sourceCode" id="cb536"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb536-1"><a href="#cb536-1" aria-hidden="true" tabindex="-1"></a>setlocale<span class="op">(</span>LC_ALL<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span>  <span class="co">// Utiliza la configuración regional</span></span>
<span id="cb536-2"><a href="#cb536-2" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// de este entorno para todo</span></span></code></pre></div>
<p>Usted querrá llamar a eso para que el programa se inicialice con su configuración regional actual.</p>
<p>Entrando en más detalles, hay una cosa más que puedes hacer y seguir siendo portable:</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb537-1"><a href="#cb537-1" aria-hidden="true" tabindex="-1"></a>setlocale<span class="op">(</span>LC_ALL<span class="op">,</span> <span class="st">&quot;C&quot;</span><span class="op">);</span>  <span class="co">// Utilizar la configuración regional C por defecto.</span></span></code></pre></div>
<p>pero se ejecuta por defecto cada vez que se inicia el programa, por lo que no es necesario que lo hagas tú mismo.</p>
<p>En la segunda cadena, puedes especificar cualquier configuración regional soportada por tu sistema. Esto depende completamente del sistema, así que variará. En mi sistema, puedo especificar esto:</p>
<div class="sourceCode" id="cb538"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb538-1"><a href="#cb538-1" aria-hidden="true" tabindex="-1"></a>setlocale<span class="op">(</span>LC_ALL<span class="op">,</span> <span class="st">&quot;en_US.UTF-8&quot;</span><span class="op">);</span>  <span class="co">// ¡No portátil!</span></span></code></pre></div>
<p>Y funcionará. Pero sólo es portable a sistemas que tengan exactamente el mismo nombre para la misma localización, y no puedes garantizarlo.</p>
<p>Al pasar una cadena vacía (<code>""</code>) como segundo argumento, le estás diciendo a C: “Oye, averigua cuál es la configuración regional actual en este sistema para que yo no tenga que decírtelo”.</p>
<p></p>
<h2 data-number="26.2" id="obtener-la-configuración-regional-monetaria"><span class="header-section-number">26.2</span> Obtener la configuración regional monetaria</h2>
<p></p>
<p>Porque mover papelitos verdes promete ser la clave de la felicidad<a href="#fn154" class="footnote-ref" id="fnref154" role="doc-noteref"><sup>154</sup></a>, hablemos de la localización monetaria. Cuando escribes código portable, tienes que saber qué escribir por dinero, ¿verdad? Ya sea “$”, “€”, “¥”, o “£”.</p>
<p></p>
<p>¿Cómo puedes escribir ese código sin volverte loco? Por suerte, una vez que llames a <code>setlocale(LC_ALL, "")</code>, puedes buscarlas con una llamada a <code>localeconv()</code>:</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb539-1"><a href="#cb539-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> lconv <span class="op">*</span>x <span class="op">=</span> localeconv<span class="op">();</span></span></code></pre></div>
<p>Esta función devuelve un puntero a una <code>struct lconv</code> estáticamente asignada que contiene toda la información que estás buscando.</p>
<p>Estos son los campos de <code>struct lconv</code> y sus significados.</p>
<p>Primero, algunas convenciones. Un <code>_p_</code> significa “positivo”, y <code>_n_</code> significa “negativo”, y <code>int_</code> significa “internacional”. Aunque muchos de ellos son del tipo <code>char</code> o <code>char*</code>, la mayoría (o las cadenas a las que apuntan) se tratan en realidad como enteros<a href="#fn155" class="footnote-ref" id="fnref155" role="doc-noteref"><sup>155</sup></a>.</p>
<p>Antes de continuar, debes saber que <code>CHAR_MAX</code> (de <code>&lt;limits.h&gt;</code>) es el valor máximo que puede contener un <code>char</code>. Y que muchos de los siguientes valores <code>char</code> lo usan para indicar que el valor no está disponible en la localización dada.</p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Campo</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char *mon_decimal_point</code></td>
<td>Carácter puntero decimal para dinero, por ejemplo <code>"."</code>.</td>
</tr>
<tr class="even">
<td><code>char *mon_thousands_sep</code></td>
<td>Carácter separador de miles para dinero, por ejemplo <code>","</code>.</td>
</tr>
<tr class="odd">
<td><code>char *mon_grouping</code></td>
<td>Descripción de la agrupación por dinero (véase más abajo).</td>
</tr>
<tr class="even">
<td><code>char *positive_sign</code></td>
<td>Signo positivo para el dinero, por ejemplo <code>"+"</code> o <code>""</code>.</td>
</tr>
<tr class="odd">
<td><code>char *negative_sign</code></td>
<td>Signo negativo para el dinero, por ejemplo <code>"-"</code>.</td>
</tr>
<tr class="even">
<td><code>char *currency_symbol</code></td>
<td>Símbolo de moneda, por ejemplo <code>"$"</code>.</td>
</tr>
<tr class="odd">
<td><code>char frac_digits</code></td>
<td>Al imprimir importes monetarios, cuántos dígitos imprimir después del punto decimal, por ejemplo <code>2</code>.</td>
</tr>
<tr class="even">
<td><code>char p_cs_precedes</code></td>
<td><code>1</code> si el <code>símbolo_moneda</code> viene antes del valor de una cantidad monetaria no negativa, <code>0</code> si viene después.</td>
</tr>
<tr class="odd">
<td><code>char n_cs_precedes</code></td>
<td><code>1</code> si el <code>símbolo_moneda</code> viene antes del valor para una cantidad monetaria negativa, <code>0</code> si viene después.</td>
</tr>
<tr class="even">
<td><code>char p_sep_by_space</code></td>
<td>Determina la separación del <code>símbolo de moneda</code> del valor para importes no negativos (véase más abajo).</td>
</tr>
<tr class="odd">
<td><code>char n_sep_by_space</code></td>
<td>Determina la separación del <code>símbolo de moneda</code> del valor para los importes negativos (véase más abajo).</td>
</tr>
<tr class="even">
<td><code>char p_sign_posn</code></td>
<td>Determina la posición de <code>positive_sign</code> para valores no negativos.</td>
</tr>
<tr class="odd">
<td><code>char p_sign_posn</code></td>
<td>Determina la posición de <code>positive_sign</code> para valores negativos.</td>
</tr>
<tr class="even">
<td><code>char *int_curr_symbol</code></td>
<td>Símbolo de moneda internacional, por ejemplo <code>"USD"</code>.</td>
</tr>
<tr class="odd">
<td><code>char int_frac_digits</code></td>
<td>Valor internacional para <code>frac_digits</code>.</td>
</tr>
<tr class="even">
<td><code>char int_p_cs_precedes</code></td>
<td>Valor internacional para <code>p_cs_precedes</code>.</td>
</tr>
<tr class="odd">
<td><code>char int_n_cs_precedes</code></td>
<td>Valor internacional para <code>n_cs_precedes</code>.</td>
</tr>
<tr class="even">
<td><code>char int_p_sep_by_space</code></td>
<td>Valor internacional para <code>p_sep_by_space</code>.</td>
</tr>
<tr class="odd">
<td><code>char int_n_sep_by_space</code></td>
<td>Valor internacional para <code>n_sep_by_space</code>.</td>
</tr>
<tr class="even">
<td><code>char int_p_sign_posn</code></td>
<td>Valor internacional para <code>p_sign_posn</code>.</td>
</tr>
<tr class="odd">
<td><code>char int_n_sign_posn</code></td>
<td>Valor internacional para <code>n_sign_posn</code>.</td>
</tr>
</tbody>
</table>
<p></p>
<h3 data-number="26.2.1" id="monetary-digit-grouping"><span class="header-section-number">26.2.1</span> Agrupación de dígitos monetarios</h3>
<p></p>
<p>Vale, esto es un poco raro. <code>mon_grouping</code> es un <code>char*</code>, así que podrías pensar que es una cadena. Pero en este caso, no, en realidad es un array de <code>char</code>s. Siempre debe terminar en <code>0</code> o <code>CHAR_MAX</code>.</p>
<p>Estos valores describen cómo agrupar conjuntos de números en moneda a la <em>izquierda</em> del decimal (la parte del número entero).</p>
<p>Por ejemplo, podríamos tener:</p>
<div class="sourceCode" id="cb540"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb540-1"><a href="#cb540-1" aria-hidden="true" tabindex="-1"></a>  2   1   0</span>
<span id="cb540-2"><a href="#cb540-2" aria-hidden="true" tabindex="-1"></a> --- --- ---</span>
<span id="cb540-3"><a href="#cb540-3" aria-hidden="true" tabindex="-1"></a>$100,000,000.00</span></code></pre></div>
<p>Se trata de grupos de tres. El grupo 0 (justo a la izquierda del decimal) tiene 3 dígitos. El grupo 1 (el siguiente a la izquierda) tiene 3 dígitos, y el último también tiene 3.</p>
<p>Así que podríamos describir estos grupos, de la derecha (el decimal) a la izquierda con un montón de valores enteros que representan los tamaños de los grupos:</p>
<div class="sourceCode" id="cb541"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb541-1"><a href="#cb541-1" aria-hidden="true" tabindex="-1"></a>3 3 3</span></code></pre></div>
<p>Y eso funcionaría para valores de hasta 100.000.000 de dólares.</p>
<p>Pero ¿y si tuviéramos más? Podríamos seguir añadiendo <code>3</code>s …</p>
<div class="sourceCode" id="cb542"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb542-1"><a href="#cb542-1" aria-hidden="true" tabindex="-1"></a>3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3</span></code></pre></div>
<p>pero eso es una locura. Por suerte, podemos especificar <code>0</code> para indicar que se repite el tamaño de grupo anterior:</p>
<div class="sourceCode" id="cb543"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb543-1"><a href="#cb543-1" aria-hidden="true" tabindex="-1"></a>3 0</span></code></pre></div>
<p>Lo que significa repetir cada 3. Eso manejaría $100, $1,000, $10,000, $10,000,000, $100,000,000,000, y así sucesivamente.</p>
<p>Usted puede ir legítimamente loco con estos para indicar algunas agrupaciones extrañas.</p>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb544"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb544-1"><a href="#cb544-1" aria-hidden="true" tabindex="-1"></a>4 3 2 1 0</span></code></pre></div>
<p>indicaría:</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb545-1"><a href="#cb545-1" aria-hidden="true" tabindex="-1"></a>$1,0,0,0,0,00,000,0000.00</span></code></pre></div>
<p>Otro valor que puede aparecer es <code>CHAR_MAX</code>. Indica que no se debe agrupar más, y puede aparecer en cualquier parte de la matriz, incluido el primer valor.</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb546-1"><a href="#cb546-1" aria-hidden="true" tabindex="-1"></a>3 2 CHAR_MAX</span></code></pre></div>
<p>indicaría:</p>
<div class="sourceCode" id="cb547"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb547-1"><a href="#cb547-1" aria-hidden="true" tabindex="-1"></a>100000000,00,000.00</span></code></pre></div>
<p>por ejemplo.</p>
<p>Y el simple hecho de tener <code>CHAR_MAX</code> en la primera posición del array te indicaría que no iba a haber ningún tipo de agrupación.</p>
<p></p>
<h3 data-number="26.2.2" id="separadores-y-posición-del-cartel"><span class="header-section-number">26.2.2</span> Separadores y posición del cartel</h3>
<p></p>
<p>Todas las variantes de <code>sep_by_space</code> se ocupan del espaciado alrededor del signo monetario. Los valores válidos son:</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Valor</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>0</code></td>
<td>No hay espacio entre el símbolo de la moneda y el valor.</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1</code></td>
<td>Separe el símbolo de moneda (y el signo, si existe) del valor con un espacio.</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>2</code></td>
<td>Separe el símbolo de signo del símbolo de moneda (si es adyacente) con un espacio; de lo contrario, separe el símbolo de signo del valor con un espacio.</td>
</tr>
</tbody>
</table>
<p>Las variantes de <code>sign_posn</code> vienen determinadas por los siguientes valores:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Valor</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>0</code></td>
<td>Pon paréntesis alrededor del valor y del símbolo monetario.</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1</code></td>
<td>Coloque el signo delante del símbolo monetario y del valor.</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>2</code></td>
<td>Poner el signo después del símbolo monetario y del valor.</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>3</code></td>
<td>Poner el signo directamente delante del símbolo de moneda</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>4</code></td>
<td>Coloque el signo directamente detrás del símbolo de moneda.</td>
</tr>
</tbody>
</table>
<p> </p>
<h3 data-number="26.2.3" id="ejemplos-de-valores"><span class="header-section-number">26.2.3</span> Ejemplos de valores</h3>
<p>Cuando obtengo los valores en mi sistema, esto es lo que veo (cadena de agrupación mostrada como valores de bytes individuales):</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb548-1"><a href="#cb548-1" aria-hidden="true" tabindex="-1"></a>mon_decimal_point  <span class="op">=</span> <span class="st">&quot;.&quot;</span></span>
<span id="cb548-2"><a href="#cb548-2" aria-hidden="true" tabindex="-1"></a>mon_thousands_sep  <span class="op">=</span> <span class="st">&quot;,&quot;</span></span>
<span id="cb548-3"><a href="#cb548-3" aria-hidden="true" tabindex="-1"></a>mon_grouping       <span class="op">=</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">0</span></span>
<span id="cb548-4"><a href="#cb548-4" aria-hidden="true" tabindex="-1"></a>positive_sign      <span class="op">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb548-5"><a href="#cb548-5" aria-hidden="true" tabindex="-1"></a>negative_sign      <span class="op">=</span> <span class="st">&quot;-&quot;</span></span>
<span id="cb548-6"><a href="#cb548-6" aria-hidden="true" tabindex="-1"></a>currency_symbol    <span class="op">=</span> <span class="st">&quot;$&quot;</span></span>
<span id="cb548-7"><a href="#cb548-7" aria-hidden="true" tabindex="-1"></a>frac_digits        <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb548-8"><a href="#cb548-8" aria-hidden="true" tabindex="-1"></a>p_cs_precedes      <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-9"><a href="#cb548-9" aria-hidden="true" tabindex="-1"></a>n_cs_precedes      <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-10"><a href="#cb548-10" aria-hidden="true" tabindex="-1"></a>p_sep_by_space     <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb548-11"><a href="#cb548-11" aria-hidden="true" tabindex="-1"></a>n_sep_by_space     <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb548-12"><a href="#cb548-12" aria-hidden="true" tabindex="-1"></a>p_sign_posn        <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-13"><a href="#cb548-13" aria-hidden="true" tabindex="-1"></a>n_sign_posn        <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-14"><a href="#cb548-14" aria-hidden="true" tabindex="-1"></a>int_curr_symbol    <span class="op">=</span> <span class="st">&quot;USD &quot;</span></span>
<span id="cb548-15"><a href="#cb548-15" aria-hidden="true" tabindex="-1"></a>int_frac_digits    <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb548-16"><a href="#cb548-16" aria-hidden="true" tabindex="-1"></a>int_p_cs_precedes  <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-17"><a href="#cb548-17" aria-hidden="true" tabindex="-1"></a>int_n_cs_precedes  <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-18"><a href="#cb548-18" aria-hidden="true" tabindex="-1"></a>int_p_sep_by_space <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-19"><a href="#cb548-19" aria-hidden="true" tabindex="-1"></a>int_n_sep_by_space <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-20"><a href="#cb548-20" aria-hidden="true" tabindex="-1"></a>int_p_sign_posn    <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb548-21"><a href="#cb548-21" aria-hidden="true" tabindex="-1"></a>int_n_sign_posn    <span class="op">=</span> <span class="dv">1</span></span></code></pre></div>
<h2 data-number="26.3" id="especificidades-de-localización"><span class="header-section-number">26.3</span> Especificidades de localización</h2>
<p>Observe cómo pasamos la macro <code>LC_ALL</code> a <code>setlocale()</code> anteriormente… esto indica que podría haber alguna variante que le permita ser más preciso sobre qué <em>partes</em> de la configuración regional está configurando.</p>
<p>Echemos un vistazo a los valores que puede ver para estos:</p>
<p> </p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th>Macro</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>LC_ALL</code></td>
<td>Establece todo lo siguiente a la configuración regional dada.</td>
</tr>
<tr class="even">
<td><code>LC_COLLATE</code></td>
<td>Controla el comportamiento de las funciones <code>strcoll()</code> y <code>strxfrm()</code>.</td>
</tr>
<tr class="odd">
<td><code>LC_CTYPE</code></td>
<td>Controla el comportamiento de las funciones de tratamiento de caracteres<a href="#fn156" class="footnote-ref" id="fnref156" role="doc-noteref"><sup>156</sup></a>..</td>
</tr>
<tr class="even">
<td><code>LC_MONETARY</code></td>
<td>Controla los valores devueltos por <code>localeconv()</code>.</td>
</tr>
<tr class="odd">
<td><code>LC_NUMERIC</code></td>
<td>Controla el punto decimal para la familia de funciones <code>printf()</code>.</td>
</tr>
<tr class="even">
<td><code>LC_TIME</code></td>
<td>Controla el formato de hora de las funciones de impresión de fecha y hora <code>strftime()</code> y <code>wcsftime()</code>.</td>
</tr>
</tbody>
</table>
<p>Es bastante común ver <code>LC_ALL</code>, pero, oye, al menos tienes opciones.</p>
<p>También debo señalar que <code>LC_CTYPE</code> es una de las más importantes porque se relaciona con los caracteres anchos, una importante caja de Pandora de la que hablaremos más adelante. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="27" id="unicode-caracteres-anchos-y-todo-eso"><span class="header-section-number">27</span> Unicode, caracteres anchos y todo eso</h1>
<p></p>
<p>Antes de empezar, ten en cuenta que esta es un área activa del desarrollo del lenguaje C, ya que trabaja para superar algunos, erm, <em>dolores de crecimiento</em>. Cuando salga C2x, es probable que haya actualizaciones.</p>
<p>La mayoría de la gente está básicamente interesada en la engañosamente simple pregunta: “¿Cómo uso tal y tal juego de caracteres en C?”. Ya llegaremos a eso. Pero como veremos, puede que ya funcione en tu sistema. O puede que tengas que recurrir a una biblioteca de terceros.</p>
<p>Vamos a hablar de muchas cosas en este capítulo—algunas son agnósticas a la plataforma, y otras son específicas de C.</p>
<p>Hagamos primero un resumen de lo que vamos a ver:</p>
<ul>
<li>Antecedentes de Unicode</li>
<li>Antecedentes de codificación de caracteres</li>
<li>Conjuntos de caracteres de origen y ejecución</li>
<li>Uso de Unicode y UTF-8</li>
<li>Usando otros tipos de caracteres como <code>wchar_t</code>, <code>char16_t</code>, y <code>char32_t</code></li>
</ul>
<p>¡Vamos a sumergirnos!</p>
<h2 data-number="27.1" id="qué-es-unicode"><span class="header-section-number">27.1</span> ¿Qué es Unicode?</h2>
<p>Antiguamente, en EE.UU. y en gran parte del mundo se solía utilizar una codificación de 7 u 8 bits para los caracteres de la memoria. Esto significaba que podíamos tener 128 o 256 caracteres (incluidos los caracteres no imprimibles) en total. Eso estaba bien para un mundo centrado en EE.UU, pero resulta que en realidad hay otros alfabetos ahí fuera… ¿quién lo iba a decir? El chino tiene más de 50.000 caracteres, y eso no cabe en un byte.</p>
<p>Así que la gente inventó todo tipo de formas alternativas para representar sus propios conjuntos de caracteres personalizados. Y eso estaba bien, pero se convirtió en una pesadilla de compatibilidad.</p>
<p>Para evitarlo, se inventó Unicode. Un conjunto de caracteres para gobernarlos a todos. Se extiende hasta el infinito (efectivamente) para que nunca nos quedemos sin espacio para nuevos caracteres. Incluye caracteres chinos, latinos, griegos, cuneiformes, símbolos de ajedrez, emojis… ¡casi todo! Y cada vez se añaden más.</p>
<h2 data-number="27.2" id="puntos-de-código"><span class="header-section-number">27.2</span> Puntos de código</h2>
<p></p>
<p>Quiero hablar de dos conceptos. Es confuso porque ambos son números… números diferentes para la misma cosa. Pero tengan paciencia.</p>
<p>Definamos vagamente <em>punto de código</em> como un valor numérico que representa un carácter. (Los puntos de código también pueden representar caracteres de control no imprimibles, pero suponga que me refiero a algo como la letra “B” o el carácter “π”).</p>
<p>Cada punto de código representa un carácter único. Y cada carácter tiene asociado un punto de código numérico único.</p>
<p>Por ejemplo, en Unicode, el valor numérico 66 representa “B”, y 960 representa “π”. Otros mapeados de caracteres que no son Unicode utilizan valores diferentes, pero olvidémonos de ellos y concentrémonos en Unicode, ¡el futuro!</p>
<p>Así que eso es una cosa: hay un número que representa a cada carácter. En Unicode, estos números van de 0 a más de 1 millón.</p>
<p></p>
<p>¿Entendido?</p>
<p>Porque estamos a punto de voltear la mesa un poco.</p>
<h2 data-number="27.3" id="codificación"><span class="header-section-number">27.3</span> Codificación</h2>
<p></p>
<p>Si recuerdas, un byte de 8 bits puede contener valores de 0 a 255, ambos inclusive. Eso está muy bien para “B” que es 66—que cabe en un byte. Pero “π” es 960, ¡y eso no cabe en un byte! Necesitamos otro byte. ¿Cómo almacenamos todo eso en la memoria? ¿O qué pasa con los números más grandes, como 195.024? Necesitaremos varios bytes.</p>
<p>La gran pregunta: ¿cómo se representan estos números en la memoria? Esto es lo que llamamos la <em>codificación</em> de los caracteres.</p>
<p>Así que tenemos dos cosas: una es el punto de código, que nos indica efectivamente el número de serie de un carácter concreto. Y tenemos la codificación, que nos dice cómo vamos a representar ese número en la memoria.</p>
<p>Hay muchas codificaciones. <a href="#fn157" class="footnote-ref" id="fnref157" role="doc-noteref"><sup>157</sup></a>. Pero vamos a ver algunas codificaciones realmente comunes que se usan con Unicode.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Codificación</th>
<th style="text-align: left;">Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">UTF-8</td>
<td style="text-align: left;">Codificación orientada a bytes que utiliza un número variable de bytes por carácter. Esta es la que se debe utilizar.</td>
</tr>
<tr class="even">
<td style="text-align: center;">UTF-16</td>
<td style="text-align: left;">Una codificación de 16 bits por carácter<a href="#fn158" class="footnote-ref" id="fnref158" role="doc-noteref"><sup>158</sup></a>.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">UTF-32</td>
<td style="text-align: left;">Una codificación de 32 bits por carácter.</td>
</tr>
</tbody>
</table>
<p>Con UTF-16 y UTF-32, el orden de bytes importa, por lo que puede ver UTF-16BE para big-endian y UTF-16LE para little-endian. Lo mismo ocurre con UTF-32. Técnicamente, si no se especifica, se debe asumir big-endian. Pero como Windows usa UTF-16 extensivamente y es little-endian, a veces se asume<a href="#fn159" class="footnote-ref" id="fnref159" role="doc-noteref"><sup>159</sup></a>.</p>
<p>Veamos algunos ejemplos. Voy a escribir los valores en hexadecimal porque son exactamente dos dígitos por byte de 8 bits, y así es más fácil ver cómo se ordenan las cosas en la memoria.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Caracter</th>
<th style="text-align: center;">Punto de Código</th>
<th style="text-align: center;">UTF-16BE</th>
<th style="text-align: center;">UTF-32BE</th>
<th style="text-align: center;">UTF-16LE</th>
<th style="text-align: center;">UTF-32LE</th>
<th style="text-align: center;">UTF-8</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>A</code></td>
<td style="text-align: center;">41</td>
<td style="text-align: center;">0041</td>
<td style="text-align: center;">00000041</td>
<td style="text-align: center;">4100</td>
<td style="text-align: center;">41000000</td>
<td style="text-align: center;">41</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>B</code></td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">0042</td>
<td style="text-align: center;">00000042</td>
<td style="text-align: center;">4200</td>
<td style="text-align: center;">42000000</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>~</code></td>
<td style="text-align: center;">7E</td>
<td style="text-align: center;">007E</td>
<td style="text-align: center;">0000007E</td>
<td style="text-align: center;">7E00</td>
<td style="text-align: center;">7E000000</td>
<td style="text-align: center;">7E</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>π</code></td>
<td style="text-align: center;">3C0</td>
<td style="text-align: center;">03C0</td>
<td style="text-align: center;">000003C0</td>
<td style="text-align: center;">C003</td>
<td style="text-align: center;">C0030000</td>
<td style="text-align: center;">CF80</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>€</code></td>
<td style="text-align: center;">20AC</td>
<td style="text-align: center;">20AC</td>
<td style="text-align: center;">000020AC</td>
<td style="text-align: center;">AC20</td>
<td style="text-align: center;">AC200000</td>
<td style="text-align: center;">E282AC</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p></p>
<p>Busca ahí los patrones. Tenga en cuenta que UTF-16BE y UTF-32BE son simplemente el punto de código representado directamente como valores de 16 y 32 bits<a href="#fn160" class="footnote-ref" id="fnref160" role="doc-noteref"><sup>160</sup></a>.</p>
<p> </p>
<p>Little-endian es lo mismo, excepto que los bytes están en orden little-endian.</p>
<p></p>
<p>Luego tenemos UTF-8 al final. En primer lugar, te darás cuenta de que los puntos de código de un solo byte se representan como un solo byte. Eso está bien. También puedes observar que los distintos puntos de código ocupan un número diferente de bytes. Se trata de una codificación de ancho variable.</p>
<p>Así que tan pronto como superamos un cierto valor, UTF-8 empieza a utilizar bytes adicionales para almacenar los valores. Y tampoco parecen estar correlacionados con el valor del punto de código.</p>
<p><a href="https://en.wikipedia.org/wiki/UTF-8">Los detalles de la codificación UTF-8</a><a href="#fn161" class="footnote-ref" id="fnref161" role="doc-noteref"><sup>161</sup></a> quedan fuera del alcance de esta guía, pero basta con saber que tiene un número variable de bytes por punto de código, y que esos valores de bytes no coinciden con el punto de código <em>excepto los 128 primeros puntos de código</em>. Si realmente quieres aprender más, <a href="https://www.youtube.com/watchv=MijmeoH9LT4">Computerphile tiene un gran video de UTF-8 con Tom Scott</a><a href="#fn162" class="footnote-ref" id="fnref162" role="doc-noteref"><sup>162</sup></a>.</p>
<p>Esto último es lo bueno de Unicode y UTF-8 desde una perspectiva norteamericana: ¡es compatible con la codificación ASCII de 7 bits! Así que si estás acostumbrado a ASCII, UTF-8 es lo mismo. Todos los documentos codificados en ASCII también están codificados en UTF-8. (Pero no al revés, obviamente).</p>
<p>Probablemente sea este último punto más que ningún otro el que está impulsando a UTF-8 a conquistar el mundo.</p>
<p> </p>
<h2 data-number="27.4" id="src-exec-charset"><span class="header-section-number">27.4</span> Juegos de caracteres de origen y ejecución</h2>
<p></p>
<p>Al programar en C, hay (al menos) tres conjuntos de caracteres en juego:</p>
<ul>
<li>El que su código existe en el disco como.</li>
<li>El que el compilador traduce justo cuando comienza la compilación (el <em>source character set</em>). Este puede ser el mismo que el del disco, o puede que no.</li>
<li>Aquel al que el compilador traduce el juego de caracteres fuente para su ejecución (el <em>juego de caracteres de ejecución</em>). Este puede ser el mismo que el juego de caracteres fuente, o puede que no.</li>
</ul>
<p>Su compilador probablemente disponga de opciones para seleccionar estos conjuntos de caracteres en el momento de la compilación. </p>
<p>El juego de caracteres básico tanto para el origen como para la ejecución contendrá los siguientes caracteres:</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb549-1"><a href="#cb549-1" aria-hidden="true" tabindex="-1"></a>A B C D E F G H I J K L M</span>
<span id="cb549-2"><a href="#cb549-2" aria-hidden="true" tabindex="-1"></a>N O P Q R S T U V W X Y Z</span>
<span id="cb549-3"><a href="#cb549-3" aria-hidden="true" tabindex="-1"></a>a b c d e f g h i j k l m</span>
<span id="cb549-4"><a href="#cb549-4" aria-hidden="true" tabindex="-1"></a>n o p q r s t u v w x y z</span>
<span id="cb549-5"><a href="#cb549-5" aria-hidden="true" tabindex="-1"></a>0 1 2 3 4 5 6 7 8 9</span>
<span id="cb549-6"><a href="#cb549-6" aria-hidden="true" tabindex="-1"></a>! &quot; # % &amp; &#39; ( ) * + , - . / :</span>
<span id="cb549-7"><a href="#cb549-7" aria-hidden="true" tabindex="-1"></a>; &lt; = &gt; ? [ \ ] ^ _ { | } ~</span>
<span id="cb549-8"><a href="#cb549-8" aria-hidden="true" tabindex="-1"></a>space tab vertical-tab</span>
<span id="cb549-9"><a href="#cb549-9" aria-hidden="true" tabindex="-1"></a>form-feed end-of-line</span></code></pre></div>
<p>Esos son los caracteres que puedes utilizar en tu código fuente y seguir siendo 100% portable.</p>
<p>El conjunto de caracteres de ejecución tendrá además caracteres para alerta (campana/flash), retroceso, retorno de carro y nueva línea.</p>
<p>Pero la mayoría de la gente no llega a ese extremo y utiliza libremente sus conjuntos de caracteres extendidos en el código fuente y el ejecutable, especialmente ahora que Unicode y UTF-8 son cada vez más comunes. Quiero decir, ¡el juego de caracteres básico ni siquiera permite <code>@</code>, <code>$</code>, o <code></code>!</p>
<p>En particular, es un engorro (aunque posible con secuencias de escape) introducir caracteres Unicode utilizando sólo el juego de caracteres básico.</p>
<p> </p>
<h2 data-number="27.5" id="unicode-in-c"><span class="header-section-number">27.5</span> Unicode en C</h2>
<p>Antes de entrar en la codificación en C, hablemos de Unicode desde el punto de vista de los puntos de código. Hay una manera en C para especificar caracteres Unicode y estos serán traducidos por el compilador en el conjunto de caracteres de ejecución<a href="#fn163" class="footnote-ref" id="fnref163" role="doc-noteref"><sup>163</sup></a>.</p>
<p>Entonces, ¿cómo lo hacemos?</p>
<p>¿Qué tal el símbolo del euro, punto de código 0x20AC? (Lo he escrito en hexadecimal porque ambas formas de representarlo en C requieren hexadecimal). ¿Cómo podemos ponerlo en nuestro código C?</p>
<p> Utiliza el escape <code>\u</code> para ponerlo en una cadena, por ejemplo <code>"\u20AC"</code> (las mayúsculas y minúsculas del hexadecimal no importan). Debe poner <strong>exactamente cuatro</strong> dígitos hexadecimales después de la “u”, rellenando con ceros a la izquierda si es necesario.</p>
<p>He aquí un ejemplo:</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb550-1"><a href="#cb550-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;</span><span class="sc">\u20AC</span><span class="st">1.23&quot;</span><span class="op">;</span></span>
<span id="cb550-2"><a href="#cb550-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb550-3"><a href="#cb550-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>  <span class="co">// €1.23</span></span></code></pre></div>
<p></p>
<p>Así pues, <code>\u</code> funciona para los puntos de código Unicode de 16 bits, pero ¿qué pasa con los que tienen más de 16 bits? Para eso, necesitamos mayúsculas: <code>\U</code>.</p>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb551"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb551-1"><a href="#cb551-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;</span><span class="sc">\U0001D4D1</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb551-2"><a href="#cb551-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb551-3"><a href="#cb551-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>  <span class="co">// Imprime una matemática letter &quot;B&quot;</span></span></code></pre></div>
<p>Es lo mismo que <code>\u</code>, sólo que con 32 bits en lugar de 16. Son equivalentes:</p>
<div class="sourceCode" id="cb552"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb552-1"><a href="#cb552-1" aria-hidden="true" tabindex="-1"></a>\u03C0</span>
<span id="cb552-2"><a href="#cb552-2" aria-hidden="true" tabindex="-1"></a>\U000003C0</span></code></pre></div>
<p> </p>
<p>De nuevo, se traducen al juego de caracteres de ejecución durante la compilación. Representan puntos de código Unicode, no una codificación específica. Además, si un punto de código Unicode no es representable en el conjunto de caracteres de ejecución, el compilador puede hacer lo que quiera con él.</p>
<p>Ahora bien, puede que se pregunte por qué no puede hacer esto sin más:</p>
<div class="sourceCode" id="cb553"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb553-1"><a href="#cb553-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;€1.23&quot;</span><span class="op">;</span></span>
<span id="cb553-2"><a href="#cb553-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb553-3"><a href="#cb553-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>  <span class="co">// €1.23</span></span></code></pre></div>
<p>Y probablemente pueda, dado un compilador moderno. El juego de caracteres fuente será traducido por el compilador al juego de caracteres de ejecución. Pero los compiladores son libres de vomitar si encuentran cualquier carácter que no esté incluido en su juego de caracteres extendido, y el símbolo € ciertamente no está en el juego de caracteres básico.</p>
<p> </p>
<p>Advertencia de la especificación: no se puede utilizar <code>\u</code> o <code>\U</code> para codificar ningún punto de código por debajo de 0xA0 excepto 0x24 (<code>$</code>), 0x40 (<code>@</code>), y 0x60 (`` ```)—sí, esos son precisamente el trío de signos de puntuación comunes que faltan en el juego de caracteres básico. Al parecer, esta restricción se relajará en la próxima versión de la especificación.</p>
<p> </p>
<p>Por último, también puede utilizar estos en identificadores en su código, con algunas restricciones. Pero no quiero entrar en eso aquí. En este capítulo nos centramos en el manejo de cadenas.</p>
<p>Y eso es todo sobre Unicode en C (excepto la codificación).</p>
<h2 data-number="27.6" id="utf8-quick"><span class="header-section-number">27.6</span> Una nota rápida sobre UTF-8 antes de adentrarnos en la maleza</h2>
<p></p>
<p>Podría ser que tu archivo fuente en disco, los caracteres fuente extendidos y los caracteres de ejecución extendidos estén todos en formato UTF-8. Y las bibliotecas que utilizas esperan UTF-8. Este es el glorioso futuro de UTF-8 en todas partes.</p>
<p>Si ese es el caso, y no te importa ser no-portable a sistemas que no son así, entonces simplemente corre con ello. Mete caracteres Unicode en tus fuentes y datos a voluntad. Usa cadenas C normales y sé feliz.</p>
<p>Muchas cosas funcionarán (aunque de forma no portable) porque las cadenas UTF-8 pueden terminar en NUL de forma segura como cualquier otra cadena C. Pero tal vez perder portabilidad a cambio de un manejo más sencillo de los caracteres sea una compensación que merezca la pena.</p>
<p>Sin embargo, hay algunas advertencias:</p>
<ul>
<li><p>Cosas como <code>strlen()</code> informan del número de bytes de una cadena, no necesariamente del número de caracteres. (La función <code>mbstowcs()</code> devuelve el número de caracteres de una cadena cuando la convierte a caracteres anchos. POSIX extiende esto para que pueda pasar <code>NULL</code> para el primer argumento si sólo quiere el recuento de caracteres).</p></li>
<li><p>Lo siguiente no funcionará correctamente con caracteres de más de un byte: <code>strtok()</code>, <code>strchr()</code> (use <code>str()</code> en su lugar), funciones del tipo <code>strspn()</code>, <code>toupper()</code>, <code>tolower()</code>, <code>isalpha()</code>-type functions, y probablemente más. Cuidado con todo lo que opere sobre bytes.</p></li>
<li><p><code>printf()</code> variants allow for a way to only print so many bytes of a string<a href="#fn164" class="footnote-ref" id="fnref164" role="doc-noteref"><sup>164</sup></a>. Quieres asegurarte de que imprimes el número correcto de bytes para terminar en un límite de carácter.</p></li>
<li><p>Si quieres <code>malloc()</code> espacio para una cadena, o declarar un array de <code>char</code>s para una, ten en cuenta que el tamaño máximo podría ser más de lo que esperabas. Cada caracter puede ocupar hasta <code>MB_LEN_MAX</code> bytes (de <code>&lt;limits.h&gt;</code>)—excepto los caracteres del juego de caracteres básico que se garantiza que son de un byte</p></li>
</ul>
<p>Y probablemente otros que no he descubierto. Háganme saber qué trampas hay por ahí…</p>
<p></p>
<h2 data-number="27.7" id="diferentes-tipos-de-personajes"><span class="header-section-number">27.7</span> Diferentes tipos de personajes</h2>
<p>Quiero introducir más tipos de caracteres. Estamos acostumbrados a <code>char</code>, ¿verdad?</p>
<p>Pero eso es demasiado fácil. ¡Hagamos las cosas mucho más difíciles! ¡Sí!</p>
<h3 data-number="27.7.1" id="caracteres-multibyte"><span class="header-section-number">27.7.1</span> Caracteres multibyte</h3>
<p></p>
<p>En primer lugar, quiero cambiar potencialmente tu idea de lo que es una cadena (array de <code>char</code>s). Son <em>cadenas multibyte</em> formadas por <em>caracteres multibyte</em>.</p>
<p>Así es, una cadena de caracteres común y corriente es multibyte. Cuando alguien dice “cadena C”, quiere decir “cadena multibyte C”.</p>
<p>Incluso si un carácter en particular en la cadena es sólo un byte, o si una cadena se compone sólo de caracteres simples, se conoce como una cadena multibyte.</p>
<p>Por ejemplo:</p>
<div class="sourceCode" id="cb554"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb554-1"><a href="#cb554-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c<span class="op">[</span><span class="dv">128</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span>  <span class="co">// Multibyte string</span></span></code></pre></div>
<p>Lo que queremos decir con esto es que un carácter concreto que no esté en el juego de caracteres básico podría estar compuesto por varios bytes. Hasta <code>MB_LEN_MAX</code> de ellos (de <code>&lt;limits.h&gt;</code>). Claro, sólo parece un carácter en la pantalla, pero podrían ser múltiples bytes.</p>
<p>También puedes meter valores Unicode, como vimos antes:</p>
<div class="sourceCode" id="cb555"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb555-1"><a href="#cb555-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;</span><span class="sc">\u20AC</span><span class="st">1.23&quot;</span><span class="op">;</span></span>
<span id="cb555-2"><a href="#cb555-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb555-3"><a href="#cb555-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>  <span class="co">// €1.23</span></span></code></pre></div>
<p>Pero aquí entramos en algo raro, porque mira esto:</p>
<p></p>
<div class="sourceCode" id="cb556"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb556-1"><a href="#cb556-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;</span><span class="sc">\u20AC</span><span class="st">1.23&quot;</span><span class="op">;</span>  <span class="co">// €1.23</span></span>
<span id="cb556-2"><a href="#cb556-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb556-3"><a href="#cb556-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> strlen<span class="op">(</span>s<span class="op">));</span>  <span class="co">// 7!</span></span></code></pre></div>
<p>¡¿La longitud de la cadena de <code>"€1.23"</code> es <code>7</code>?! ¡Sí! Bueno, en mi sistema, ¡sí! Recuerde que <code>strlen()</code> devuelve el número de bytes de la cadena, no el número de caracteres. (Cuando lleguemos a “caracteres anchos”, más adelante, veremos una forma de obtener el número de caracteres de la cadena).</p>
<p></p>
<p>Tenga en cuenta que aunque C permite constantes individuales multibyte <code>char</code> (en oposición a <code>char*</code>), el comportamiento de éstas varía según la implementación y su compilador podría advertirle de ello.</p>
<p>GCC, por ejemplo, advierte de constantes de caracteres multibyte para las dos líneas siguientes (y, en mi sistema, imprime la codificación UTF-8):</p>
<div class="sourceCode" id="cb557"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb557-1"><a href="#cb557-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%x\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="ch">&#39;€&#39;</span><span class="op">);</span></span>
<span id="cb557-2"><a href="#cb557-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%x\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="ch">&#39;\</span><span class="er">u20ac</span><span class="ch">&#39;</span><span class="op">);</span></span></code></pre></div>
<p></p>
<h3 data-number="27.7.2" id="wide-characters"><span class="header-section-number">27.7.2</span> Caracteres anchos</h3>
<p></p>
<p>Si no es un carácter multibyte, entonces es un <em>carácter ancho</em>.</p>
<p>Un carácter ancho es un valor único que puede representar cualquier carácter en la configuración regional actual. Es análogo a los puntos de código Unicode. Pero podría no serlo. O podría serlo.</p>
<p>Básicamente, mientras que las cadenas de caracteres multibyte son matrices de bytes, las cadenas de caracteres anchos son matrices de <em>caracteres</em>. Así que puedes empezar a pensar carácter por carácter en lugar de byte por byte (esto último se complica cuando los caracteres empiezan a ocupar un número variable de bytes).</p>
<p></p>
<p>Los caracteres anchos pueden representarse mediante varios tipos, pero el más destacado es <code>wchar_t</code>. Es el principal. Es como <code>char</code>, pero ancho.</p>
<p>Te estarás preguntando si no puedes saber si es Unicode o no, ¿cómo te permite eso mucha flexibilidad a la hora de escribir código? <code>wchar_t</code> abre algunas de esas puertas, ya que hay un rico conjunto de funciones que puedes usar para tratar con cadenas <code>wchar_t</code> (como obtener la longitud, etc.) sin preocuparte de la codificación.</p>
<h2 data-number="27.8" id="uso-de-caracteres-anchos-y-wchar_t"><span class="header-section-number">27.8</span> Uso de caracteres anchos y <code>wchar_t</code></h2>
<p>Es hora de un nuevo tipo: <code>wchar_t</code>. Este es el principal tipo de carácter ancho. ¿Recuerdas que un <code>char</code> es sólo un byte? ¿Y un byte no es suficiente para representar todos los caracteres, potencialmente? Pues este es suficiente.</p>
<p>Para usar <code>wchar_t</code>, incluye <code>&lt;wchar.h&gt;</code>.</p>
<p>¿De cuántos bytes es? Bueno, no está del todo claro. Podrían ser 16 bits. Podrían ser 32 bits.</p>
<p>Pero espera, estás diciendo—si son sólo 16 bits, no es lo suficientemente grande como para contener todos los puntos de código Unicode, ¿verdad? Tienes razón, no lo es. La especificación no requiere que lo sea. Sólo tiene que ser capaz de representar todos los caracteres de la configuración regional actual.</p>
<p>Esto puede causar problemas con Unicode en plataformas con <code>wchar_t</code>s de 16 bits (ejem—Windows). Pero eso está fuera del alcance de esta guía.</p>
<p></p>
<p>Puede declarar una cadena o carácter de este tipo con el prefijo <code>L</code>, y puede imprimirlos con el especificador de formato <code>%ls</code> (“ell ess”). O imprimir un <code>wchar_t</code> individual con <code>%lc</code>.</p>
<div class="sourceCode" id="cb558"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb558-1"><a href="#cb558-1" aria-hidden="true" tabindex="-1"></a><span class="dt">wchar_t</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">L&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb558-2"><a href="#cb558-2" aria-hidden="true" tabindex="-1"></a><span class="dt">wchar_t</span> c <span class="op">=</span> <span class="ch">L&#39;B&#39;</span><span class="op">;</span></span>
<span id="cb558-3"><a href="#cb558-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb558-4"><a href="#cb558-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%ls</span><span class="st"> </span><span class="sc">%lc\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">,</span> c<span class="op">);</span></span></code></pre></div>
<p></p>
<p>Ahora bien, ¿estos caracteres se almacenan como puntos de código Unicode o no? Depende de la implementación. Pero puedes comprobar si lo están con la macro . <code>__STDC_ISO_10646__</code>. Si está definida, la respuesta es: “¡Es Unicode!”.</p>
<p>Más detalladamente, el valor de esa macro es un número entero de la forma <code>yyyymm</code> que le permite saber en qué estándar Unicode puede confiar—el que estuviera en vigor en esa fecha.</p>
<p>Pero, ¿cómo se utilizan?</p>
<h3 data-number="27.8.1" id="conversiones-de-multibyte-a-wchar_t"><span class="header-section-number">27.8.1</span> Conversiones de Multibyte a <code>wchar_t</code></h3>
<p>Entonces, ¿cómo pasamos de las cadenas estándar orientadas a bytes a las cadenas anchas orientadas a caracteres y viceversa?</p>
<p>Podemos utilizar un par de funciones de conversión de cadenas para hacerlo.</p>
<p>Primero, algunas convenciones de nomenclatura que verás en estas funciones:</p>
<ul>
<li><code>mb</code>: multibyte</li>
<li><code>wc</code>: carácter ancho</li>
<li><code>mbs</code>: cadena multibyte</li>
<li><code>wcs</code>: cadena de caracteres anchos</li>
</ul>
<p>Así que si queremos convertir una cadena multibyte en una cadena de caracteres anchos, podemos llamar a <code>mbstowcs()</code>. Y al revés: <code>wcstombs()</code>.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Función de conversión</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mbtowc()</code></td>
<td>Convierte un carácter multibyte en un carácter ancho.</td>
</tr>
<tr class="even">
<td><code>wctomb()</code></td>
<td>Convierte un carácter ancho en un carácter multibyte.</td>
</tr>
<tr class="odd">
<td><code>mbstowcs()</code></td>
<td>Convierte una cadena multibyte en una cadena ancha.</td>
</tr>
<tr class="even">
<td><code>wcstombs()</code></td>
<td>Convierte una cadena ancha en una cadena multibyte.</td>
</tr>
</tbody>
</table>
<p>Hagamos una demostración rápida en la que convertiremos una cadena multibyte en una cadena de caracteres anchos, y compararemos las longitudes de cadena de ambas utilizando sus respectivas funciones.</p>
<p></p>
<div class="sourceCode" id="cb559"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb559-1"><a href="#cb559-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb559-2"><a href="#cb559-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb559-3"><a href="#cb559-3"></a><span class="pp">#include </span><span class="im">&lt;wchar.h&gt;</span></span>
<span id="cb559-4"><a href="#cb559-4"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb559-5"><a href="#cb559-5"></a><span class="pp">#include </span><span class="im">&lt;locale.h&gt;</span></span>
<span id="cb559-6"><a href="#cb559-6"></a></span>
<span id="cb559-7"><a href="#cb559-7"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb559-8"><a href="#cb559-8"></a><span class="op">{</span></span>
<span id="cb559-9"><a href="#cb559-9"></a>    <span class="co">// Salir de la configuración regional C a una que probablemente tenga el símbolo del euro</span></span>
<span id="cb559-10"><a href="#cb559-10"></a>    setlocale<span class="op">(</span>LC_ALL<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb559-11"><a href="#cb559-11"></a></span>
<span id="cb559-12"><a href="#cb559-12"></a>    <span class="co">// Cadena multibyte original con el símbolo del euro (punto 20ac de Unicode)</span></span>
<span id="cb559-13"><a href="#cb559-13"></a>    <span class="dt">char</span> <span class="op">*</span>mb_string <span class="op">=</span> <span class="st">&quot;The cost is </span><span class="sc">\u20ac</span><span class="st">1.23&quot;</span><span class="op">;</span>  <span class="co">// €1.23</span></span>
<span id="cb559-14"><a href="#cb559-14"></a>    <span class="dt">size_t</span> mb_len <span class="op">=</span> strlen<span class="op">(</span>mb_string<span class="op">);</span></span>
<span id="cb559-15"><a href="#cb559-15"></a></span>
<span id="cb559-16"><a href="#cb559-16"></a>    <span class="co">// Matriz de caracteres anchos que contendrá la cadena convertida</span></span>
<span id="cb559-17"><a href="#cb559-17"></a>    <span class="dt">wchar_t</span> wc_string<span class="op">[</span><span class="dv">128</span><span class="op">];</span>  <span class="co">// Contiene hasta 128 caracteres de ancho</span></span>
<span id="cb559-18"><a href="#cb559-18"></a></span>
<span id="cb559-19"><a href="#cb559-19"></a>    <span class="co">// Convierte la cadena MB a WC; esto devuelve el número de caracteres anchos</span></span>
<span id="cb559-20"><a href="#cb559-20"></a>    <span class="dt">size_t</span> wc_len <span class="op">=</span> mbstowcs<span class="op">(</span>wc_string<span class="op">,</span> mb_string<span class="op">,</span> <span class="dv">128</span><span class="op">);</span></span>
<span id="cb559-21"><a href="#cb559-21"></a></span>
<span id="cb559-22"><a href="#cb559-22"></a>    <span class="co">// Imprime el resultado - nota las %ls para cadenas de caracteres anchos</span></span>
<span id="cb559-23"><a href="#cb559-23"></a>    printf<span class="op">(</span><span class="st">&quot;multibyte: </span><span class="sc">\&quot;%s\&quot;</span><span class="st"> (</span><span class="sc">%zu</span><span class="st"> bytes)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> mb_string<span class="op">,</span> mb_len<span class="op">);</span></span>
<span id="cb559-24"><a href="#cb559-24"></a>    printf<span class="op">(</span><span class="st">&quot;wide char: </span><span class="sc">\&quot;%ls\&quot;</span><span class="st"> (</span><span class="sc">%zu</span><span class="st"> characters)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> wc_string<span class="op">,</span> wc_len<span class="op">);</span></span>
<span id="cb559-25"><a href="#cb559-25"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>En mi sistema, esta salida:</p>
<div class="sourceCode" id="cb560"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb560-1"><a href="#cb560-1" aria-hidden="true" tabindex="-1"></a>multibyte: &quot;The cost is €1.23&quot; (19 bytes)</span>
<span id="cb560-2"><a href="#cb560-2" aria-hidden="true" tabindex="-1"></a>wide char: &quot;The cost is €1.23&quot; (17 characters)</span></code></pre></div>
<p>(Su sistema puede variar en el número de bytes dependiendo de su localización).</p>
<p>Una cosa interesante a tener en cuenta es que <code>mbstowcs()</code>, además de convertir la cadena multibyte a ancha, devuelve la longitud (en caracteres) de la cadena de caracteres anchos. En sistemas compatibles con POSIX, puede aprovechar un modo especial en el que <em>sólo</em> devuelve la longitud en caracteres de una cadena multibyte dada: sólo tiene que pasar <code>NULL</code> al destino, y <code>0</code> al número máximo de caracteres a convertir (este valor se ignora).</p>
<p>(En el código de abajo, estoy usando mi juego de caracteres fuente extendido—puede que tengas que reemplazarlos con escapes <code>\u</code>).</p>
<div class="sourceCode" id="cb561"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb561-1"><a href="#cb561-1" aria-hidden="true" tabindex="-1"></a>setlocale<span class="op">(</span>LC_ALL<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb561-2"><a href="#cb561-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb561-3"><a href="#cb561-3" aria-hidden="true" tabindex="-1"></a><span class="co">// La siguiente cadena tiene 7 caracteres</span></span>
<span id="cb561-4"><a href="#cb561-4" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> len_in_chars <span class="op">=</span> mbstowcs<span class="op">(</span>NULL<span class="op">,</span> <span class="st">&quot;§¶°±π€•&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb561-5"><a href="#cb561-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb561-6"><a href="#cb561-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu</span><span class="st">&quot;</span><span class="op">,</span> len_in_chars<span class="op">);</span>  <span class="co">// 7</span></span></code></pre></div>
<p></p>
<p>De nuevo, es una extensión POSIX no portable.</p>
<p>Y, por supuesto, si quieres convertir de la otra manera, es <code>wcstombs()</code>.</p>
<h2 data-number="27.9" id="funcionalidad-de-los-caracteres-anchos"><span class="header-section-number">27.9</span> Funcionalidad de los caracteres anchos</h2>
<p>Una vez en la tierra de los caracteres anchos, tenemos todo tipo de funciones a nuestra disposición. Sólo voy a resumir un montón de funciones, pero básicamente lo que tenemos aquí son las versiones de caracteres anchos de las funciones de cadena multibyte a las que estamos acostumbrados. (Por ejemplo, conocemos <code>strlen()</code> para cadenas multibyte; hay una &lt;]</p>
<p>Muchas de estas funciones utilizan un <code>wint_t</code> para contener caracteres individuales, ya sean pasados o devueltos.</p>
<p>Está relacionado con <code>wchar_t</code> por naturaleza. Un <code>wint_t</code> es un entero que puede representar todos los valores del juego de caracteres extendido, y también un carácter especial de fin de fichero, <code>WEOF</code>.</p>
<p></p>
<p>Lo utilizan varias funciones de caracteres anchos orientadas a un solo carácter.</p>
<h3 data-number="27.9.1" id="io-stream-orientation"><span class="header-section-number">27.9.1</span> Orientación del flujo de E/S</h3>
<p></p>
<p>Lo importante es no mezclar funciones orientadas a bytes (como <code>fprintf()</code>) con funciones orientadas a ancho (como <code>fwprintf()</code>). Decide si un flujo será orientado a bytes o a ancho y quédate con esos tipos de funciones de E/S.</p>
<p>En más detalle: los flujos pueden estar orientados a bytes u orientados a ancho. Cuando un flujo se crea por primera vez, no tiene orientación, pero la primera lectura o escritura establecerá la orientación.</p>
<p>Si utiliza por primera vez una operación amplia (como <code>fwprintf()</code>) orientará el flujo de forma amplia.</p>
<p>Si utiliza por primera vez una operación byte (como <code>fprintf()</code>) orientará el flujo por bytes.</p>
<p>Puede orientar manualmente un flujo desorientado de una forma u otra con una llamada a . <code>fwide()</code>. Puede utilizar esa misma función para obtener la orientación de un flujo.</p>
<p>Si necesitas cambiar la orientación en mitad del vuelo, puedes hacerlo con <code>freopen()</code>.</p>
<p></p>
<h3 data-number="27.9.2" id="funciones-de-es"><span class="header-section-number">27.9.2</span> Funciones de E/S</h3>
<p>Típicamente incluye <code>&lt;stdio.h&gt;</code> y <code>&lt;wchar.h&gt;</code> para estas.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>I/O Función</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>wprintf()</code></td>
<td>Salida de consola formateada.</td>
</tr>
<tr class="even">
<td><code>wscanf()</code></td>
<td>Entrada de consola formateada.</td>
</tr>
<tr class="odd">
<td><code>getwchar()</code></td>
<td>Entrada de consola basada en caracteres.</td>
</tr>
<tr class="even">
<td><code>putwchar()</code></td>
<td>Salida de consola basada en caracteres.</td>
</tr>
<tr class="odd">
<td><code>fwprintf()</code></td>
<td>Salida de archivos formateados.</td>
</tr>
<tr class="even">
<td><code>fwscanf()</code></td>
<td>Entrada de archivos formateados.</td>
</tr>
<tr class="odd">
<td><code>fgetwc()</code></td>
<td>Entrada de archivos basada en caracteres.</td>
</tr>
<tr class="even">
<td><code>fputwc()</code></td>
<td>Salida de archivos basada en caracteres.</td>
</tr>
<tr class="odd">
<td><code>fgetws()</code></td>
<td>Entrada de archivos basada en cadenas.</td>
</tr>
<tr class="even">
<td><code>fputws()</code></td>
<td>Salida de archivos basada en cadenas.</td>
</tr>
<tr class="odd">
<td><code>swprintf()</code></td>
<td>Cadena formateada output.</td>
</tr>
<tr class="even">
<td><code>swscanf()</code></td>
<td>Cadena formateada input.</td>
</tr>
<tr class="odd">
<td><code>vfwprintf()</code></td>
<td>Salida de archivo con formato variable.</td>
</tr>
<tr class="even">
<td><code>vfwscanf()</code></td>
<td>Archivo con formato variadic entrada.</td>
</tr>
<tr class="odd">
<td><code>vswprintf()</code></td>
<td>Salida de cadena con formato variable.</td>
</tr>
<tr class="even">
<td><code>vswscanf()</code></td>
<td>Entrada de cadena con formato variable.</td>
</tr>
<tr class="odd">
<td><code>vwprintf()</code></td>
<td>Salida de consola con formato variable.</td>
</tr>
<tr class="even">
<td><code>vwscanf()</code></td>
<td>Entrada de consola con formato variable.</td>
</tr>
<tr class="odd">
<td><code>ungetwc()</code></td>
<td>Empuja un carácter ancho hacia atrás en un flujo de salida.</td>
</tr>
<tr class="even">
<td><code>fwide()</code></td>
<td>Obtener o establecer la orientación multibyte/ancha del flujo.</td>
</tr>
</tbody>
</table>
<h3 data-number="27.9.3" id="funciones-de-conversión-de-tipos"><span class="header-section-number">27.9.3</span> Funciones de conversión de tipos</h3>
<p>Típicamente incluye <code>&lt;wchar.h&gt;</code> para esto.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Función de conversión</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>wcstod()</code></td>
<td>Convierte cadena(String) a <code>doble</code>.</td>
</tr>
<tr class="even">
<td><code>wcstof()</code></td>
<td>Convierte cadena a <code>float</code>.</td>
</tr>
<tr class="odd">
<td><code>wcstold()</code></td>
<td>Convierte cadena a <code>long double</code>.</td>
</tr>
<tr class="even">
<td><code>wcstol()</code></td>
<td>Convierte cadena a <code>long</code>.</td>
</tr>
<tr class="odd">
<td><code>wcstoll()</code></td>
<td>Convierte cadena a <code>long long</code>.</td>
</tr>
<tr class="even">
<td><code>wcstoul()</code></td>
<td>Convierte cadena a <code>unsigned long</code>.</td>
</tr>
<tr class="odd">
<td><code>wcstoull()</code></td>
<td>Convierte cadena a <code>unsigned long long</code>.</td>
</tr>
</tbody>
</table>
<h3 data-number="27.9.4" id="funciones-de-copia-de-cadenas-y-memoria"><span class="header-section-number">27.9.4</span> Funciones de copia de cadenas y memoria</h3>
<p>Típicamente incluye <code>&lt;wchar.h&gt;</code> para estas.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Función de copia</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>wcscpy()</code></td>
<td>Copiar cadena.</td>
</tr>
<tr class="even">
<td><code>wcsncpy()</code></td>
<td>Cadena de copia, de longitud limitada.</td>
</tr>
<tr class="odd">
<td><code>wmemcpy()</code></td>
<td>Copiar memoria.</td>
</tr>
<tr class="even">
<td><code>wmemmove()</code></td>
<td>Copia la memoria potencialmente solapada.</td>
</tr>
<tr class="odd">
<td><code>wcscat()</code></td>
<td>Concatenar cadenas.</td>
</tr>
<tr class="even">
<td><code>wcsncat()</code></td>
<td>Concatenar cadenas, longitud limitada.</td>
</tr>
</tbody>
</table>
<h3 data-number="27.9.5" id="funciones-de-comparación-de-cadenas-y-memoria"><span class="header-section-number">27.9.5</span> Funciones de comparación de cadenas y memoria</h3>
<p>Típicamente incluye <code>&lt;wchar.h&gt;</code> para estas.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>Función de comparación</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>wcscmp()</code></td>
<td>Compara cadenas lexicográficamente.</td>
</tr>
<tr class="even">
<td><code>wcsncmp()</code></td>
<td>Compara cadenas lexicográficamente, con límite de longitud.</td>
</tr>
<tr class="odd">
<td><code>wcscoll()</code></td>
<td>Compara cadenas en orden de diccionario por configuración regional.</td>
</tr>
<tr class="even">
<td><code>wmemcmp()</code></td>
<td>Compara la memoria lexicográficamente.</td>
</tr>
<tr class="odd">
<td><code>wcsxfrm()</code></td>
<td>Transforma cadenas en versiones tales que <code>wcscmp()</code> se comporta como <code>wcscoll()</code><a href="#fn165" class="footnote-ref" id="fnref165" role="doc-noteref"><sup>165</sup></a>.</td>
</tr>
</tbody>
</table>
<h3 data-number="27.9.6" id="funciones-de-búsqueda-de-cadenas"><span class="header-section-number">27.9.6</span> Funciones de búsqueda de cadenas</h3>
<p>Típicamente incluye <code>&lt;wchar.h&gt;</code> para estas.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Función de búsqueda</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>wcschr()</code></td>
<td>Find a character in a string.</td>
</tr>
<tr class="even">
<td><code>wcsrchr()</code></td>
<td>Find a character in a string from the back.</td>
</tr>
<tr class="odd">
<td><code>wmemchr()</code></td>
<td>Find a character in memory.</td>
</tr>
<tr class="even">
<td><code>wcsstr()</code></td>
<td>Find a substring in a string.</td>
</tr>
<tr class="odd">
<td><code>wcspbrk()</code></td>
<td>Find any of a set of characters in a string.</td>
</tr>
<tr class="even">
<td><code>wcsspn()</code></td>
<td>Find length of substring including any of a set of characters.</td>
</tr>
<tr class="odd">
<td><code>wcscspn()</code></td>
<td>Find length of substring before any of a set of characters.</td>
</tr>
<tr class="even">
<td><code>wcstok()</code></td>
<td>Find tokens in a string.</td>
</tr>
</tbody>
</table>
<h3 data-number="27.9.7" id="longitudfunciones-varias"><span class="header-section-number">27.9.7</span> Longitud/Funciones varias</h3>
<p>Typically include <code>&lt;wchar.h&gt;</code> for these.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Length/Misc Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>wcslen()</code></td>
<td>Return the length of the string.</td>
</tr>
<tr class="even">
<td><code>wmemset()</code></td>
<td>Set characters in memory.</td>
</tr>
<tr class="odd">
<td><code>wcsftime()</code></td>
<td>Formatted date and time output.</td>
</tr>
</tbody>
</table>
<h3 data-number="27.9.8" id="funciones-de-clasificación-de-caracteres"><span class="header-section-number">27.9.8</span> Funciones de clasificación de caracteres</h3>
<p>Include <code>&lt;wctype.h&gt;</code> for these.</p>
<p> </p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Length/Misc Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>iswalnum()</code></td>
<td>True if the character is alphanumeric.</td>
</tr>
<tr class="even">
<td><code>iswalpha()</code></td>
<td>True if the character is alphabetic.</td>
</tr>
<tr class="odd">
<td><code>iswblank()</code></td>
<td>True if the character is blank (space-ish, but not a newline).</td>
</tr>
<tr class="even">
<td><code>iswcntrl()</code></td>
<td>True if the character is a control character.</td>
</tr>
<tr class="odd">
<td><code>iswdigit()</code></td>
<td>True if the character is a digit.</td>
</tr>
<tr class="even">
<td><code>iswgraph()</code></td>
<td>True if the character is printable (except space).</td>
</tr>
<tr class="odd">
<td><code>iswlower()</code></td>
<td>True if the character is lowercase.</td>
</tr>
<tr class="even">
<td><code>iswprint()</code></td>
<td>True if the character is printable (including space).</td>
</tr>
<tr class="odd">
<td><code>iswpunct()</code></td>
<td>True if the character is punctuation.</td>
</tr>
<tr class="even">
<td><code>iswspace()</code></td>
<td>True if the character is whitespace.</td>
</tr>
<tr class="odd">
<td><code>iswupper()</code></td>
<td>True if the character is uppercase.</td>
</tr>
<tr class="even">
<td><code>iswxdigit()</code></td>
<td>True if the character is a hex digit.</td>
</tr>
<tr class="odd">
<td><code>towlower()</code></td>
<td>Convert character to lowercase.</td>
</tr>
<tr class="even">
<td><code>towupper()</code></td>
<td>Convert character to uppercase.</td>
</tr>
</tbody>
</table>
<h2 data-number="27.10" id="estado-de-análisis-funciones-reiniciables"><span class="header-section-number">27.10</span> Estado de análisis, funciones reiniciables</h2>
<p></p>
<p>Vamos a entrar un poco en las tripas de la conversión multibyte, pero esto es algo bueno de entender, conceptualmente.</p>
<p>Imagina cómo tu programa toma una secuencia de caracteres multibyte y los convierte en caracteres anchos, o viceversa. Puede que, en algún momento, esté a medio camino de analizar un carácter, o puede que tenga que esperar más bytes antes de determinar el valor final.</p>
<p>Este estado de análisis se almacena en una variable opaca de tipo <code>mbstate_t</code> y se utiliza cada vez que se realiza la conversión. Así es como las funciones de conversión llevan la cuenta de dónde se encuentran a mitad de trabajo. Y si cambias a una secuencia de caracteres diferente a mitad del proceso, o intentas buscar un lugar diferente en tu secuencia de entrada, podría confundirse.</p>
<p>Puede que quieras llamarme la atención sobre esto: acabamos de hacer algunas conversiones, arriba, y nunca mencioné ningún <code>mbstate_t</code> en ningún sitio.</p>
<p>Eso es porque las funciones de conversión como <code>mbstowcs()</code>, <code>wctomb()</code>, etc. tienen cada una su propia variable <code>mbstate_t</code> que usan. Sólo hay una por función, así que si estás escribiendo código multihilo, no es seguro usarlas.</p>
<p>Afortunadamente, C define versiones <em>restartable</em> de estas funciones donde puedes pasar tu propio <code>mbstate_t</code> por hilo si lo necesitas. Si estás haciendo cosas multihilo, ¡úsalas!</p>
<p>Nota rápida sobre la inicialización de una variable <code>mbstate_t</code>: simplemente <code>memset()</code> a cero. No hay ninguna función integrada para forzar su inicialización.</p>
<div class="sourceCode" id="cb562"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb562-1"><a href="#cb562-1" aria-hidden="true" tabindex="-1"></a>mbstate_t mbs<span class="op">;</span></span>
<span id="cb562-2"><a href="#cb562-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb562-3"><a href="#cb562-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Establecer el estado inicial</span></span>
<span id="cb562-4"><a href="#cb562-4" aria-hidden="true" tabindex="-1"></a>memset<span class="op">(&amp;</span>mbs<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span> mbs<span class="op">);</span></span></code></pre></div>
<p>Esta es una lista de las funciones de conversión reiniciables: tenga en cuenta la convención de nomenclatura de poner una “<code>r</code>” después del tipo “from”:</p>
<ul>
<li>mbrtowc()`—carácter multibyte a carácter ancho</li>
<li><code>wcrtomb()</code>–carácter ancho a multibyte</li>
<li><code>mbsrtowcs()</code>—cadena multibyte a cadena de caracteres anchos</li>
<li><code>wcsrtombs()</code>—cadena de caracteres anchos a cadena multibyte</li>
</ul>
<p>Son muy similares a sus equivalentes no reiniciables, salvo que requieren que pases un puntero a tu propia variable <code>mbstate_t</code>. Y también modifican el puntero de la cadena fuente (para ayudarte si se encuentran bytes inválidos), por lo que puede ser útil guardar una copia del original.</p>
<p>Aquí está el ejemplo de antes en el capítulo reelaborado para pasar nuestro propio <code>mbstate_t</code>.</p>
<div class="sourceCode" id="cb563"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb563-1"><a href="#cb563-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb563-2"><a href="#cb563-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb563-3"><a href="#cb563-3"></a><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span></span>
<span id="cb563-4"><a href="#cb563-4"></a><span class="pp">#include </span><span class="im">&lt;wchar.h&gt;</span></span>
<span id="cb563-5"><a href="#cb563-5"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb563-6"><a href="#cb563-6"></a><span class="pp">#include </span><span class="im">&lt;locale.h&gt;</span></span>
<span id="cb563-7"><a href="#cb563-7"></a></span>
<span id="cb563-8"><a href="#cb563-8"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb563-9"><a href="#cb563-9"></a><span class="op">{</span></span>
<span id="cb563-10"><a href="#cb563-10"></a>    <span class="co">// Salir de la configuración regional C a una que probablemente tenga el símbolo del euro</span></span>
<span id="cb563-11"><a href="#cb563-11"></a>    setlocale<span class="op">(</span>LC_ALL<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb563-12"><a href="#cb563-12"></a></span>
<span id="cb563-13"><a href="#cb563-13"></a>    <span class="co">// Cadena multibyte original con el símbolo del euro (punto 20ac de Unicode)</span></span>
<span id="cb563-14"><a href="#cb563-14"></a>    <span class="dt">char</span> <span class="op">*</span>mb_string <span class="op">=</span> <span class="st">&quot;The cost is </span><span class="sc">\u20ac</span><span class="st">1.23&quot;</span><span class="op">;</span>  <span class="co">// €1.23</span></span>
<span id="cb563-15"><a href="#cb563-15"></a>    <span class="dt">size_t</span> mb_len <span class="op">=</span> strlen<span class="op">(</span>mb_string<span class="op">);</span></span>
<span id="cb563-16"><a href="#cb563-16"></a></span>
<span id="cb563-17"><a href="#cb563-17"></a>    <span class="co">// Matriz de caracteres anchos que contendrá la cadena convertida</span></span>
<span id="cb563-18"><a href="#cb563-18"></a>    <span class="dt">wchar_t</span> wc_string<span class="op">[</span><span class="dv">128</span><span class="op">];</span>  <span class="co">// Contiene hasta 128 caracteres de ancho</span></span>
<span id="cb563-19"><a href="#cb563-19"></a></span>
<span id="cb563-20"><a href="#cb563-20"></a>    <span class="co">// Configurar el estado de conversión</span></span>
<span id="cb563-21"><a href="#cb563-21"></a>    mbstate_t mbs<span class="op">;</span></span>
<span id="cb563-22"><a href="#cb563-22"></a>    memset<span class="op">(&amp;</span>mbs<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span> mbs<span class="op">);</span>  <span class="co">// Estado inicial</span></span>
<span id="cb563-23"><a href="#cb563-23"></a></span>
<span id="cb563-24"><a href="#cb563-24"></a>    <span class="co">// mbsrtowcs() modifica el puntero de entrada para que apunte al primer</span></span>
<span id="cb563-25"><a href="#cb563-25"></a>    <span class="co">// carácter inválido, o NULL si tiene éxito. Hagamos una copia de</span></span>
<span id="cb563-26"><a href="#cb563-26"></a>    <span class="co">// del puntero para que mbsrtowcs() se meta con él, así nuestro original queda</span></span>
<span id="cb563-27"><a href="#cb563-27"></a>    <span class="co">// sin cambios.</span></span>
<span id="cb563-28"><a href="#cb563-28"></a>    <span class="co">//</span></span>
<span id="cb563-29"><a href="#cb563-29"></a>    <span class="co">// Este ejemplo probablemente sea exitoso, pero chequeamos mas adelante</span></span>
<span id="cb563-30"><a href="#cb563-30"></a>    <span class="co">// abajo para ver.</span></span>
<span id="cb563-31"><a href="#cb563-31"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>invalid <span class="op">=</span> mb_string<span class="op">;</span></span>
<span id="cb563-32"><a href="#cb563-32"></a></span>
<span id="cb563-33"><a href="#cb563-33"></a>    <span class="co">// Convierte la cadena MB a WC; esto devuelve el número de caracteres anchos</span></span>
<span id="cb563-34"><a href="#cb563-34"></a>    <span class="dt">size_t</span> wc_len <span class="op">=</span> mbsrtowcs<span class="op">(</span>wc_string<span class="op">,</span> <span class="op">&amp;</span>invalid<span class="op">,</span> <span class="dv">128</span><span class="op">,</span> <span class="op">&amp;</span>mbs<span class="op">);</span></span>
<span id="cb563-35"><a href="#cb563-35"></a></span>
<span id="cb563-36"><a href="#cb563-36"></a>    <span class="cf">if</span> <span class="op">(</span>invalid <span class="op">==</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb563-37"><a href="#cb563-37"></a>        printf<span class="op">(</span><span class="st">&quot;No invalid characters found</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb563-38"><a href="#cb563-38"></a></span>
<span id="cb563-39"><a href="#cb563-39"></a>        <span class="co">// Imprime el resultado - nota las %ls para cadenas de caracteres anchos</span></span>
<span id="cb563-40"><a href="#cb563-40"></a>        printf<span class="op">(</span><span class="st">&quot;multibyte: </span><span class="sc">\&quot;%s\&quot;</span><span class="st"> (</span><span class="sc">%zu</span><span class="st"> bytes)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> mb_string<span class="op">,</span> mb_len<span class="op">);</span></span>
<span id="cb563-41"><a href="#cb563-41"></a>        printf<span class="op">(</span><span class="st">&quot;wide char: </span><span class="sc">\&quot;%ls\&quot;</span><span class="st"> (</span><span class="sc">%zu</span><span class="st"> characters)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> wc_string<span class="op">,</span> wc_len<span class="op">);</span></span>
<span id="cb563-42"><a href="#cb563-42"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb563-43"><a href="#cb563-43"></a>        <span class="dt">ptrdiff_t</span> offset <span class="op">=</span> invalid <span class="op">-</span> mb_string<span class="op">;</span></span>
<span id="cb563-44"><a href="#cb563-44"></a>        printf<span class="op">(</span><span class="st">&quot;Invalid character at offset </span><span class="sc">%td\n</span><span class="st">&quot;</span><span class="op">,</span> offset<span class="op">);</span></span>
<span id="cb563-45"><a href="#cb563-45"></a>    <span class="op">}</span></span>
<span id="cb563-46"><a href="#cb563-46"></a><span class="op">}</span></span></code></pre></div>
<p>Para las funciones de conversión que gestionan su propio estado, puedes restablecer su estado interno al inicial pasando <code>NULL</code> para sus argumentos <code>char*</code>, por ejemplo:</p>
<div class="sourceCode" id="cb564"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb564-1"><a href="#cb564-1" aria-hidden="true" tabindex="-1"></a>mbstowcs<span class="op">(</span>NULL<span class="op">,</span> NULL<span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// Restablecer el estado de análisis para mbstowcs()</span></span>
<span id="cb564-2"><a href="#cb564-2" aria-hidden="true" tabindex="-1"></a>mbstowcs<span class="op">(</span>dest<span class="op">,</span> src<span class="op">,</span> <span class="dv">100</span><span class="op">);</span> <span class="co">// Analiza algunas cosas</span></span></code></pre></div>
<p>Para la E/S, cada flujo ancho gestiona su propio <code>mbstate_t</code> y lo utiliza para las conversiones de entrada y salida sobre la marcha.</p>
<p>Y algunas de las funciones de E/S orientadas a bytes como <code>printf()</code> y <code>scanf()</code> mantienen su propio estado interno mientras hacen su trabajo.</p>
<p>Finalmente, estas funciones de conversión reiniciables tienen su propio estado interno si pasas <code>NULL</code> por el parámetro <code>mbstate_t</code>. Esto hace que se comporten más como sus homólogas no reiniciables.</p>
<p> </p>
<h2 data-number="27.11" id="codificaciones-unicode-y-c"><span class="header-section-number">27.11</span> Codificaciones Unicode y C</h2>
<p>In this section, we’ll see what C can (and can’t) do when it comes to three specific Unicode encodings: UTF-8, UTF-16, and UTF-32.</p>
<h3 data-number="27.11.1" id="utf-8"><span class="header-section-number">27.11.1</span> UTF-8</h3>
<p></p>
<p>To refresh before this section, read the <a href="#utf8-quick">UTF-8 quick note, above</a>.</p>
<p>Aside from that, what are C’s UTF-8 capabilities?</p>
<p>Well, not much, unfortunately.</p>
<p></p>
<p>You can tell C that you specifically want a string literal to be UTF-8 encoded, and it’ll do it for you. You can prefix a string with <code>u8</code>:</p>
<div class="sourceCode" id="cb565"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb565-1"><a href="#cb565-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">u8&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb565-2"><a href="#cb565-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb565-3"><a href="#cb565-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span>   <span class="co">// Hello, world!--if you can output UTF-8</span></span></code></pre></div>
<p>Now, can you put Unicode characters in there?</p>
<div class="sourceCode" id="cb566"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb566-1"><a href="#cb566-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">u8&quot;€123&quot;</span><span class="op">;</span></span></code></pre></div>
<p></p>
<p>Sure! If the extended source character set supports it. (gcc does.)</p>
<p>What if it doesn’t? You can specify a Unicode code point with your friendly neighborhood <code>\u</code> and <code>\U</code>, <a href="#unicode-in-c">as noted above</a>.</p>
<p>But that’s about it. There’s no portable way in the standard library to take arbirary input and turn it into UTF-8 unless your locale is UTF-8. Or to parse UTF-8 unless your locale is UTF-8.</p>
<p>So if you want to do it, either be in a UTF-8 locale and:</p>
<p></p>
<div class="sourceCode" id="cb567"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb567-1"><a href="#cb567-1" aria-hidden="true" tabindex="-1"></a>setlocale<span class="op">(</span>LC_ALL<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span></code></pre></div>
<p>or figure out a UTF-8 locale name on your local machine and set it explicitly like so:</p>
<div class="sourceCode" id="cb568"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb568-1"><a href="#cb568-1" aria-hidden="true" tabindex="-1"></a>setlocale<span class="op">(</span>LC_ALL<span class="op">,</span> <span class="st">&quot;en_US.UTF-8&quot;</span><span class="op">);</span>  <span class="co">// Non-portable name</span></span></code></pre></div>
<p></p>
<p>Or use a <a href="#utf-3rd-party">third-party library</a>.</p>
<p></p>
<h3 data-number="27.11.2" id="utf-16-utf-32-char16_t-y-char32_t"><span class="header-section-number">27.11.2</span> UTF-16, UTF-32, <code>char16_t</code>, y <code>char32_t</code></h3>
<p> </p>
<p><code>char16_t</code> and <code>char32_t</code> are a couple other potentially wide character types with sizes of 16 bits and 32 bits, respectively. Not necessarily wide, because if they can’t represent every character in the current locale, they lose their wide character nature. But the spec refers them as “wide character” types all over the place, so there we are.</p>
<p>These are here to make things a little more Unicode-friendly, potentially.</p>
<p>To use, include <code>&lt;uchar.h&gt;</code>. (That’s “u”, not “w”.)</p>
<p>This header file doesn’t exist on OS X—bummer. If you just want the types, you can:</p>
<div class="sourceCode" id="cb569"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb569-1"><a href="#cb569-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb569-2"><a href="#cb569-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb569-3"><a href="#cb569-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int_least16_t</span> <span class="dt">char16_t</span><span class="op">;</span></span>
<span id="cb569-4"><a href="#cb569-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int_least32_t</span> <span class="dt">char32_t</span><span class="op">;</span></span></code></pre></div>
<p>But if you also want the functions, that’s all on you.</p>
<p> </p>
<p>Assuming you’re still good to go, you can declare a string or character of these types with the <code>u</code> and <code>U</code> prefixes:</p>
<div class="sourceCode" id="cb570"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb570-1"><a href="#cb570-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char16_t</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">u&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb570-2"><a href="#cb570-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char16_t</span> c <span class="op">=</span> <span class="ch">u&#39;B&#39;</span><span class="op">;</span></span>
<span id="cb570-3"><a href="#cb570-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb570-4"><a href="#cb570-4" aria-hidden="true" tabindex="-1"></a><span class="dt">char32_t</span> <span class="op">*</span>t <span class="op">=</span> <span class="st">U&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb570-5"><a href="#cb570-5" aria-hidden="true" tabindex="-1"></a><span class="dt">char32_t</span> d <span class="op">=</span> <span class="ch">U&#39;B&#39;</span><span class="op">;</span></span></code></pre></div>
<p> </p>
<p>Now—are values in these stored in UTF-16 or UTF-32? Depends on the implementation.</p>
<p>But you can test to see if they are. If the macros <code>__STDC_UTF_16__</code> or <code>__STDC_UTF_32__</code> are defined (to <code>1</code>) it means the types hold UTF-16 or UTF-32, respectively.</p>
<p>If you’re curious, and I know you are, the values, if UTF-16 or UTF-32, are stored in the native endianess. That is, you should be able to compare them straight up to Unicode code point values:</p>
<div class="sourceCode" id="cb571"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb571-1"><a href="#cb571-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char16_t</span> pi <span class="op">=</span> <span class="st">u&quot;</span><span class="sc">\u03C0</span><span class="st">&quot;</span><span class="op">;</span>  <span class="co">// pi symbol</span></span>
<span id="cb571-2"><a href="#cb571-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb571-3"><a href="#cb571-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#if __STDC_UTF_16__</span></span>
<span id="cb571-4"><a href="#cb571-4" aria-hidden="true" tabindex="-1"></a>pi <span class="op">==</span> <span class="bn">0x3C0</span><span class="op">;</span>  <span class="co">// Always true</span></span>
<span id="cb571-5"><a href="#cb571-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb571-6"><a href="#cb571-6" aria-hidden="true" tabindex="-1"></a>pi <span class="op">==</span> <span class="bn">0x3C0</span><span class="op">;</span>  <span class="co">// Probably not true</span></span>
<span id="cb571-7"><a href="#cb571-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p> </p>
<h3 data-number="27.11.3" id="conversiones-multibyte"><span class="header-section-number">27.11.3</span> Conversiones multibyte</h3>
<p>You can convert from your multibyte encoding to <code>char16_t</code> or <code>char32_t</code> with a number of helper functions.</p>
<p>(Like I said, though, the result might not be UTF-16 or UTF-32 unless the corresponding macro is set to <code>1</code>.)</p>
<p>All of these functions are restartable (i.e. you pass in your own <code>mbstate_t</code>), and all of them operate character by character<a href="#fn166" class="footnote-ref" id="fnref166" role="doc-noteref"><sup>166</sup></a>.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Conversion Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mbrtoc16()</code></td>
<td>Convert a multibyte character to a <code>char16_t</code> character.</td>
</tr>
<tr class="even">
<td><code>mbrtoc32()</code></td>
<td>Convert a multibyte character to a <code>char32_t</code> character.</td>
</tr>
<tr class="odd">
<td><code>c16rtomb()</code></td>
<td>Convert a <code>char16_t</code> character to a multibyte character.</td>
</tr>
<tr class="even">
<td><code>c32rtomb()</code></td>
<td>Convert a <code>char32_t</code> character to a multibyte character.</td>
</tr>
</tbody>
</table>
<h3 data-number="27.11.4" id="utf-3rd-party"><span class="header-section-number">27.11.4</span> Bibliotecas de terceros</h3>
<p>For heavy-duty conversion between different specific encodings, there are a couple mature libraries worth checking out. Note that I haven’t used either of these.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Iconv">iconv</a><a href="#fn167" class="footnote-ref" id="fnref167" role="doc-noteref"><sup>167</sup></a>—Internationalization Conversion, a common POSIX-standard API available on the major platforms.</li>
<li><a href="http://site.icu-project.org/">ICU</a><a href="#fn168" class="footnote-ref" id="fnref168" role="doc-noteref"><sup>168</sup></a>—International Components for Unicode. At least one blogger found this easy to use.</li>
</ul>
<p>If you have more noteworthy libraries, let me know.</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="28" id="salir-de-un-programa"><span class="header-section-number">28</span> Salir de un programa</h1>
<p></p>
<p>Resulta que hay un montón de maneras de hacer esto, e incluso maneras de configurar “ganchos” para que una función se ejecute cuando un programa salga.</p>
<p>En este capítulo nos sumergiremos en ellas y las comprobaremos.</p>
<p>Ya hemos cubierto el significado del código de estado de salida en la sección <a href="#exit-status">Exit Status</a>, así que vuelve allí y repásalo si es necesario.</p>
<p>Todas las funciones de esta sección están en <code>&lt;stdlib.h&gt;</code>.</p>
<h2 data-number="28.1" id="salidas-normales"><span class="header-section-number">28.1</span> Salidas normales</h2>
<p>Empezaremos con las formas normales de salir de un programa, y luego saltaremos a algunas de las más raras y esotéricas.</p>
<p>Cuando se sale de un programa normalmente, todos los flujos de E/S abiertos se vacían y los archivos temporales se eliminan. Básicamente es una salida agradable donde todo se limpia y se maneja. Es lo que quieres hacer casi todo el tiempo a menos que tengas razones para hacer lo contrario.</p>
<h3 data-number="28.1.1" id="retorno-de-main"><span class="header-section-number">28.1.1</span> Retorno de <code>main()</code></h3>
<p></p>
<p>Si te has dado cuenta, <code>main()</code> tiene un tipo de retorno <code>int</code>… y sin embargo rara vez, o nunca, he estado <code>devolviendo</code> nada de <code>main()</code> en absoluto.</p>
<p>Esto se debe a que <code>main()</code> sólo (y no puedo enfatizar lo suficiente este caso especial <em>sólo</em> se aplica a <code>main()</code> y a ninguna otra función en ninguna parte) tiene un <code>return 0</code> <em>implícito</em> si te caes del final.</p>
<p>Puedes <code>return</code> explícitamente desde <code>main()</code> cuando quieras, y algunos programadores creen que es más <em>Correcto</em> tener siempre un <code>return</code> al final de <code>main()</code>. Pero si lo dejas, C pondrá uno por ti.</p>
<p>Así que… aquí están las reglas de <code>return</code> para <code>main()</code>:</p>
<ul>
<li>Puede devolver un estado de salida desde <code>main()</code> con una sentencia <code>return</code>. <code>main()</code> es la única función con este comportamiento especial. Usar <code>return</code> en cualquier otra función sólo devuelve desde esa función a quien la llamó.</li>
<li>Si no se usa <code>return</code> explícitamente y se sale al final de <code>main()</code>, es como si se hubiera devuelto <code>0</code> o <code>EXIT_SUCCESS</code>. </li>
</ul>
<h3 data-number="28.1.2" id="exit"><span class="header-section-number">28.1.2</span> <code>exit()</code></h3>
<p></p>
<p>Éste también ha aparecido unas cuantas veces. Si llama a <code>exit()</code> desde cualquier parte de su programa, éste saldrá en ese punto.</p>
<p>El argumento que pasas a <code>exit()</code> es el estado de salida.</p>
<h3 data-number="28.1.3" id="configuración-de-los-controladores-de-salida-con-atexit"><span class="header-section-number">28.1.3</span> Configuración de los controladores de salida con <code>atexit()</code></h3>
<p></p>
<p>Puede registrar funciones para ser llamadas cuando un programa sale, ya sea volviendo de <code>main()</code> o llamando a la función <code>exit()</code>.</p>
<p>Una llamada a <code>atexit()</code> con el nombre de la función manejadora lo hará. Puede registrar múltiples manejadores de salida, y serán llamados en el orden inverso al registro.</p>
<p>He aquí un ejemplo:</p>
<div class="sourceCode" id="cb572"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb572-1"><a href="#cb572-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb572-2"><a href="#cb572-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb572-3"><a href="#cb572-3"></a></span>
<span id="cb572-4"><a href="#cb572-4"></a><span class="dt">void</span> on_exit_1<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb572-5"><a href="#cb572-5"></a><span class="op">{</span></span>
<span id="cb572-6"><a href="#cb572-6"></a>    printf<span class="op">(</span><span class="st">&quot;¡Controlador de salida 1 llamado!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb572-7"><a href="#cb572-7"></a><span class="op">}</span></span>
<span id="cb572-8"><a href="#cb572-8"></a></span>
<span id="cb572-9"><a href="#cb572-9"></a><span class="dt">void</span> on_exit_2<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb572-10"><a href="#cb572-10"></a><span class="op">{</span></span>
<span id="cb572-11"><a href="#cb572-11"></a>    printf<span class="op">(</span><span class="st">&quot;¡Controlador de salida 2 llamado!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb572-12"><a href="#cb572-12"></a><span class="op">}</span></span>
<span id="cb572-13"><a href="#cb572-13"></a></span>
<span id="cb572-14"><a href="#cb572-14"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb572-15"><a href="#cb572-15"></a><span class="op">{</span></span>
<span id="cb572-16"><a href="#cb572-16"></a>    atexit<span class="op">(</span>on_exit_1<span class="op">);</span></span>
<span id="cb572-17"><a href="#cb572-17"></a>    atexit<span class="op">(</span>on_exit_2<span class="op">);</span></span>
<span id="cb572-18"><a href="#cb572-18"></a>    </span>
<span id="cb572-19"><a href="#cb572-19"></a>    printf<span class="op">(</span><span class="st">&quot;A punto de salir...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb572-20"><a href="#cb572-20"></a><span class="op">}</span></span></code></pre></div>
<p>Y la salida es:</p>
<div class="sourceCode" id="cb573"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb573-1"><a href="#cb573-1" aria-hidden="true" tabindex="-1"></a>A punto de salir...</span>
<span id="cb573-2"><a href="#cb573-2" aria-hidden="true" tabindex="-1"></a>¡Controlador de salida 2 llamado!</span>
<span id="cb573-3"><a href="#cb573-3" aria-hidden="true" tabindex="-1"></a>¡Controlador de salida 1 llamado!</span></code></pre></div>
<p></p>
<h2 data-number="28.2" id="salidas-más-rápidas-con-quick_exit."><span class="header-section-number">28.2</span> Salidas más rápidas con <code>quick_exit()</code>.</h2>
<p></p>
<p>Esto es similar a una salida normal, excepto:</p>
<ul>
<li>Los archivos abiertos pueden no ser vaciados.</li>
<li>Los ficheros temporales pueden no ser eliminados.</li>
<li>Los manejadores <code>atexit()</code> no serán llamados.</li>
</ul>
<p>Pero hay una forma de registrar manejadores de salida: llame a <code>at_quick_exit()</code> de forma análoga a como llamaría a <code>atexit()</code>.</p>
<div class="sourceCode" id="cb574"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb574-1"><a href="#cb574-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb574-2"><a href="#cb574-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb574-3"><a href="#cb574-3"></a></span>
<span id="cb574-4"><a href="#cb574-4"></a><span class="dt">void</span> on_quick_exit_1<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb574-5"><a href="#cb574-5"></a><span class="op">{</span></span>
<span id="cb574-6"><a href="#cb574-6"></a>    printf<span class="op">(</span><span class="st">&quot;Llamada al gestor de salida rápida 1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb574-7"><a href="#cb574-7"></a><span class="op">}</span></span>
<span id="cb574-8"><a href="#cb574-8"></a></span>
<span id="cb574-9"><a href="#cb574-9"></a><span class="dt">void</span> on_quick_exit_2<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb574-10"><a href="#cb574-10"></a><span class="op">{</span></span>
<span id="cb574-11"><a href="#cb574-11"></a>    printf<span class="op">(</span><span class="st">&quot;Llamada al gestor de salida rápida 2</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb574-12"><a href="#cb574-12"></a><span class="op">}</span></span>
<span id="cb574-13"><a href="#cb574-13"></a></span>
<span id="cb574-14"><a href="#cb574-14"></a><span class="dt">void</span> on_exit<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb574-15"><a href="#cb574-15"></a><span class="op">{</span></span>
<span id="cb574-16"><a href="#cb574-16"></a>    printf<span class="op">(</span><span class="st">&quot;Salida normal... ¡No me llamarán!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb574-17"><a href="#cb574-17"></a><span class="op">}</span></span>
<span id="cb574-18"><a href="#cb574-18"></a></span>
<span id="cb574-19"><a href="#cb574-19"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb574-20"><a href="#cb574-20"></a><span class="op">{</span></span>
<span id="cb574-21"><a href="#cb574-21"></a>    at_quick_exit<span class="op">(</span>on_quick_exit_1<span class="op">);</span></span>
<span id="cb574-22"><a href="#cb574-22"></a>    at_quick_exit<span class="op">(</span>on_quick_exit_2<span class="op">);</span></span>
<span id="cb574-23"><a href="#cb574-23"></a></span>
<span id="cb574-24"><a href="#cb574-24"></a>    atexit<span class="op">(</span>on_exit<span class="op">);</span>  <span class="co">// Esto no se llamará</span></span>
<span id="cb574-25"><a href="#cb574-25"></a></span>
<span id="cb574-26"><a href="#cb574-26"></a>    printf<span class="op">(</span><span class="st">&quot;A punto de salir rápidamente...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb574-27"><a href="#cb574-27"></a></span>
<span id="cb574-28"><a href="#cb574-28"></a>    quick_exit<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb574-29"><a href="#cb574-29"></a><span class="op">}</span></span></code></pre></div>
<p>Lo que da esta salida:</p>
<div class="sourceCode" id="cb575"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb575-1"><a href="#cb575-1" aria-hidden="true" tabindex="-1"></a>A punto de salir rápidamente...</span>
<span id="cb575-2"><a href="#cb575-2" aria-hidden="true" tabindex="-1"></a>Llamada al gestor de salida rápida 2</span>
<span id="cb575-3"><a href="#cb575-3" aria-hidden="true" tabindex="-1"></a>Llamada al gestor de salida rápida 1</span></code></pre></div>
<p>Funciona igual que <code>exit()</code>/<code>atexit()</code>, excepto por el hecho de que el vaciado y limpieza de ficheros puede no realizarse.</p>
<p></p>
<h2 data-number="28.3" id="destrúyelo-desde-la-órbita-_exit"><span class="header-section-number">28.3</span> Destrúyelo desde la órbita: <code>_Exit()</code></h2>
<p></p>
<p>Llamando a <code>_Exit()</code> se sale inmediatamente, punto. No se ejecutan funciones de callback al salir. Los ficheros no se vaciarán. Los ficheros temporales no se eliminan.</p>
<p>Use esto si tiene que salir <em>ahora mismo</em>.</p>
<h2 data-number="28.4" id="saliendo-a-veces-assert"><span class="header-section-number">28.4</span> Saliendo a veces: <code>assert()</code></h2>
<p>La sentencia <code>assert()</code> se utiliza para insistir en que algo sea cierto, o de lo contrario el programa se cerrará.</p>
<p>Los desarrolladores a menudo utilizan un assert para detectar errores del tipo “no debería ocurrir nunca”.</p>
<div class="sourceCode" id="cb576"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb576-1"><a href="#cb576-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define PI </span><span class="fl">3.14159</span></span>
<span id="cb576-2"><a href="#cb576-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb576-3"><a href="#cb576-3" aria-hidden="true" tabindex="-1"></a>assert<span class="op">(</span>PI <span class="op">&gt;</span> <span class="dv">3</span><span class="op">);</span>   <span class="co">// Claro que sí, así que continúa.</span></span></code></pre></div>
<p>versus:</p>
<div class="sourceCode" id="cb577"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb577-1"><a href="#cb577-1" aria-hidden="true" tabindex="-1"></a>goats <span class="op">-=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb577-2"><a href="#cb577-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb577-3"><a href="#cb577-3" aria-hidden="true" tabindex="-1"></a>assert<span class="op">(</span>goats <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// No puede tener cabras negativas</span></span></code></pre></div>
<p>En ese caso, si intento ejecutarlo y <code>goats</code> cae bajo <code>0</code>, ocurre esto:</p>
<div class="sourceCode" id="cb578"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb578-1"><a href="#cb578-1" aria-hidden="true" tabindex="-1"></a>goat_counter: goat_counter.c:8: main: Assertion `goats &gt;= 0&#39; failed.</span>
<span id="cb578-2"><a href="#cb578-2" aria-hidden="true" tabindex="-1"></a>Aborted</span></code></pre></div>
<p>y vuelvo a la línea de comandos.</p>
<p>Esto no es muy fácil de usar, así que sólo se usa para cosas que el usuario nunca verá. Y a menudo la gente <a href="#my-assert">escribe sus propias macros assert que pueden ser desactivadas más fácilmente</a>.</p>
<p></p>
<h2 data-number="28.5" id="salida-anormal-abort"><span class="header-section-number">28.5</span> Salida anormal: <code>abort()</code></h2>
<p></p>
<p>Puedes utilizarlo si algo ha ido terriblemente mal y quieres indicarlo al entorno exterior. Esto tampoco limpiará necesariamente cualquier archivo abierto, etc.</p>
<p>Raramente he visto usar esto.</p>
<p>Puedes utilizarlo si algo ha ido terriblemente mal y quieres indicarlo al entorno exterior. Esto tampoco limpiará necesariamente cualquier archivo abierto, etc.</p>
<p>Rara vez he visto que se utilice.</p>
<p>Un poco de anticipación sobre las <em>señales</em>: esto en realidad funciona lanzando una <code>SIGABRT</code> que terminará el proceso.</p>
<p>Lo que suceda después depende del sistema, pero en los Unix, era común <a href="https://en.wikipedia.org/wiki/Core_dump">dump core</a><a href="#fn169" class="footnote-ref" id="fnref169" role="doc-noteref"><sup>169</sup></a> cuando el programa terminaba. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="29" id="manejo-de-señales"><span class="header-section-number">29</span> Manejo de señales</h1>
<p></p>
<p>Antes de empezar, voy a aconsejarte que ignores todo este capítulo y utilices las (muy probablemente) superiores funciones de manejo de señales de tu sistema operativo. Los Unix tienen la función .</p>
<p>Una vez aclarado esto, ¿qué son las señales?</p>
<h2 data-number="29.1" id="qué-son-las-señales"><span class="header-section-number">29.1</span> ¿Qué son las señales?</h2>
<p>Una <em>señal</em> es <em>levantada</em> en una variedad de eventos externos. Su programa puede ser configurado para ser interrumpido para <em>manejar</em> la señal, y, opcionalmente, continuar donde lo dejó una vez que la señal ha sido manejada.</p>
<p>Piense en ello como una función que se llama automáticamente cuando se produce uno de estos eventos externos.</p>
<p>¿Cuáles son estos eventos? En tu sistema, probablemente haya muchos, pero en la especificación C sólo hay unos pocos:</p>
<p> </p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Signal</th>
<th>Descipción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SIGABRT</code></td>
<td>Terminación anormal—lo que ocurre cuando se llama a <code>abort()</code>.</td>
</tr>
<tr class="even">
<td><code>SIGFPE</code></td>
<td>Excepción de coma flotante.</td>
</tr>
<tr class="odd">
<td><code>SIGILL</code></td>
<td>Instrucción ilegal.</td>
</tr>
<tr class="even">
<td><code>SIGINT</code></td>
<td>Interrupción: normalmente el resultado de pulsar “CTRL-C”.</td>
</tr>
<tr class="odd">
<td><code>SIGSEGV</code></td>
<td>“Violación de segmentación”: acceso inválido a memoria.</td>
</tr>
<tr class="even">
<td><code>SIGTERM</code></td>
<td>Terminación solicitada.</td>
</tr>
</tbody>
</table>
<p>Puede configurar su programa para ignorar, manejar o permitir la acción por defecto para cada uno de ellos utilizando la función <code>signal()</code>.</p>
<h2 data-number="29.2" id="manejo-de-señales-con-signal."><span class="header-section-number">29.2</span> Manejo de señales con <code>signal()</code>.</h2>
<p></p>
<p>La llamada a <code>signal()</code> toma dos parámetros: la señal en cuestión, y una acción a tomar cuando esa señal es lanzada.</p>
<p>La acción puede ser una de estas tres cosas:</p>
<ul>
<li>Un puntero a una función manejadora.</li>
<li><code>SIG_IGN</code> para ignorar la señal.</li>
<li><code>SIG_DFL</code> para restaurar el manejador por defecto de la señal.</li>
</ul>
<p>Escribamos un programa del que no puedas salir con <code>CTRL-C</code>. (No te preocupes–en el siguiente programa, también puedes pulsar <code>RETURN</code> y saldrá).</p>
<p></p>
<div class="sourceCode" id="cb579"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb579-1"><a href="#cb579-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb579-2"><a href="#cb579-2"></a><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></span>
<span id="cb579-3"><a href="#cb579-3"></a></span>
<span id="cb579-4"><a href="#cb579-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb579-5"><a href="#cb579-5"></a><span class="op">{</span></span>
<span id="cb579-6"><a href="#cb579-6"></a>    <span class="dt">char</span> s<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb579-7"><a href="#cb579-7"></a></span>
<span id="cb579-8"><a href="#cb579-8"></a>    signal<span class="op">(</span>SIGINT<span class="op">,</span> SIG_IGN<span class="op">);</span>    <span class="co">// Ignorar SIGINT, causado por ^C</span></span>
<span id="cb579-9"><a href="#cb579-9"></a></span>
<span id="cb579-10"><a href="#cb579-10"></a>    printf<span class="op">(</span><span class="st">&quot;Prueba a pulsar ^C... (pulsa RETURN para salir)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb579-11"><a href="#cb579-11"></a></span>
<span id="cb579-12"><a href="#cb579-12"></a>    <span class="co">// Esperar una línea de entrada para que el programa no salga sin más</span></span>
<span id="cb579-13"><a href="#cb579-13"></a>    fgets<span class="op">(</span>s<span class="op">,</span> <span class="kw">sizeof</span> s<span class="op">,</span> stdin<span class="op">);</span></span>
<span id="cb579-14"><a href="#cb579-14"></a><span class="op">}</span></span></code></pre></div>
<p>Mira la línea 8: le decimos al programa que ignore “SIGINT”, la señal de interrupción que se activa cuando se pulsa “CTRL-C”. No importa cuánto la pulses, la señal permanece ignorada. Si comentas la línea 8, verás que puedes pulsar <code>CTRL-C</code> impunemente y salir del programa en el acto.</p>
<p> </p>
<h2 data-number="29.3" id="escribiendo-manejadores-de-señales"><span class="header-section-number">29.3</span> Escribiendo Manejadores de Señales</h2>
<p>He mencionado que también se puede escribir una función manejadora que se llama cuando la señal se eleva.</p>
<p>Estos son bastante sencillos, también son muy limitados en cuanto a la capacidad de la especificación. </p>
<p>Antes de empezar, veamos el prototipo de función para la llamada <code>signal()</code>:</p>
<div class="sourceCode" id="cb580"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb580-1"><a href="#cb580-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">(*</span>signal<span class="op">(</span><span class="dt">int</span> sig<span class="op">,</span> <span class="dt">void</span> <span class="op">(*</span>func<span class="op">)(</span><span class="dt">int</span><span class="op">)))(</span><span class="dt">int</span><span class="op">);</span></span></code></pre></div>
<p>Bastante fácil de leer, ¿verdad?</p>
<p>ERROR.</p>
<p>Vamos a desmenuzarlo un poco para practicar.</p>
<p><code>signal()</code> toma dos argumentos: un entero <code>sig</code> que representa la señal, y un puntero <code>func</code> al manejador (el manejador devuelve <code>void</code> y toma un <code>int</code> como argumento), resaltado abajo:</p>
<div class="sourceCode" id="cb581"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb581-1"><a href="#cb581-1" aria-hidden="true" tabindex="-1"></a>                sig          func</span>
<span id="cb581-2"><a href="#cb581-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">|-----|</span>  <span class="op">|---------------|</span></span>
<span id="cb581-3"><a href="#cb581-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">(*</span>signal<span class="op">(</span><span class="dt">int</span> sig<span class="op">,</span> <span class="dt">void</span> <span class="op">(*</span>func<span class="op">)(</span><span class="dt">int</span><span class="op">)))(</span><span class="dt">int</span><span class="op">);</span></span></code></pre></div>
<p></p>
<p>Básicamente, vamos a pasar en el número de señal que estamos interesados en la captura, y vamos a pasar un puntero a una función de la forma:</p>
<div class="sourceCode" id="cb582"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb582-1"><a href="#cb582-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">);</span></span></code></pre></div>
<p>que hará la captura real.</p>
<p>Ahora… ¿qué pasa con el resto del prototipo? Básicamente es todo el tipo de retorno. Verás, <code>signal()</code> devolverá lo que hayas pasado como <code>func</code> en caso de éxito… así que eso significa que devuelve un puntero a una función que devuelve <code>void</code> y toma un <code>int</code> como argumento.</p>
<div class="sourceCode" id="cb583"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb583-1"><a href="#cb583-1" aria-hidden="true" tabindex="-1"></a>returned</span>
<span id="cb583-2"><a href="#cb583-2" aria-hidden="true" tabindex="-1"></a>function    indicates we<span class="ch">&#39;r</span><span class="er">e              and</span></span>
<span id="cb583-3"><a href="#cb583-3" aria-hidden="true" tabindex="-1"></a>returns     returning a                  that function</span>
<span id="cb583-4"><a href="#cb583-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span>        pointer to function          takes an <span class="dt">int</span></span>
<span id="cb583-5"><a href="#cb583-5" aria-hidden="true" tabindex="-1"></a><span class="op">|--|</span>        <span class="op">|</span>                                   <span class="op">|---|</span></span>
<span id="cb583-6"><a href="#cb583-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span>       <span class="op">(*</span>signal<span class="op">(</span><span class="dt">int</span> sig<span class="op">,</span> <span class="dt">void</span> <span class="op">(*</span>func<span class="op">)(</span><span class="dt">int</span><span class="op">)))(</span><span class="dt">int</span><span class="op">);</span></span></code></pre></div>
<p>Además, puede devolver <code>SIG_ERR</code> en caso de error.</p>
<p>Hagamos un ejemplo donde tengamos que pulsar <code>CTRL-C</code> dos veces para salir.</p>
<p>Quiero dejar claro que este programa tiene un comportamiento indefinido en un par de formas. Pero probablemente te funcione, y es difícil hacer demos portables no triviales.</p>
<p> </p>
<div class="sourceCode" id="cb584"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb584-1"><a href="#cb584-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb584-2"><a href="#cb584-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb584-3"><a href="#cb584-3"></a><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></span>
<span id="cb584-4"><a href="#cb584-4"></a></span>
<span id="cb584-5"><a href="#cb584-5"></a><span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb584-6"><a href="#cb584-6"></a></span>
<span id="cb584-7"><a href="#cb584-7"></a><span class="dt">void</span> sigint_handler<span class="op">(</span><span class="dt">int</span> signum<span class="op">)</span></span>
<span id="cb584-8"><a href="#cb584-8"></a><span class="op">{</span></span>
<span id="cb584-9"><a href="#cb584-9"></a>    <span class="co">// El compilador puede funcionar:</span></span>
<span id="cb584-10"><a href="#cb584-10"></a>    <span class="co">//</span></span>
<span id="cb584-11"><a href="#cb584-11"></a>    <span class="co">// signal(signum, SIG_DFL)</span></span>
<span id="cb584-12"><a href="#cb584-12"></a>    <span class="co">//</span></span>
<span id="cb584-13"><a href="#cb584-13"></a>    <span class="co">// cuando el manejador es llamado. Así que aquí reiniciamos el manejador:</span></span>
<span id="cb584-14"><a href="#cb584-14"></a>    signal<span class="op">(</span>SIGINT<span class="op">,</span> sigint_handler<span class="op">);</span></span>
<span id="cb584-15"><a href="#cb584-15"></a></span>
<span id="cb584-16"><a href="#cb584-16"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>signum<span class="op">;</span>   <span class="co">// Deshacerse del aviso de variable no utilizada</span></span>
<span id="cb584-17"><a href="#cb584-17"></a>    count<span class="op">++;</span>                       <span class="co">// Comportamiento indefinido</span></span>
<span id="cb584-18"><a href="#cb584-18"></a>    printf<span class="op">(</span><span class="st">&quot;Count: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> count<span class="op">);</span>   <span class="co">// Comportamiento indefinido</span></span>
<span id="cb584-19"><a href="#cb584-19"></a>    <span class="cf">if</span> <span class="op">(</span>count <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb584-20"><a href="#cb584-20"></a>        printf<span class="op">(</span><span class="st">&quot;Exiting!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>       <span class="co">// Comportamiento indefinido</span></span>
<span id="cb584-21"><a href="#cb584-21"></a>        exit<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb584-22"><a href="#cb584-22"></a>    <span class="op">}</span></span>
<span id="cb584-23"><a href="#cb584-23"></a><span class="op">}</span></span>
<span id="cb584-24"><a href="#cb584-24"></a></span>
<span id="cb584-25"><a href="#cb584-25"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb584-26"><a href="#cb584-26"></a><span class="op">{</span></span>
<span id="cb584-27"><a href="#cb584-27"></a>    signal<span class="op">(</span>SIGINT<span class="op">,</span> sigint_handler<span class="op">);</span></span>
<span id="cb584-28"><a href="#cb584-28"></a></span>
<span id="cb584-29"><a href="#cb584-29"></a>    printf<span class="op">(</span><span class="st">&quot;Try hitting ^C...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb584-30"><a href="#cb584-30"></a></span>
<span id="cb584-31"><a href="#cb584-31"></a>    <span class="cf">for</span><span class="op">(;;);</span>  <span class="co">// Espera aquí para siempre</span></span>
<span id="cb584-32"><a href="#cb584-32"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Una de las cosas que notarás es que en la línea 14 reiniciamos el manejador de señales. Esto es porque C tiene la opción de resetear el manejador de señales a su <code>SIG_DFL</code> antes de ejecutar tu manejador personalizado. En otras palabras. Así que lo reseteamos a la primera para volver a manejarlo en la siguiente.</p>
<p>Estamos ignorando el valor de retorno de <code>signal()</code> en este caso. Si lo hubiéramos puesto antes en un manejador diferente, devolvería un puntero a ese manejador, que podríamos obtener así:</p>
<div class="sourceCode" id="cb585"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb585-1"><a href="#cb585-1" aria-hidden="true" tabindex="-1"></a><span class="co">// old_handler es del tipo &quot;puntero a función que toma un único parámetro</span></span>
<span id="cb585-2"><a href="#cb585-2" aria-hidden="true" tabindex="-1"></a><span class="co">// parámetro int y devuelve void&quot;:</span></span>
<span id="cb585-3"><a href="#cb585-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-4"><a href="#cb585-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">(*</span>old_handler<span class="op">)(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb585-5"><a href="#cb585-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-6"><a href="#cb585-6" aria-hidden="true" tabindex="-1"></a>old_handler <span class="op">=</span> signal<span class="op">(</span>SIGINT<span class="op">,</span> sigint_handler<span class="op">);</span></span></code></pre></div>
<p></p>
<p>Dicho esto, no estoy seguro de que haya un caso de uso común para esto. Pero si necesitas el antiguo manejador por alguna razón, puedes conseguirlo de esa manera.</p>
<p>Nota rápida sobre la línea 16—es sólo para decirle al compilador que no advierta que no estamos usando esta variable. Es como decir, “Sé que no la estoy usando; no tienes que advertirme”.</p>
<p>Y por último verás que he marcado comportamiento indefinido en un par de sitios. Más sobre esto en la siguiente sección.</p>
<h2 data-number="29.4" id="qué-podemos-hacer-realmente"><span class="header-section-number">29.4</span> ¿Qué podemos hacer realmente?</h2>
<p>Resulta que estamos bastante limitados en lo que podemos y no podemos hacer en nuestros manejadores de señales. Esta es una de las razones por las que digo que ni siquiera deberías molestarte con esto y en su lugar utilizar el manejo de señales de tu sistema operativo (por ejemplo, . <code>sigaction()</code> para sistemas tipo Unix).</p>
<p>Wikipedia llega a decir que lo único realmente portable que puedes hacer es llamar a <code>signal()</code> con <code>SIG_IGN</code> o <code>SIG_DFL</code> y ya está.</p>
<p>Esto es lo que <strong>no</strong> podemos hacer de forma portable:</p>
<p></p>
<ul>
<li>Llama a cualquier función de la biblioteca estándar.
<ul>
<li>Como <code>printf()</code>, por ejemplo.</li>
<li>Creo que es probablemente seguro llamar a funciones reiniciables/reentrantes, pero la especificación no permite esa libertad.</li>
</ul></li>
<li>Obtener o establecer valores desde una variable local <code>static</code>, file scope, o thread-local.
<ul>
<li>A menos que sea un objeto atómico libre de bloqueos o…</li>
<li>Estás asignando a una variable de tipo <code>volatile sig_atomic_t</code>.</li>
</ul></li>
</ul>
<p></p>
<p>Ese último bit–<code>sig_atomic_t</code>–es tu boleto para obtener datos de un manejador de señales. (A menos que quieras usar objetos atómicos sin bloqueo, lo cual está fuera del alcance de esta sección<a href="#fn170" class="footnote-ref" id="fnref170" role="doc-noteref"><sup>170</sup></a>). Es un tipo entero que puede o no estar firmado. Y está limitado por lo que puedes poner ahí Puede consultar los valores mínimo y máximo permitidos en las macros <code>SIG_ATOMIC_MIN</code> y <code>SIG_ATOMIC_MAX</code><a href="#fn171" class="footnote-ref" id="fnref171" role="doc-noteref"><sup>171</sup></a>.</p>
<p>Confusamente, la especificación también dice que no puedes referirte “a ningún objeto con duración de almacenamiento estático o de hilo que no sea un objeto atómico libre de bloqueos que no sea asignando un valor a un objeto declarado como <code>volatile sig_atomic_t</code> […]”.</p>
<p>Mi lectura de esto es que no puedes leer o escribir nada que no sea un objeto atómico libre de bloqueo. También puedes asignar a un objeto que es <code>volatile sig_atomic_t</code>.</p>
<p>¿Pero puedes leer de él? Honestamente, no veo por qué no, excepto que la especificación es muy específica sobre la mención de asignar a. Pero si tienes que leerlo y tomar cualquier tipo de decisión basándote en ello, podrías estar abriendo espacio para algún tipo de race conditions.</p>
<p></p>
<p>Con esto en mente, podemos reescribir nuestro código “pulsa <code>CTRL-C</code> dos veces para salir” para que sea un poco más portable, aunque menos verboso en la salida.</p>
<p>Cambiemos nuestro manejador <code>SIGINT</code> para que no haga nada excepto incrementar un valor de tipo <code>volatile sig_atomic_t</code>. Así contará el número de <code>CTRL-C</code>s que han sido pulsados.</p>
<p>Luego, en nuestro bucle principal, comprobaremos si el contador es mayor de <code>2</code>, y si es así, lo abandonaremos.</p>
<div class="sourceCode" id="cb586"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb586-1"><a href="#cb586-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb586-2"><a href="#cb586-2"></a><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></span>
<span id="cb586-3"><a href="#cb586-3"></a></span>
<span id="cb586-4"><a href="#cb586-4"></a><span class="dt">volatile</span> <span class="dt">sig_atomic_t</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb586-5"><a href="#cb586-5"></a></span>
<span id="cb586-6"><a href="#cb586-6"></a><span class="dt">void</span> sigint_handler<span class="op">(</span><span class="dt">int</span> signum<span class="op">)</span></span>
<span id="cb586-7"><a href="#cb586-7"></a><span class="op">{</span></span>
<span id="cb586-8"><a href="#cb586-8"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>signum<span class="op">;</span>                    <span class="co">// Aviso de variable no utilizada</span></span>
<span id="cb586-9"><a href="#cb586-9"></a></span>
<span id="cb586-10"><a href="#cb586-10"></a>    signal<span class="op">(</span>SIGINT<span class="op">,</span> sigint_handler<span class="op">);</span>  <span class="co">// Restablecer manejador de señal</span></span>
<span id="cb586-11"><a href="#cb586-11"></a></span>
<span id="cb586-12"><a href="#cb586-12"></a>    count<span class="op">++;</span>                         <span class="co">// Comportamiento indefinido</span></span>
<span id="cb586-13"><a href="#cb586-13"></a><span class="op">}</span></span>
<span id="cb586-14"><a href="#cb586-14"></a></span>
<span id="cb586-15"><a href="#cb586-15"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb586-16"><a href="#cb586-16"></a><span class="op">{</span></span>
<span id="cb586-17"><a href="#cb586-17"></a>    signal<span class="op">(</span>SIGINT<span class="op">,</span> sigint_handler<span class="op">);</span></span>
<span id="cb586-18"><a href="#cb586-18"></a></span>
<span id="cb586-19"><a href="#cb586-19"></a>    printf<span class="op">(</span><span class="st">&quot;Hit ^C twice to exit.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb586-20"><a href="#cb586-20"></a></span>
<span id="cb586-21"><a href="#cb586-21"></a>    <span class="cf">while</span><span class="op">(</span>count <span class="op">&lt;</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb586-22"><a href="#cb586-22"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>¿Otra vez comportamiento indefinido? Yo creo que sí, porque tenemos que leer el valor para incrementarlo y almacenarlo.</p>
<p>Si sólo queremos posponer la salida una pulsación de <code>CTRL-C</code>, podemos hacerlo sin demasiados problemas. Pero cualquier otro aplazamiento requeriría un encadenamiento de funciones ridículo.</p>
<p>Lo que haremos es manejarlo una vez, y el manejador restablecerá la señal a su comportamiento por defecto (es decir, a la salida):</p>
<p></p>
<div class="sourceCode" id="cb587"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb587-1"><a href="#cb587-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb587-2"><a href="#cb587-2"></a><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></span>
<span id="cb587-3"><a href="#cb587-3"></a></span>
<span id="cb587-4"><a href="#cb587-4"></a><span class="dt">void</span> sigint_handler<span class="op">(</span><span class="dt">int</span> signum<span class="op">)</span></span>
<span id="cb587-5"><a href="#cb587-5"></a><span class="op">{</span></span>
<span id="cb587-6"><a href="#cb587-6"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>signum<span class="op">;</span>                      <span class="co">// Aviso de variable no utilizada</span></span>
<span id="cb587-7"><a href="#cb587-7"></a>    signal<span class="op">(</span>SIGINT<span class="op">,</span> SIG_DFL<span class="op">);</span>           <span class="co">// Restablecer manejador de señal</span></span>
<span id="cb587-8"><a href="#cb587-8"></a><span class="op">}</span></span>
<span id="cb587-9"><a href="#cb587-9"></a></span>
<span id="cb587-10"><a href="#cb587-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb587-11"><a href="#cb587-11"></a><span class="op">{</span></span>
<span id="cb587-12"><a href="#cb587-12"></a>    signal<span class="op">(</span>SIGINT<span class="op">,</span> sigint_handler<span class="op">);</span></span>
<span id="cb587-13"><a href="#cb587-13"></a></span>
<span id="cb587-14"><a href="#cb587-14"></a>    printf<span class="op">(</span><span class="st">&quot;Hit ^C twice to exit.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb587-15"><a href="#cb587-15"></a></span>
<span id="cb587-16"><a href="#cb587-16"></a>    <span class="cf">while</span><span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb587-17"><a href="#cb587-17"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Más adelante, cuando veamos las variables atómicas sin bloqueo, veremos una forma de arreglar la versión <code>count</code> (suponiendo que las variables atómicas sin bloqueo estén disponibles en tu sistema en particular).</p>
<p>Esta es la razón por la que al principio, sugería comprobar el sistema de señales integrado en tu sistema operativo como una alternativa probablemente superior.</p>
<h2 data-number="29.5" id="los-amigos-no-dejan-a-los-amigos-señal"><span class="header-section-number">29.5</span> Los amigos no dejan a los amigos <code>señal()</code></h2>
<p>De nuevo, usa el manejo de señales integrado en tu sistema operativo o su equivalente. No está en la especificación, no es tan portable, pero probablemente es mucho más capaz. Además, tu sistema operativo probablemente tenga definidas un número de señales que no están en la especificación de C. Y es difícil escribir señales portables. Más adelante, cuando veamos las variables atómicas sin bloqueo, veremos una forma de arreglar la versión <code>count</code> (suponiendo que las variables atómicas sin bloqueo estén disponibles en tu sistema en particular).</p>
<p>Esta es la razón por la que al principio, sugería comprobar el sistema de señales integrado en tu sistema operativo como una alternativa probablemente superior.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="30" id="matrices-de-longitud-variable-vla"><span class="header-section-number">30</span> Matrices de longitud variable (VLA)</h1>
<p></p>
<p>C permite declarar un array cuyo tamaño se determina en tiempo de ejecución. Esto te da los beneficios del dimensionamiento dinámico en tiempo de ejecución que obtienes con <code>malloc()</code>, pero sin tener que preocuparte de <code>free()</code> la memoria después.</p>
<p>A mucha gente no le gustan los VLAs. Por ejemplo, han sido prohibidos en el kernel de Linux. Profundizaremos más en ese razonamiento <a href="#vla-general-issues">más tarde</a>. </p>
<p>Se trata de una característica opcional del lenguaje. La macro <code>__STDC_NO_VLA__</code> se pone a <code>1</code> si los VLAs <em>no</em> están presentes. (Eran obligatorios en C99, y luego pasaron a ser opcionales en C11).</p>
<div class="sourceCode" id="cb588"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb588-1"><a href="#cb588-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if __STDC_NO_VLA__ == 1</span></span>
<span id="cb588-2"><a href="#cb588-2" aria-hidden="true" tabindex="-1"></a>   <span class="pp">#error Sorry, need VLAs for this program!</span></span>
<span id="cb588-3"><a href="#cb588-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p></p>
<p>Pero como ni GCC ni Clang se molestan en definir esta macro, puede que le saques poco provecho.</p>
<p>Vamos a sumergirnos primero con un ejemplo, y luego buscaremos el diablo en los detalles.</p>
<h2 data-number="30.1" id="lo-básico"><span class="header-section-number">30.1</span> Lo Básico</h2>
<p>Un array normal se declara con un tamaño constante, así:</p>
<div class="sourceCode" id="cb589"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb589-1"><a href="#cb589-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span></code></pre></div>
<p></p>
<p>Pero con VLAs, podemos utilizar un tamaño determinado en tiempo de ejecución para establecer la matriz, así:</p>
<div class="sourceCode" id="cb590"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb590-1"><a href="#cb590-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb590-2"><a href="#cb590-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v<span class="op">[</span>n<span class="op">];</span></span></code></pre></div>
<p>Ahora, eso parece lo mismo, y en muchos sentidos lo es, pero esto le da la flexibilidad para calcular el tamaño que necesita, y luego obtener una matriz de exactamente ese tamaño.</p>
<p>Vamos a pedir al usuario que introduzca el tamaño de la matriz, y luego almacenar el índice 10 veces, en cada uno de los elementos de la matriz:</p>
<div class="sourceCode" id="cb591"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb591-1"><a href="#cb591-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb591-2"><a href="#cb591-2"></a></span>
<span id="cb591-3"><a href="#cb591-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb591-4"><a href="#cb591-4"></a><span class="op">{</span></span>
<span id="cb591-5"><a href="#cb591-5"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb591-6"><a href="#cb591-6"></a>    <span class="dt">char</span> buf<span class="op">[</span><span class="dv">32</span><span class="op">];</span></span>
<span id="cb591-7"><a href="#cb591-7"></a></span>
<span id="cb591-8"><a href="#cb591-8"></a>    printf<span class="op">(</span><span class="st">&quot;Enter a number: &quot;</span><span class="op">);</span> fflush<span class="op">(</span>stdout<span class="op">);</span></span>
<span id="cb591-9"><a href="#cb591-9"></a>    fgets<span class="op">(</span>buf<span class="op">,</span> <span class="kw">sizeof</span> buf<span class="op">,</span> stdin<span class="op">);</span></span>
<span id="cb591-10"><a href="#cb591-10"></a>    n <span class="op">=</span> strtoul<span class="op">(</span>buf<span class="op">,</span> NULL<span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb591-11"><a href="#cb591-11"></a></span>
<span id="cb591-12"><a href="#cb591-12"></a>    <span class="dt">int</span> v<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb591-13"><a href="#cb591-13"></a></span>
<span id="cb591-14"><a href="#cb591-14"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb591-15"><a href="#cb591-15"></a>        v<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb591-16"><a href="#cb591-16"></a></span>
<span id="cb591-17"><a href="#cb591-17"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb591-18"><a href="#cb591-18"></a>        printf<span class="op">(</span><span class="st">&quot;v[</span><span class="sc">%d</span><span class="st">] = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> v<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb591-19"><a href="#cb591-19"></a><span class="op">}</span></span></code></pre></div>
<p>(En la línea 7, tengo un <code>fflush()</code> que debería forzar la salida de la línea aunque no tenga una nueva línea al final).</p>
<p>La línea 10 es donde declaramos el VLA—una vez que la ejecución pasa esa línea, el tamaño del array se establece a lo que sea <code>n</code> en ese momento. La longitud del array no se puede cambiar más tarde.</p>
<p>También puedes poner una expresión entre paréntesis:</p>
<div class="sourceCode" id="cb592"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb592-1"><a href="#cb592-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v<span class="op">[</span>x <span class="op">*</span> <span class="dv">100</span><span class="op">];</span></span></code></pre></div>
<p>Algunas restricciones:</p>
<ul>
<li>No puedes declarar una VLA en el ámbito de un fichero, y no puedes hacer una <code>static</code> en el ámbito de un bloque<a href="#fn172" class="footnote-ref" id="fnref172" role="doc-noteref"><sup>172</sup></a>.</li>
<li>No puedes usar una lista inicializadora para inicializar el array.</li>
</ul>
<p>Además, introducir un valor negativo para el tamaño del array invoca un comportamiento indefinido— al menos en este universo.</p>
<p></p>
<h2 data-number="30.2" id="sizeof-y-vlas"><span class="header-section-number">30.2</span> <code>sizeof</code> y VLAs</h2>
<p></p>
<p>Estamos acostumbrados a que <code>sizeof</code> nos indique el tamaño en bytes de cualquier objeto, incluidas las matrices. Y los VLAs no son una excepción.</p>
<p>La principal diferencia es que <code>sizeof</code> en una VLA se ejecuta en <em>runtime</em>, mientras que en una variable de tamaño no variable se calcula en <em>tiempo de compilación</em>.</p>
<p>Pero el uso es el mismo.</p>
<p>Incluso se puede calcular el número de elementos de un VLA con el truco habitual de los arrays:</p>
<div class="sourceCode" id="cb593"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb593-1"><a href="#cb593-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> num_elems <span class="op">=</span> <span class="kw">sizeof</span> v <span class="op">/</span> <span class="kw">sizeof</span> v<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span></code></pre></div>
<p>Hay una implicación sutil y correcta en la línea anterior: la aritmética de punteros funciona como cabría esperar para una matriz normal. Así que adelante, úsala a tu antojo:</p>
<div class="sourceCode" id="cb594"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb594-1"><a href="#cb594-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb594-2"><a href="#cb594-2"></a></span>
<span id="cb594-3"><a href="#cb594-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb594-4"><a href="#cb594-4"></a><span class="op">{</span></span>
<span id="cb594-5"><a href="#cb594-5"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb594-6"><a href="#cb594-6"></a>    <span class="dt">int</span> v<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb594-7"><a href="#cb594-7"></a></span>
<span id="cb594-8"><a href="#cb594-8"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb594-9"><a href="#cb594-9"></a></span>
<span id="cb594-10"><a href="#cb594-10"></a>    <span class="op">*(</span>p<span class="op">+</span><span class="dv">2</span><span class="op">)</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb594-11"><a href="#cb594-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> v<span class="op">[</span><span class="dv">2</span><span class="op">]);</span>  <span class="co">// 12</span></span>
<span id="cb594-12"><a href="#cb594-12"></a></span>
<span id="cb594-13"><a href="#cb594-13"></a>    p<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="dv">34</span><span class="op">;</span></span>
<span id="cb594-14"><a href="#cb594-14"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> v<span class="op">[</span><span class="dv">3</span><span class="op">]);</span>  <span class="co">// 34</span></span>
<span id="cb594-15"><a href="#cb594-15"></a><span class="op">}</span></span></code></pre></div>
<p>Al igual que con las matrices normales, puede utilizar paréntesis con <code>sizeof()</code> para obtener el tamaño de un posible VLA sin tener que declararlo:</p>
<div class="sourceCode" id="cb595"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb595-1"><a href="#cb595-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb595-2"><a href="#cb595-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb595-3"><a href="#cb595-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span> <span class="op">[</span>x<span class="op">]));</span>  <span class="co">// Imprime 48 en mi sistema</span></span></code></pre></div>
<p></p>
<h2 data-number="30.3" id="vla-multidimensionales"><span class="header-section-number">30.3</span> VLA multidimensionales</h2>
<p></p>
<p>puede seguir adelante y hacer todo tipo de VLA con una o más dimensiones establecidas en una variable</p>
<div class="sourceCode" id="cb596"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb596-1"><a href="#cb596-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> w <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb596-2"><a href="#cb596-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> h <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb596-3"><a href="#cb596-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb596-4"><a href="#cb596-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[</span>h<span class="op">][</span>w<span class="op">];</span></span>
<span id="cb596-5"><a href="#cb596-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y<span class="op">[</span><span class="dv">5</span><span class="op">][</span>w<span class="op">];</span></span>
<span id="cb596-6"><a href="#cb596-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> z<span class="op">[</span><span class="dv">10</span><span class="op">][</span>w<span class="op">][</span><span class="dv">20</span><span class="op">];</span></span></code></pre></div>
<p>De nuevo, puedes navegar por ellas como lo harías por un array normal.</p>
<p></p>
<h2 data-number="30.4" id="pasar-vlas-unidimensionales-a-funciones"><span class="header-section-number">30.4</span> Pasar VLAs unidimensionales a funciones</h2>
<p></p>
<p>Pasar VLAs unidimensionales a una función no puede ser diferente de pasar un array normal. Basta con hacerlo.</p>
<div class="sourceCode" id="cb597"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb597-1"><a href="#cb597-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb597-2"><a href="#cb597-2"></a></span>
<span id="cb597-3"><a href="#cb597-3"></a><span class="dt">int</span> sum<span class="op">(</span><span class="dt">int</span> count<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>v<span class="op">)</span></span>
<span id="cb597-4"><a href="#cb597-4"></a><span class="op">{</span></span>
<span id="cb597-5"><a href="#cb597-5"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb597-6"><a href="#cb597-6"></a></span>
<span id="cb597-7"><a href="#cb597-7"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> count<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb597-8"><a href="#cb597-8"></a>        total <span class="op">+=</span> v<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb597-9"><a href="#cb597-9"></a></span>
<span id="cb597-10"><a href="#cb597-10"></a>    <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb597-11"><a href="#cb597-11"></a><span class="op">}</span></span>
<span id="cb597-12"><a href="#cb597-12"></a></span>
<span id="cb597-13"><a href="#cb597-13"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb597-14"><a href="#cb597-14"></a><span class="op">{</span></span>
<span id="cb597-15"><a href="#cb597-15"></a>    <span class="dt">int</span> x<span class="op">[</span><span class="dv">5</span><span class="op">];</span>   <span class="co">// Standard array</span></span>
<span id="cb597-16"><a href="#cb597-16"></a></span>
<span id="cb597-17"><a href="#cb597-17"></a>    <span class="dt">int</span> a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb597-18"><a href="#cb597-18"></a>    <span class="dt">int</span> y<span class="op">[</span>a<span class="op">];</span>   <span class="co">// VLA</span></span>
<span id="cb597-19"><a href="#cb597-19"></a></span>
<span id="cb597-20"><a href="#cb597-20"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> a<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb597-21"><a href="#cb597-21"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> y<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb597-22"><a href="#cb597-22"></a></span>
<span id="cb597-23"><a href="#cb597-23"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">5</span><span class="op">,</span> x<span class="op">));</span></span>
<span id="cb597-24"><a href="#cb597-24"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> sum<span class="op">(</span>a<span class="op">,</span> y<span class="op">));</span></span>
<span id="cb597-25"><a href="#cb597-25"></a><span class="op">}</span></span></code></pre></div>
<p>Pero hay algo más. También puedes hacer saber a C que el array tiene un tamaño VLA específico pasándolo primero y luego dando esa dimensión en la lista de parámetros:</p>
<div class="sourceCode" id="cb598"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb598-1"><a href="#cb598-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="dt">int</span> count<span class="op">,</span> <span class="dt">int</span> v<span class="op">[</span>count<span class="op">])</span></span>
<span id="cb598-2"><a href="#cb598-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb598-3"><a href="#cb598-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb598-4"><a href="#cb598-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Por cierto, hay un par de formas de listar un prototipo para la función anterior; una de ellas implica un <code>*</code> si no se quiere nombrar específicamente el valor en el VLA. Sólo indica que el tipo es un VLA en lugar de un puntero normal.</p>
<p>Prototipos VLA:</p>
<div class="sourceCode" id="cb599"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb599-1"><a href="#cb599-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> do_something<span class="op">(</span><span class="dt">int</span> count<span class="op">,</span> <span class="dt">int</span> v<span class="op">[</span>count<span class="op">]);</span>  <span class="co">// Con nombres</span></span>
<span id="cb599-2"><a href="#cb599-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> do_something<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span> v<span class="op">[*]);</span>            <span class="co">// Sin nombres</span></span></code></pre></div>
<p>De nuevo, eso de <code>*</code> sólo funciona con el prototipo–en la función en sí, tendrás que poner el tamaño explícito.</p>
<p> </p>
<p>Ahora… ¡vamos a lo multidimensional! Aquí empieza la diversión.</p>
<h2 data-number="30.5" id="pasar-vlas-multidimensionales-a-funciones"><span class="header-section-number">30.5</span> Pasar VLAs multidimensionales a funciones</h2>
<p>Lo mismo que hicimos con la segunda forma de VLAs unidimensionales, arriba, pero esta vez pasamos dos dimensiones y las usamos.</p>
<p>En el siguiente ejemplo, construimos una matriz de tabla de multiplicación de anchura y altura variables, y luego la pasamos a una función para que la imprima. Aquí empieza la diversión.</p>
<div class="sourceCode" id="cb600"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb600-1"><a href="#cb600-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb600-2"><a href="#cb600-2"></a></span>
<span id="cb600-3"><a href="#cb600-3"></a><span class="dt">void</span> print_matrix<span class="op">(</span><span class="dt">int</span> h<span class="op">,</span> <span class="dt">int</span> w<span class="op">,</span> <span class="dt">int</span> m<span class="op">[</span>h<span class="op">][</span>w<span class="op">])</span></span>
<span id="cb600-4"><a href="#cb600-4"></a><span class="op">{</span></span>
<span id="cb600-5"><a href="#cb600-5"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> row <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> row <span class="op">&lt;</span> h<span class="op">;</span> row<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb600-6"><a href="#cb600-6"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> col <span class="op">&lt;</span> w<span class="op">;</span> col<span class="op">++)</span></span>
<span id="cb600-7"><a href="#cb600-7"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%2d</span><span class="st"> &quot;</span><span class="op">,</span> m<span class="op">[</span>row<span class="op">][</span>col<span class="op">]);</span></span>
<span id="cb600-8"><a href="#cb600-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb600-9"><a href="#cb600-9"></a>    <span class="op">}</span></span>
<span id="cb600-10"><a href="#cb600-10"></a><span class="op">}</span></span>
<span id="cb600-11"><a href="#cb600-11"></a></span>
<span id="cb600-12"><a href="#cb600-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb600-13"><a href="#cb600-13"></a><span class="op">{</span></span>
<span id="cb600-14"><a href="#cb600-14"></a>    <span class="dt">int</span> rows <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb600-15"><a href="#cb600-15"></a>    <span class="dt">int</span> cols <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb600-16"><a href="#cb600-16"></a></span>
<span id="cb600-17"><a href="#cb600-17"></a>    <span class="dt">int</span> matrix<span class="op">[</span>rows<span class="op">][</span>cols<span class="op">];</span></span>
<span id="cb600-18"><a href="#cb600-18"></a></span>
<span id="cb600-19"><a href="#cb600-19"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> row <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> row <span class="op">&lt;</span> rows<span class="op">;</span> row<span class="op">++)</span></span>
<span id="cb600-20"><a href="#cb600-20"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> col <span class="op">&lt;</span> cols<span class="op">;</span> col<span class="op">++)</span></span>
<span id="cb600-21"><a href="#cb600-21"></a>            matrix<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> row <span class="op">*</span> col<span class="op">;</span></span>
<span id="cb600-22"><a href="#cb600-22"></a></span>
<span id="cb600-23"><a href="#cb600-23"></a>    print_matrix<span class="op">(</span>rows<span class="op">,</span> cols<span class="op">,</span> matrix<span class="op">);</span></span>
<span id="cb600-24"><a href="#cb600-24"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="30.5.1" id="vla-multidimensionales-parciales"><span class="header-section-number">30.5.1</span> VLA multidimensionales parciales</h3>
<p>Puede tener algunas de las dimensiones fijas y otras variables. Digamos que tenemos una longitud de registro fija en 5 elementos, pero no sabemos cuántos registros hay.</p>
<div class="sourceCode" id="cb601"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb601-1"><a href="#cb601-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb601-2"><a href="#cb601-2"></a></span>
<span id="cb601-3"><a href="#cb601-3"></a><span class="dt">void</span> print_records<span class="op">(</span><span class="dt">int</span> count<span class="op">,</span> <span class="dt">int</span> record<span class="op">[</span>count<span class="op">][</span><span class="dv">5</span><span class="op">])</span></span>
<span id="cb601-4"><a href="#cb601-4"></a><span class="op">{</span></span>
<span id="cb601-5"><a href="#cb601-5"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> count<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb601-6"><a href="#cb601-6"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb601-7"><a href="#cb601-7"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%2d</span><span class="st"> &quot;</span><span class="op">,</span> record<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb601-8"><a href="#cb601-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb601-9"><a href="#cb601-9"></a>    <span class="op">}</span></span>
<span id="cb601-10"><a href="#cb601-10"></a><span class="op">}</span></span>
<span id="cb601-11"><a href="#cb601-11"></a></span>
<span id="cb601-12"><a href="#cb601-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb601-13"><a href="#cb601-13"></a><span class="op">{</span></span>
<span id="cb601-14"><a href="#cb601-14"></a>    <span class="dt">int</span> rec_count <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb601-15"><a href="#cb601-15"></a>    <span class="dt">int</span> records<span class="op">[</span>rec_count<span class="op">][</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb601-16"><a href="#cb601-16"></a></span>
<span id="cb601-17"><a href="#cb601-17"></a>    <span class="co">// Fill with some dummy data</span></span>
<span id="cb601-18"><a href="#cb601-18"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> rec_count<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb601-19"><a href="#cb601-19"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb601-20"><a href="#cb601-20"></a>            records<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>i<span class="op">+</span><span class="dv">1</span><span class="op">)*(</span>j<span class="op">+</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb601-21"><a href="#cb601-21"></a></span>
<span id="cb601-22"><a href="#cb601-22"></a>    print_records<span class="op">(</span>rec_count<span class="op">,</span> records<span class="op">);</span></span>
<span id="cb601-23"><a href="#cb601-23"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<h2 data-number="30.6" id="compatibilidad-con-matrices-regulares"><span class="header-section-number">30.6</span> Compatibilidad con matrices regulares</h2>
<p></p>
<p>Dado que los VLA son como matrices normales en memoria, es perfectamente permisible pasarlos indistintamente… siempre que las dimensiones coincidan.</p>
<p>Por ejemplo, si tenemos una función que específicamente quiere un array de <span class="math inline">\(3\times5\)</span>, podemos pasarle un VLA.</p>
<div class="sourceCode" id="cb602"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb602-1"><a href="#cb602-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo<span class="op">(</span><span class="dt">int</span> m<span class="op">[</span><span class="dv">5</span><span class="op">][</span><span class="dv">3</span><span class="op">])</span> <span class="op">{...}</span></span>
<span id="cb602-2"><a href="#cb602-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb602-3"><a href="#cb602-3" aria-hidden="true" tabindex="-1"></a>\\ <span class="op">...</span></span>
<span id="cb602-4"><a href="#cb602-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb602-5"><a href="#cb602-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> w <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> h <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb602-6"><a href="#cb602-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> matrix<span class="op">[</span>h<span class="op">][</span>w<span class="op">];</span></span>
<span id="cb602-7"><a href="#cb602-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb602-8"><a href="#cb602-8" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span>matrix<span class="op">);</span>   <span class="co">// OK!</span></span></code></pre></div>
<p>Del mismo modo, si tiene una función VLA, puede pasarle una matriz normal:</p>
<div class="sourceCode" id="cb603"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb603-1"><a href="#cb603-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo<span class="op">(</span><span class="dt">int</span> h<span class="op">,</span> <span class="dt">int</span> w<span class="op">,</span> <span class="dt">int</span> m<span class="op">[</span>h<span class="op">][</span>w<span class="op">])</span> <span class="op">{...}</span></span>
<span id="cb603-2"><a href="#cb603-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb603-3"><a href="#cb603-3" aria-hidden="true" tabindex="-1"></a>\\ <span class="op">...</span></span>
<span id="cb603-4"><a href="#cb603-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb603-5"><a href="#cb603-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> matrix<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb603-6"><a href="#cb603-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb603-7"><a href="#cb603-7" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> matrix<span class="op">);</span>   <span class="co">// OK!</span></span></code></pre></div>
<p>Pero cuidado: si las dimensiones no coinciden, es probable que se produzcan comportamientos indefinidos. </p>
<h2 data-number="30.7" id="typedef-y-vlas"><span class="header-section-number">30.7</span> <code>typedef</code> Y VLAs</h2>
<p></p>
<p>Puedes <code>typedef</code> un VLA, pero el comportamiento puede no ser el que esperas.</p>
<p>Básicamente, <code>typedef</code> hace un nuevo tipo con los valores tal y como existían en el momento en que se ejecutó <code>typedef</code>.</p>
<p>Así que no es un <code>typedef</code> de un VLA tanto como un nuevo tipo de array de tamaño fijo de las dimensiones en ese momento.</p>
<div class="sourceCode" id="cb604"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb604-1"><a href="#cb604-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb604-2"><a href="#cb604-2"></a></span>
<span id="cb604-3"><a href="#cb604-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb604-4"><a href="#cb604-4"></a><span class="op">{</span></span>
<span id="cb604-5"><a href="#cb604-5"></a>    <span class="dt">int</span> w <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb604-6"><a href="#cb604-6"></a></span>
<span id="cb604-7"><a href="#cb604-7"></a>    <span class="kw">typedef</span> <span class="dt">int</span> goat<span class="op">[</span>w<span class="op">];</span></span>
<span id="cb604-8"><a href="#cb604-8"></a></span>
<span id="cb604-9"><a href="#cb604-9"></a>    <span class="co">// goat es un array de 10 ints</span></span>
<span id="cb604-10"><a href="#cb604-10"></a>    goat x<span class="op">;</span></span>
<span id="cb604-11"><a href="#cb604-11"></a></span>
<span id="cb604-12"><a href="#cb604-12"></a>    <span class="co">// Init con cuadrados de números</span></span>
<span id="cb604-13"><a href="#cb604-13"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> w<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb604-14"><a href="#cb604-14"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">*</span>i<span class="op">;</span></span>
<span id="cb604-15"><a href="#cb604-15"></a></span>
<span id="cb604-16"><a href="#cb604-16"></a>    <span class="co">// Imprimirlos</span></span>
<span id="cb604-17"><a href="#cb604-17"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> w<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb604-18"><a href="#cb604-18"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb604-19"><a href="#cb604-19"></a></span>
<span id="cb604-20"><a href="#cb604-20"></a>    <span class="co">// Ahora vamos a cambiar w...</span></span>
<span id="cb604-21"><a href="#cb604-21"></a></span>
<span id="cb604-22"><a href="#cb604-22"></a>    w <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb604-23"><a href="#cb604-23"></a></span>
<span id="cb604-24"><a href="#cb604-24"></a>    <span class="co">// Pero cabra es TODAVÍA un array de 10 ints, porque ese era el</span></span>
<span id="cb604-25"><a href="#cb604-25"></a>    <span class="co">// valor de w cuando se ejecutó el typedef.</span></span>
<span id="cb604-26"><a href="#cb604-26"></a><span class="op">}</span></span></code></pre></div>
<p>Así que actúa como un array de tamaño fijo.</p>
<p>Pero todavía no se puede utilizar una lista de inicializadores en él.</p>
<p></p>
<h2 data-number="30.8" id="salto-de-trampas"><span class="header-section-number">30.8</span> Salto de Trampas</h2>
<p></p>
<p>Hay que tener cuidado cuando se usa <code>goto</code> cerca de VLAs porque muchas cosas no son legales.</p>
<p> </p>
<p>Y cuando usas <code>longjmp()</code> hay un caso en el que podrías tener fugas de memoria con VLAs. </p>
<p>Pero ambas cosas las trataremos en sus respectivos capítulos.</p>
<h2 data-number="30.9" id="vla-general-issues"><span class="header-section-number">30.9</span> Cuestiones generales</h2>
<p></p>
<p>Los VLAs han sido prohibidos en el kernel de Linux por varias razones:</p>
<ul>
<li>Muchos de los lugares en los que se usaban deberían haber sido de tamaño fijo.</li>
<li>El código detrás de los VLAs es más lento (en un grado que la mayoría de la gente no notaría, pero que marca la diferencia en un sistema operativo).</li>
<li>No todos los compiladores de C soportan VLA en el mismo grado.</li>
<li>El tamaño de la pila es limitado, y los VLAs van en la pila. Si algún código accidentalmente (o maliciosamente) pasa un valor grande a una función del núcleo que asigna un VLA, <em>Bad Things</em>™ podría suceder.</li>
</ul>
<p>Otras personas en línea señalan que no hay manera de detectar un fallo en la asignación de un VLA, y los programas que sufrieran tales problemas probablemente simplemente se bloquearían. Aunque las matrices de tamaño fijo también tienen el mismo problema, es mucho más probable que alguien haga accidentalmente una <em>VLA de tamaño inusual</em> que declarar accidentalmente una matriz de tamaño fijo, digamos, de 30 megabytes.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="31" id="goto"><span class="header-section-number">31</span> <code>goto</code></h1>
<p></p>
<p>La afirmación <code>goto</code> es universalmente venerada y puede presentarse aquí sin impugnación.</p>
<p>Es broma. A lo largo de los años, ha habido muchas idas y venidas sobre si <code>goto</code> es o no (a menudo no) <a href="https://en.wikipedia.org/wiki/Goto#Criticism">considerado dañino</a><a href="#fn173" class="footnote-ref" id="fnref173" role="doc-noteref"><sup>173</sup></a>.</p>
<p>En opinión de este programador, deberías usar cualquier construcción que conduzca al <em>mejor</em> código, teniendo en cuenta la mantenibilidad y la velocidad. ¡Y a veces esto puede ser <code>goto</code>!</p>
<p>En este capítulo, veremos cómo funciona <code>goto</code> en C, y luego comprobaremos algunos de los casos comunes en los que se usa<a href="#fn174" class="footnote-ref" id="fnref174" role="doc-noteref"><sup>174</sup></a>.</p>
<h2 data-number="31.1" id="un-ejemplo-sencillo"><span class="header-section-number">31.1</span> Un ejemplo sencillo</h2>
<p></p>
<p>En este ejemplo, vamos a utilizar <code>goto</code> para saltar una línea de código y saltar a una <em>etiqueta</em>. La etiqueta es el identificador que puede ser un objetivo de <code>goto</code>; termina con dos puntos (<code>:</code>).</p>
<div class="sourceCode" id="cb605"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb605-1"><a href="#cb605-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb605-2"><a href="#cb605-2"></a></span>
<span id="cb605-3"><a href="#cb605-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb605-4"><a href="#cb605-4"></a><span class="op">{</span></span>
<span id="cb605-5"><a href="#cb605-5"></a>    printf<span class="op">(</span><span class="st">&quot;One</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb605-6"><a href="#cb605-6"></a>    printf<span class="op">(</span><span class="st">&quot;Two</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb605-7"><a href="#cb605-7"></a></span>
<span id="cb605-8"><a href="#cb605-8"></a>    <span class="cf">goto</span> skip_3<span class="op">;</span></span>
<span id="cb605-9"><a href="#cb605-9"></a></span>
<span id="cb605-10"><a href="#cb605-10"></a>    printf<span class="op">(</span><span class="st">&quot;Three</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb605-11"><a href="#cb605-11"></a></span>
<span id="cb605-12"><a href="#cb605-12"></a>skip_3<span class="op">:</span></span>
<span id="cb605-13"><a href="#cb605-13"></a></span>
<span id="cb605-14"><a href="#cb605-14"></a>    printf<span class="op">(</span><span class="st">&quot;Five!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb605-15"><a href="#cb605-15"></a><span class="op">}</span></span></code></pre></div>
<p>La salida es :</p>
<div class="sourceCode" id="cb606"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb606-1"><a href="#cb606-1" aria-hidden="true" tabindex="-1"></a>One</span>
<span id="cb606-2"><a href="#cb606-2" aria-hidden="true" tabindex="-1"></a>Two</span>
<span id="cb606-3"><a href="#cb606-3" aria-hidden="true" tabindex="-1"></a>Five!</span></code></pre></div>
<p><code>goto</code> envía la ejecución saltando a la etiqueta especificada, saltándose todo lo que hay entre medias.</p>
<p>Puedes saltar hacia delante o hacia atrás con <code>goto</code>.</p>
<div class="sourceCode" id="cb607"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb607-1"><a href="#cb607-1" aria-hidden="true" tabindex="-1"></a>infinite_loop<span class="op">:</span></span>
<span id="cb607-2"><a href="#cb607-2" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb607-3"><a href="#cb607-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> infinite_loop<span class="op">;</span></span></code></pre></div>
<p>Las etiquetas se omiten durante la ejecución. Lo siguiente imprimirá los tres números en orden como si las etiquetas no estuvieran allí:</p>
<div class="sourceCode" id="cb608"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb608-1"><a href="#cb608-1" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Zero</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb608-2"><a href="#cb608-2" aria-hidden="true" tabindex="-1"></a>label_1<span class="op">:</span></span>
<span id="cb608-3"><a href="#cb608-3" aria-hidden="true" tabindex="-1"></a>label_2<span class="op">:</span></span>
<span id="cb608-4"><a href="#cb608-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;One</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb608-5"><a href="#cb608-5" aria-hidden="true" tabindex="-1"></a>label_3<span class="op">:</span></span>
<span id="cb608-6"><a href="#cb608-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Two</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb608-7"><a href="#cb608-7" aria-hidden="true" tabindex="-1"></a>label_4<span class="op">:</span></span>
<span id="cb608-8"><a href="#cb608-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Three</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Como habrá notado, es una convención común justificar las etiquetas hasta el final a la izquierda. Esto aumenta la legibilidad porque un lector puede escanear rápidamente para encontrar el destino.</p>
<p>Las etiquetas tienen <em>alcance de función</em>. Es decir, no importa a cuántos niveles de profundidad en los bloques aparezcan, puedes “ir a ellas” desde cualquier parte de la función.</p>
<p>También significa que sólo se puede “ir a” las etiquetas que están en la misma función que la propia “ir a”. Las etiquetas de otras funciones están fuera del alcance de <code>goto</code>. Y significa que puedes usar el mismo nombre de etiqueta en dos funciones, pero no en la misma función. </p>
<h2 data-number="31.2" id="etiqueta-continue"><span class="header-section-number">31.2</span> Etiqueta <code>continue</code></h2>
<p></p>
<p>En algunos lenguajes, puedes especificar una etiqueta para una sentencia <code>continue</code>. C no lo permite, pero puedes usar <code>goto</code> en su lugar.</p>
<p>Para mostrar el problema, mira <code>continue</code> en este bucle anidado:</p>
<div class="sourceCode" id="cb609"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb609-1"><a href="#cb609-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb609-2"><a href="#cb609-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb609-3"><a href="#cb609-3" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb609-4"><a href="#cb609-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span>   <span class="co">// Siempre pasa al siguiente j</span></span>
<span id="cb609-5"><a href="#cb609-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb609-6"><a href="#cb609-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Como vemos, ese <code>continue</code>, como todos los <code>continues</code>, va a la siguiente iteración del bucle más cercano. ¿Y si queremos <code>continuar</code> en el siguiente bucle exterior, el bucle con <code>i</code>?</p>
<p>Bueno, podemos <code>break</code> para volver al bucle exterior, ¿no?</p>
<div class="sourceCode" id="cb610"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb610-1"><a href="#cb610-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb610-2"><a href="#cb610-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb610-3"><a href="#cb610-3" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb610-4"><a href="#cb610-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span>     <span class="co">// Nos lleva a la siguiente iteración de i</span></span>
<span id="cb610-5"><a href="#cb610-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb610-6"><a href="#cb610-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Eso nos da dos niveles de bucle anidado. Pero si anidamos otro bucle, nos quedamos sin opciones. ¿Qué pasa con esto, donde no tenemos ninguna declaración que nos llevará a la siguiente iteración de <code>i</code>?</p>
<div class="sourceCode" id="cb611"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb611-1"><a href="#cb611-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb611-2"><a href="#cb611-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb611-3"><a href="#cb611-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb611-4"><a href="#cb611-4" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb611-5"><a href="#cb611-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb611-6"><a href="#cb611-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span>  <span class="co">// Nos lleva a la siguiente iteración de k</span></span>
<span id="cb611-7"><a href="#cb611-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span>     <span class="co">// Nos lleva a la siguiente iteración de j</span></span>
<span id="cb611-8"><a href="#cb611-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">????;</span>      <span class="co">// Nos lleva a la siguiente iteración de i???</span></span>
<span id="cb611-9"><a href="#cb611-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb611-10"><a href="#cb611-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb611-11"><a href="#cb611-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb611-12"><a href="#cb611-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>¡La sentencia <code>goto</code> nos ofrece un camino!</p>
<div class="sourceCode" id="cb612"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb612-1"><a href="#cb612-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb612-2"><a href="#cb612-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb612-3"><a href="#cb612-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb612-4"><a href="#cb612-4" aria-hidden="true" tabindex="-1"></a>                printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb612-5"><a href="#cb612-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb612-6"><a href="#cb612-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">goto</span> continue_i<span class="op">;</span>   <span class="co">// ¡¡¡Ahora continuando el bucle i!!!</span></span>
<span id="cb612-7"><a href="#cb612-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb612-8"><a href="#cb612-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb612-9"><a href="#cb612-9" aria-hidden="true" tabindex="-1"></a>continue_i<span class="op">:</span> <span class="op">;</span></span>
<span id="cb612-10"><a href="#cb612-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Tenemos un <code>;</code> al final—eso es porque no se puede tener una etiqueta apuntando al final plano de una sentencia compuesta (o antes de una declaración de variable).</p>
<p></p>
<h2 data-number="31.3" id="libertad-bajo-fianza"><span class="header-section-number">31.3</span> Libertad bajo fianza</h2>
<p></p>
<p>Cuando estás super anidado en medio de algún código, puedes usar <code>goto</code> para salir de él de una manera que a menudo es más limpia que anidar más <code>if</code>s y usar variables flag.</p>
<div class="sourceCode" id="cb613"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb613-1"><a href="#cb613-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Pseudocode</span></span>
<span id="cb613-2"><a href="#cb613-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb613-3"><a href="#cb613-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb613-4"><a href="#cb613-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb613-5"><a href="#cb613-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb613-6"><a href="#cb613-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb613-7"><a href="#cb613-7" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>some_error_condition<span class="op">)</span></span>
<span id="cb613-8"><a href="#cb613-8" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">goto</span> bail<span class="op">;</span></span>
<span id="cb613-9"><a href="#cb613-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb613-10"><a href="#cb613-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">while</span><span class="op">(...);</span></span>
<span id="cb613-11"><a href="#cb613-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb613-12"><a href="#cb613-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb613-13"><a href="#cb613-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb613-14"><a href="#cb613-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb613-15"><a href="#cb613-15" aria-hidden="true" tabindex="-1"></a>bail<span class="op">:</span></span>
<span id="cb613-16"><a href="#cb613-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Limpieza aquí</span></span></code></pre></div>
<p>Sin <code>goto</code>, tendrías que comprobar una bandera de condición de error en todos los bucles para llegar hasta el final.</p>
<p></p>
<h2 data-number="31.4" id="etiqueta-break"><span class="header-section-number">31.4</span> Etiqueta <code>break</code></h2>
<p></p>
<p>Esta situación es muy similar a la de <code>continue</code>, que sólo continúa el bucle más interno. También <code>break</code> sólo sale del bucle más interno.</p>
<div class="sourceCode" id="cb614"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb614-1"><a href="#cb614-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb614-2"><a href="#cb614-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb614-3"><a href="#cb614-3" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb614-4"><a href="#cb614-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span>   <span class="co">// Sólo sale del bucle j</span></span>
<span id="cb614-5"><a href="#cb614-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb614-6"><a href="#cb614-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb614-7"><a href="#cb614-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb614-8"><a href="#cb614-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Done!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Pero podemos usar <code>goto</code> para ir más lejos:</p>
<div class="sourceCode" id="cb615"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb615-1"><a href="#cb615-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb615-2"><a href="#cb615-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb615-3"><a href="#cb615-3" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb615-4"><a href="#cb615-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">goto</span> break_i<span class="op">;</span>   <span class="co">// ¡Ahora saliendo del bucle i!</span></span>
<span id="cb615-5"><a href="#cb615-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb615-6"><a href="#cb615-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb615-7"><a href="#cb615-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb615-8"><a href="#cb615-8" aria-hidden="true" tabindex="-1"></a>break_i<span class="op">:</span></span>
<span id="cb615-9"><a href="#cb615-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb615-10"><a href="#cb615-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Done!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p></p>
<h2 data-number="31.5" id="limpieza-multinivel"><span class="header-section-number">31.5</span> Limpieza multinivel</h2>
<p></p>
<p>Si estás llamando a varias funciones para inicializar varios sistemas y una de ellas falla, sólo debes desinicializar los que hayas conseguido hasta el momento.</p>
<p>Hagamos un ejemplo falso en el que empezamos a inicializar sistemas y comprobamos si alguno devuelve un error (usaremos <code>-1</code> para indicar un error). Si alguno lo hace, tenemos que apagar sólo los sistemas que hemos inicializado hasta ahora.</p>
<div class="sourceCode" id="cb616"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb616-1"><a href="#cb616-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>init_system_1<span class="op">()</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb616-2"><a href="#cb616-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> shutdown<span class="op">;</span></span>
<span id="cb616-3"><a href="#cb616-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-4"><a href="#cb616-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>init_system_2<span class="op">()</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb616-5"><a href="#cb616-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> shutdown_1<span class="op">;</span></span>
<span id="cb616-6"><a href="#cb616-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-7"><a href="#cb616-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>init_system_3<span class="op">()</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb616-8"><a href="#cb616-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> shutdown_2<span class="op">;</span></span>
<span id="cb616-9"><a href="#cb616-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-10"><a href="#cb616-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>init_system_4<span class="op">()</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb616-11"><a href="#cb616-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> shutdown_3<span class="op">;</span></span>
<span id="cb616-12"><a href="#cb616-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-13"><a href="#cb616-13" aria-hidden="true" tabindex="-1"></a>    do_main_thing<span class="op">();</span>   <span class="co">// Ejecutar nuestro programa</span></span>
<span id="cb616-14"><a href="#cb616-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-15"><a href="#cb616-15" aria-hidden="true" tabindex="-1"></a>    shutdown_system4<span class="op">();</span></span>
<span id="cb616-16"><a href="#cb616-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-17"><a href="#cb616-17" aria-hidden="true" tabindex="-1"></a>shutdown_3<span class="op">:</span></span>
<span id="cb616-18"><a href="#cb616-18" aria-hidden="true" tabindex="-1"></a>    shutdown_system3<span class="op">();</span></span>
<span id="cb616-19"><a href="#cb616-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-20"><a href="#cb616-20" aria-hidden="true" tabindex="-1"></a>shutdown_2<span class="op">:</span></span>
<span id="cb616-21"><a href="#cb616-21" aria-hidden="true" tabindex="-1"></a>    shutdown_system2<span class="op">();</span></span>
<span id="cb616-22"><a href="#cb616-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-23"><a href="#cb616-23" aria-hidden="true" tabindex="-1"></a>shutdown_1<span class="op">:</span></span>
<span id="cb616-24"><a href="#cb616-24" aria-hidden="true" tabindex="-1"></a>    shutdown_system1<span class="op">();</span></span>
<span id="cb616-25"><a href="#cb616-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-26"><a href="#cb616-26" aria-hidden="true" tabindex="-1"></a>shutdown<span class="op">:</span></span>
<span id="cb616-27"><a href="#cb616-27" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;All subsystems shut down.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Ten en cuenta que estamos apagando en el orden inverso al que inicializamos los subsistemas. Así que si el subsistema 4 no arranca, apagará el 3, el 2 y el 1 en ese orden.</p>
<p></p>
<h2 data-number="31.6" id="optimización-de-las-llamadas-de-cola"><span class="header-section-number">31.6</span> Optimización de las llamadas de cola</h2>
<p> </p>
<p>Algo así. Sólo para funciones recursivas.</p>
<p>Si no está familiarizado, <a href="https://en.wikipedia.org/wiki/Tail_call">Optimización de las llamadas de cola (TCO)</a><a href="#fn175" class="footnote-ref" id="fnref175" role="doc-noteref"><sup>175</sup></a> es una forma de no desperdiciar espacio en la pila cuando se llama a otras funciones bajo circunstancias muy específicas. Por desgracia, los detalles están fuera del alcance de esta guía.</p>
<p>Pero si tienes una función recursiva que sabes que puede ser optimizada de esta manera, puedes hacer uso de esta técnica. (Ten en cuenta que no puedes llamar a la cola a otras funciones debido al ámbito de función de las etiquetas).</p>
<p>Hagamos un ejemplo sencillo, factorial.</p>
<p>Aquí hay una versión recursiva que no es TCO, ¡pero puede serlo!</p>
<div class="sourceCode" id="cb617"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb617-1"><a href="#cb617-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb617-2"><a href="#cb617-2"></a><span class="pp">#include </span><span class="im">&lt;complex.h&gt;</span></span>
<span id="cb617-3"><a href="#cb617-3"></a></span>
<span id="cb617-4"><a href="#cb617-4"></a><span class="dt">int</span> factorial<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> a<span class="op">)</span></span>
<span id="cb617-5"><a href="#cb617-5"></a><span class="op">{</span></span>
<span id="cb617-6"><a href="#cb617-6"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb617-7"><a href="#cb617-7"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb617-8"><a href="#cb617-8"></a></span>
<span id="cb617-9"><a href="#cb617-9"></a>    <span class="cf">return</span> factorial<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> a <span class="op">*</span> n<span class="op">);</span></span>
<span id="cb617-10"><a href="#cb617-10"></a><span class="op">}</span></span>
<span id="cb617-11"><a href="#cb617-11"></a></span>
<span id="cb617-12"><a href="#cb617-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb617-13"><a href="#cb617-13"></a><span class="op">{</span></span>
<span id="cb617-14"><a href="#cb617-14"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb617-15"><a href="#cb617-15"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">! == </span><span class="sc">%ld\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> factorial<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb617-16"><a href="#cb617-16"></a><span class="op">}</span></span></code></pre></div>
<p>Para conseguirlo, puedes sustituir la llamada por dos pasos:</p>
<ol type="1">
<li>Establecer los valores de los parámetros a lo que serían en la siguiente llamada.</li>
<li><code>goto</code> una etiqueta en la primera línea de la función.</li>
</ol>
<p>Vamos a probarlo:</p>
<div class="sourceCode" id="cb618"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb618-1"><a href="#cb618-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb618-2"><a href="#cb618-2"></a></span>
<span id="cb618-3"><a href="#cb618-3"></a><span class="dt">int</span> factorial<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> a<span class="op">)</span></span>
<span id="cb618-4"><a href="#cb618-4"></a><span class="op">{</span></span>
<span id="cb618-5"><a href="#cb618-5"></a>tco<span class="op">:</span>  <span class="co">// añade esto</span></span>
<span id="cb618-6"><a href="#cb618-6"></a></span>
<span id="cb618-7"><a href="#cb618-7"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb618-8"><a href="#cb618-8"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb618-9"><a href="#cb618-9"></a></span>
<span id="cb618-10"><a href="#cb618-10"></a>    <span class="co">// sustituir return por la fijación de nuevos valores de los parámetros y</span></span>
<span id="cb618-11"><a href="#cb618-11"></a>    <span class="co">// goto-ando el principio de la función</span></span>
<span id="cb618-12"><a href="#cb618-12"></a>    <span class="co">//return factorial(n - 1, a * n);</span></span>
<span id="cb618-13"><a href="#cb618-13"></a></span>
<span id="cb618-14"><a href="#cb618-14"></a>    <span class="dt">int</span> next_n <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// ¿Ves cómo coinciden con</span></span>
<span id="cb618-15"><a href="#cb618-15"></a>    <span class="dt">int</span> next_n <span class="op">=</span> a <span class="op">*</span> n<span class="op">;</span> <span class="co">// ¿los argumentos recursivos, arriba?</span></span>
<span id="cb618-16"><a href="#cb618-16"></a></span>
<span id="cb618-17"><a href="#cb618-17"></a>    n <span class="op">=</span> next_n<span class="op">;</span>   <span class="co">// Establecer los parámetros a los nuevos valores</span></span>
<span id="cb618-18"><a href="#cb618-18"></a>    a <span class="op">=</span> next_a<span class="op">;</span></span>
<span id="cb618-19"><a href="#cb618-19"></a></span>
<span id="cb618-20"><a href="#cb618-20"></a>    <span class="cf">goto</span> tco<span class="op">;</span>   <span class="co">// y repite!</span></span>
<span id="cb618-21"><a href="#cb618-21"></a><span class="op">}</span></span>
<span id="cb618-22"><a href="#cb618-22"></a></span>
<span id="cb618-23"><a href="#cb618-23"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb618-24"><a href="#cb618-24"></a><span class="op">{</span></span>
<span id="cb618-25"><a href="#cb618-25"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb618-26"><a href="#cb618-26"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">! == </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> factorial<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb618-27"><a href="#cb618-27"></a><span class="op">}</span></span></code></pre></div>
<p>Utilicé variables temporales ahí arriba para establecer los siguientes valores de los parámetros antes de saltar al inicio de la función. ¿Ves cómo corresponden a los argumentos recursivos que estaban en la llamada recursiva?</p>
<p>Ahora bien, ¿por qué usar variables temporales? Podría haber hecho esto en su lugar:</p>
<div class="sourceCode" id="cb619"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb619-1"><a href="#cb619-1" aria-hidden="true" tabindex="-1"></a>    a <span class="op">*=</span> n<span class="op">;</span></span>
<span id="cb619-2"><a href="#cb619-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb619-3"><a href="#cb619-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb619-4"><a href="#cb619-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> tco<span class="op">;</span></span></code></pre></div>
<p>y eso funciona muy bien. Pero si descuidadamente invierto esas dos líneas de código:</p>
<div class="sourceCode" id="cb620"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb620-1"><a href="#cb620-1" aria-hidden="true" tabindex="-1"></a>    n <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// MALAS NOTICIAS</span></span>
<span id="cb620-2"><a href="#cb620-2" aria-hidden="true" tabindex="-1"></a>    a <span class="op">*=</span> n<span class="op">;</span></span></code></pre></div>
<p>—ahora estamos en problemas. Modificamos <code>n</code> antes de usarlo para modificar <code>a</code>. Eso es malo porque no es así como funciona cuando llamas recursivamente. Usar las variables temporales evita este problema incluso si no estás atento a ello. Y el compilador probablemente las optimiza, de todos modos.</p>
<p> </p>
<h2 data-number="31.7" id="reinicio-de-llamadas-al-sistema-interrumpidas"><span class="header-section-number">31.7</span> Reinicio de llamadas al sistema interrumpidas</h2>
<p></p>
<p>Esto está fuera de la especificación, pero se ve comúnmente en sistemas tipo Unix.</p>
<p>Ciertas llamadas al sistema de larga duración pueden devolver un error si son interrumpidas por una señal, y <code>errno</code> será puesto a <code>EINTR</code> para indicar que la llamada al sistema estaba funcionando bien; sólo fue interrumpida.</p>
<p>En esos casos, es muy común que el programador quiera reiniciar la llamada e intentarlo de nuevo.</p>
<div class="sourceCode" id="cb621"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb621-1"><a href="#cb621-1" aria-hidden="true" tabindex="-1"></a>retry<span class="op">:</span></span>
<span id="cb621-2"><a href="#cb621-2" aria-hidden="true" tabindex="-1"></a>    byte_count <span class="op">=</span> read<span class="op">(</span><span class="dv">0</span><span class="op">,</span> buf<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>buf<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span>  <span class="co">// Llamada al sistema Unix read()</span></span>
<span id="cb621-3"><a href="#cb621-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb621-4"><a href="#cb621-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>byte_count <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span>            <span class="co">// Se ha producido un error...</span></span>
<span id="cb621-5"><a href="#cb621-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>errno <span class="op">==</span> EINTR<span class="op">)</span> <span class="op">{</span>          <span class="co">// Pero sólo fue interrumpido</span></span>
<span id="cb621-6"><a href="#cb621-6" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;Restarting...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb621-7"><a href="#cb621-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">goto</span> retry<span class="op">;</span></span>
<span id="cb621-8"><a href="#cb621-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p>Muchos Unix-likes tienen una bandera <code>SA_RESTART</code> que puede pasar a <code>sigaction()</code> para solicitar al SO que reinicie automáticamente cualquier syscall lenta en lugar de fallar con <code>EINTR</code>.</p>
<p>De nuevo, esto es específico de Unix y está fuera del estándar C.</p>
<p>Dicho esto, es posible usar una técnica similar cada vez que cualquier función deba ser reiniciada.</p>
<p></p>
<h2 data-number="31.8" id="goto-y-el-hilo-conductor-preferente-thread-preemption"><span class="header-section-number">31.8</span> <code>goto</code> y el Hilo conductor preferente (Thread Preemption)</h2>
<p></p>
<p>Este ejemplo está extraído directamente de <a href="http://www.ostep.org/"><em>Sistemas operativos: Tres piezas fáciles</em></a>, otro excelente libro de autores con ideas afines que también consideran que los libros de calidad deben poder descargarse gratuitamente. No es que sea un testarudo, ni nada por el estilo.</p>
<div class="sourceCode" id="cb622"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb622-1"><a href="#cb622-1" aria-hidden="true" tabindex="-1"></a>retry<span class="op">:</span></span>
<span id="cb622-2"><a href="#cb622-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb622-3"><a href="#cb622-3" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_lock<span class="op">(</span>L1<span class="op">);</span></span>
<span id="cb622-4"><a href="#cb622-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb622-5"><a href="#cb622-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pthread_mutex_trylock<span class="op">(</span>L2<span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb622-6"><a href="#cb622-6" aria-hidden="true" tabindex="-1"></a>        pthread_mutex_unlock<span class="op">(</span>L1<span class="op">);</span></span>
<span id="cb622-7"><a href="#cb622-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> retry<span class="op">;</span></span>
<span id="cb622-8"><a href="#cb622-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb622-9"><a href="#cb622-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb622-10"><a href="#cb622-10" aria-hidden="true" tabindex="-1"></a>    save_the_day<span class="op">();</span></span>
<span id="cb622-11"><a href="#cb622-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb622-12"><a href="#cb622-12" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_unlock<span class="op">(</span>L2<span class="op">);</span></span>
<span id="cb622-13"><a href="#cb622-13" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_unlock<span class="op">(</span>L1<span class="op">);</span></span></code></pre></div>
<p>Allí el hilo adquiere felizmente el mutex <code>L1</code>, pero entonces falla potencialmente en conseguir el segundo recurso custodiado por el mutex <code>L2</code> (si algún otro hilo no cooperativo lo tiene, digamos). Si nuestro hilo no puede conseguir el bloqueo <code>L2</code>, desbloquea <code>L1</code> y usa <code>goto</code> para reintentarlo limpiamente.</p>
<p>Esperamos que nuestra heroica hebra consiga finalmente adquirir ambos mutexes y salvar el día, todo ello evitando el malvado punto muerto.</p>
<p></p>
<h2 data-number="31.9" id="goto-y-el-ámbito-de-las-variables"><span class="header-section-number">31.9</span> <code>goto</code> y el ámbito de las variables</h2>
<p></p>
<p>Ya hemos visto que las etiquetas tienen ámbito de función, pero pueden ocurrir cosas raras si saltamos más allá de la inicialización de alguna variable.</p>
<p>Mira este ejemplo en el que saltamos de un lugar en el que la variable <code>x</code> está fuera de ámbito a la mitad de su ámbito (en el bloque).</p>
<div class="sourceCode" id="cb623"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb623-1"><a href="#cb623-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> label<span class="op">;</span></span>
<span id="cb623-2"><a href="#cb623-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb623-3"><a href="#cb623-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb623-4"><a href="#cb623-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x <span class="op">=</span> <span class="dv">12345</span><span class="op">;</span></span>
<span id="cb623-5"><a href="#cb623-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb623-6"><a href="#cb623-6" aria-hidden="true" tabindex="-1"></a>label<span class="op">:</span></span>
<span id="cb623-7"><a href="#cb623-7" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb623-8"><a href="#cb623-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Esto compilará y ejecutará, pero me da una advertencia:</p>
<div class="sourceCode" id="cb624"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb624-1"><a href="#cb624-1" aria-hidden="true" tabindex="-1"></a>warning: ‘x’ is used uninitialized in this function</span></code></pre></div>
<p>Y luego imprime <code>0</code> cuando lo ejecuto (su kilometraje puede variar).</p>
<p>Básicamente lo que ha pasado es que hemos saltado al ámbito de <code>x</code> (así que estaba bien referenciarlo en <code>printf()</code>) pero hemos saltado la línea que realmente lo inicializaba a <code>12345</code>. Así que el valor era indeterminado.</p>
<p>La solución es, por supuesto, obtener la inicialización <em>después</em> de la etiqueta de una forma u otra.</p>
<div class="sourceCode" id="cb625"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb625-1"><a href="#cb625-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> label<span class="op">;</span></span>
<span id="cb625-2"><a href="#cb625-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb625-3"><a href="#cb625-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb625-4"><a href="#cb625-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb625-5"><a href="#cb625-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb625-6"><a href="#cb625-6" aria-hidden="true" tabindex="-1"></a>label<span class="op">:</span></span>
<span id="cb625-7"><a href="#cb625-7" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="dv">12345</span><span class="op">;</span></span>
<span id="cb625-8"><a href="#cb625-8" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb625-9"><a href="#cb625-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Veamos un ejemplo más.</p>
<div class="sourceCode" id="cb626"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb626-1"><a href="#cb626-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb626-2"><a href="#cb626-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb626-3"><a href="#cb626-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb626-4"><a href="#cb626-4" aria-hidden="true" tabindex="-1"></a>label<span class="op">:</span></span>
<span id="cb626-5"><a href="#cb626-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb626-6"><a href="#cb626-6" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb626-7"><a href="#cb626-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb626-8"><a href="#cb626-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb626-9"><a href="#cb626-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> label<span class="op">;</span></span></code></pre></div>
<p>¿Qué pasa aquí?</p>
<p>La primera vez a través del bloque, estamos bien. <code>x</code> es <code>10</code> y eso es lo que se imprime.</p>
<p>Pero después del <code>goto</code>, saltamos al ámbito de <code>x</code>, pero después de su inicialización. Lo que significa que aún podemos imprimirlo, pero el valor es indeterminado (ya que no ha sido reinicializado).</p>
<p>En mi máquina, imprime <code>10</code> de nuevo (hasta el infinito), pero eso es sólo suerte. Podría imprimir cualquier valor después del <code>goto</code> ya que <code>x</code> no está inicializado.</p>
<p></p>
<h2 data-number="31.10" id="goto-y-matrices-de-longitud-variable-variable-length-arrays"><span class="header-section-number">31.10</span> <code>goto</code> y matrices de longitud variable (Variable-Length Arrays)</h2>
<p></p>
<p>Cuando se trata de VLAs y <code>goto</code>, hay una regla: no se puede saltar desde fuera del ámbito de un VLA al ámbito de ese VLA.</p>
<p>Si intento hacer esto:</p>
<div class="sourceCode" id="cb627"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb627-1"><a href="#cb627-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb627-2"><a href="#cb627-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb627-3"><a href="#cb627-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> label<span class="op">;</span></span>
<span id="cb627-4"><a href="#cb627-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb627-5"><a href="#cb627-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb627-6"><a href="#cb627-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb627-7"><a href="#cb627-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb627-8"><a href="#cb627-8" aria-hidden="true" tabindex="-1"></a>label<span class="op">:</span></span>
<span id="cb627-9"><a href="#cb627-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb627-10"><a href="#cb627-10" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Hi!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb627-11"><a href="#cb627-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Me aparece un error:</p>
<div class="sourceCode" id="cb628"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb628-1"><a href="#cb628-1" aria-hidden="true" tabindex="-1"></a>error: jump into scope of identifier with variably modified type</span></code></pre></div>
<p>Puede adelantarse así a la declaración del VLA:</p>
<div class="sourceCode" id="cb629"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb629-1"><a href="#cb629-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb629-2"><a href="#cb629-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-3"><a href="#cb629-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> label<span class="op">;</span></span>
<span id="cb629-4"><a href="#cb629-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-5"><a href="#cb629-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb629-6"><a href="#cb629-6" aria-hidden="true" tabindex="-1"></a>label<span class="op">:</span>  <span class="op">;</span></span>
<span id="cb629-7"><a href="#cb629-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb629-8"><a href="#cb629-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-9"><a href="#cb629-9" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Hi!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb629-10"><a href="#cb629-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Porque de ese modo el VLA se asigna correctamente antes de su inevitable desasignación una vez que queda fuera del ámbito de aplicación.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="32" id="tipos-parte-v-literales-compuestos-y-selecciones-genéricas"><span class="header-section-number">32</span> Tipos Parte V: Literales compuestos y selecciones genéricas</h1>
<p>Este es el capítulo final de los tipos. Hablaremos de dos cosas:</p>
<ul>
<li>Cómo tener objetos “anónimos” sin nombre y cómo eso es útil.</li>
<li>Cómo generar código dependiente del tipo.</li>
</ul>
<p>No están particularmente relacionados, pero realmente no merecen cada uno su propio capítulo. Así que los he metido aquí como un rebelde.</p>
<h2 data-number="32.1" id="literales-compuestos"><span class="header-section-number">32.1</span> Literales compuestos</h2>
<p></p>
<p>Esta es una característica del lenguaje que te permite crear un objeto de algún tipo sobre la marcha sin tener que asignarlo a una variable. Puedes crear tipos simples, arrays, <code>struct</code>s, lo que quieras.</p>
<p>Uno de los principales usos de esto es pasar argumentos complejos a funciones cuando no quieres crear una variable temporal para mantener el valor.</p>
<p>La forma de crear un literal compuesto es poner el nombre del tipo entre paréntesis, y después poner una lista inicializadora. Por ejemplo, un array sin nombre de <code>int</code>s, podría tener este aspecto:</p>
<div class="sourceCode" id="cb630"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb630-1"><a href="#cb630-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="dt">int</span> <span class="op">[]){</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">}</span></span></code></pre></div>
<p>Ahora, esa línea de código no hace nada por sí misma. Crea un array sin nombre de 4 <code>int</code>s, y luego los tira sin usarlos.</p>
<p>Podríamos usar un puntero para almacenar una referencia al array…</p>
<div class="sourceCode" id="cb631"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb631-1"><a href="#cb631-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">[]){</span><span class="dv">1</span> <span class="op">,</span><span class="dv">2</span> <span class="op">,</span><span class="dv">3</span> <span class="op">,</span><span class="dv">4</span><span class="op">};</span></span>
<span id="cb631-2"><a href="#cb631-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb631-3"><a href="#cb631-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">[</span><span class="dv">1</span><span class="op">]);</span>  <span class="co">// 2</span></span></code></pre></div>
<p>Pero eso parece una forma un poco prolija de tener una matriz. Quiero decir, podríamos haber hecho esto<a href="#fn176" class="footnote-ref" id="fnref176" role="doc-noteref"><sup>176</sup></a>:</p>
<div class="sourceCode" id="cb632"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb632-1"><a href="#cb632-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> p<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb632-2"><a href="#cb632-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-3"><a href="#cb632-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">[</span><span class="dv">1</span><span class="op">]);</span>  <span class="co">// 2</span></span></code></pre></div>
<p>Así que veamos un ejemplo más útil.</p>
<h3 data-number="32.1.1" id="pasando-objetos-sin-nombre-a-funciones"><span class="header-section-number">32.1.1</span> Pasando Objetos sin Nombre a Funciones</h3>
<p></p>
<p>Digamos que tenemos una función para sumar un array de <code>int</code>s:</p>
<div class="sourceCode" id="cb633"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb633-1"><a href="#cb633-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="dt">int</span> p<span class="op">[],</span> <span class="dt">int</span> count<span class="op">)</span></span>
<span id="cb633-2"><a href="#cb633-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb633-3"><a href="#cb633-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb633-4"><a href="#cb633-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb633-5"><a href="#cb633-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> count<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb633-6"><a href="#cb633-6" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> p<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb633-7"><a href="#cb633-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb633-8"><a href="#cb633-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb633-9"><a href="#cb633-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Si quisiéramos llamarla, normalmente tendríamos que hacer algo como esto, declarando un array y almacenando valores en él para pasárselos a la función:</p>
<div class="sourceCode" id="cb634"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb634-1"><a href="#cb634-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb634-2"><a href="#cb634-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb634-3"><a href="#cb634-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> s <span class="op">=</span> sum<span class="op">(</span>a<span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span></code></pre></div>
<p>Pero los objetos sin nombre nos dan una forma de saltarnos la variable pasándola directamente (nombres de parámetros listados arriba). Compruébalo: vamos a sustituir la variable “a” por una matriz sin nombre que pasaremos como primer argumento:</p>
<div class="sourceCode" id="cb635"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb635-1"><a href="#cb635-1" aria-hidden="true" tabindex="-1"></a><span class="co">//                   p[]         count</span></span>
<span id="cb635-2"><a href="#cb635-2" aria-hidden="true" tabindex="-1"></a><span class="co">//           |-----------------|  |</span></span>
<span id="cb635-3"><a href="#cb635-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> s <span class="op">=</span> sum<span class="op">((</span><span class="dt">int</span> <span class="op">[]){</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span> <span class="dv">4</span><span class="op">);</span></span></code></pre></div>
<p>¡Muy hábil!</p>
<p></p>
<h3 data-number="32.1.2" id="structs-sin-nombre"><span class="header-section-number">32.1.2</span> <code>struct</code>s sin nombre</h3>
<p> </p>
<p>Podemos hacer algo parecido con <code>struct</code>s.</p>
<p>Primero, hagamos las cosas sin objetos sin nombre. Definiremos una <code>struct</code> para contener algunas coordenadas <code>x</code>/<code>y</code>. Luego definiremos una, pasando valores a su inicializador. Finalmente, lo pasaremos a una función para imprimir los valores:</p>
<div class="sourceCode" id="cb636"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb636-1"><a href="#cb636-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb636-2"><a href="#cb636-2"></a></span>
<span id="cb636-3"><a href="#cb636-3"></a><span class="kw">struct</span> coord <span class="op">{</span></span>
<span id="cb636-4"><a href="#cb636-4"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb636-5"><a href="#cb636-5"></a><span class="op">};</span></span>
<span id="cb636-6"><a href="#cb636-6"></a></span>
<span id="cb636-7"><a href="#cb636-7"></a><span class="dt">void</span> print_coord<span class="op">(</span><span class="kw">struct</span> coord c<span class="op">)</span></span>
<span id="cb636-8"><a href="#cb636-8"></a><span class="op">{</span></span>
<span id="cb636-9"><a href="#cb636-9"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">.</span>x<span class="op">,</span> c<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb636-10"><a href="#cb636-10"></a><span class="op">}</span></span>
<span id="cb636-11"><a href="#cb636-11"></a></span>
<span id="cb636-12"><a href="#cb636-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb636-13"><a href="#cb636-13"></a><span class="op">{</span></span>
<span id="cb636-14"><a href="#cb636-14"></a>    <span class="kw">struct</span> coord t <span class="op">=</span> <span class="op">{.</span>x<span class="op">=</span><span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y<span class="op">=</span><span class="dv">20</span><span class="op">};</span></span>
<span id="cb636-15"><a href="#cb636-15"></a></span>
<span id="cb636-16"><a href="#cb636-16"></a>    print_coord<span class="op">(</span>t<span class="op">);</span>   <span class="co">// prints &quot;10, 20&quot;</span></span>
<span id="cb636-17"><a href="#cb636-17"></a><span class="op">}</span></span></code></pre></div>
<p>¿Suficientemente sencillo?</p>
<p>Vamos a modificarlo para utilizar un objeto sin nombre en lugar de la variable <code>t</code> que estamos pasando a <code>print_coord()</code>.</p>
<p>Quitaremos <code>t</code> y la sustituiremos por una <code>struct</code> sin nombre:</p>
<div class="sourceCode" id="cb637" data-startFrom="7"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 6;"><span id="cb637-7"><a href="#cb637-7"></a>    <span class="op">/</span>estructurar coord t <span class="op">=</span> <span class="op">{.</span>x<span class="op">=</span><span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y<span class="op">=</span><span class="dv">20</span><span class="op">};</span></span>
<span id="cb637-8"><a href="#cb637-8"></a></span>
<span id="cb637-9"><a href="#cb637-9"></a>    print_coord<span class="op">((</span><span class="kw">struct</span> coord<span class="op">){.</span>x<span class="op">=</span><span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y<span class="op">=</span><span class="dv">20</span><span class="op">});</span>   <span class="co">// Imprime &quot;10, 20&quot;</span></span></code></pre></div>
<p>¡Todavía funciona!</p>
<p> </p>
<h3 data-number="32.1.3" id="punteros-a-objetos-sin-nombre"><span class="header-section-number">32.1.3</span> Punteros a objetos sin nombre</h3>
<p></p>
<p>Puede que hayas notado en el último ejemplo que, aunque estábamos usando una <code>struct</code>, estábamos pasando una copia de la <code>struct</code> a <code>print_coord()</code> en lugar de pasar un puntero a la <code>struct</code>.</p>
<p>Resulta que podemos tomar la dirección de un objeto sin nombre con <code>&amp;</code> como siempre.</p>
<p>Esto es porque, en general, si un operador hubiera funcionado en una variable de ese tipo, puedes usar ese operador en un objeto sin nombre de ese tipo.</p>
<p>Modifiquemos el código anterior para que pasemos un puntero a un objeto sin nombre</p>
<div class="sourceCode" id="cb638"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb638-1"><a href="#cb638-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb638-2"><a href="#cb638-2"></a></span>
<span id="cb638-3"><a href="#cb638-3"></a><span class="kw">struct</span> coord <span class="op">{</span></span>
<span id="cb638-4"><a href="#cb638-4"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb638-5"><a href="#cb638-5"></a><span class="op">};</span></span>
<span id="cb638-6"><a href="#cb638-6"></a></span>
<span id="cb638-7"><a href="#cb638-7"></a><span class="dt">void</span> print_coord<span class="op">(</span><span class="kw">struct</span> coord <span class="op">*</span>c<span class="op">)</span></span>
<span id="cb638-8"><a href="#cb638-8"></a><span class="op">{</span></span>
<span id="cb638-9"><a href="#cb638-9"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> c<span class="op">-&gt;</span>x<span class="op">,</span> c<span class="op">-&gt;</span>y<span class="op">);</span></span>
<span id="cb638-10"><a href="#cb638-10"></a><span class="op">}</span></span>
<span id="cb638-11"><a href="#cb638-11"></a></span>
<span id="cb638-12"><a href="#cb638-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb638-13"><a href="#cb638-13"></a><span class="op">{</span></span>
<span id="cb638-14"><a href="#cb638-14"></a>    <span class="co">// Nota el &amp;</span></span>
<span id="cb638-15"><a href="#cb638-15"></a>    <span class="co">//          |</span></span>
<span id="cb638-16"><a href="#cb638-16"></a>    print_coord<span class="op">(&amp;(</span><span class="kw">struct</span> coord<span class="op">){.</span>x<span class="op">=</span><span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y<span class="op">=</span><span class="dv">20</span><span class="op">});</span>   <span class="co">// Imprime &quot;10, 20&quot;</span></span>
<span id="cb638-17"><a href="#cb638-17"></a><span class="op">}</span></span></code></pre></div>
<p>Además, esto puede ser una buena manera de pasar incluso punteros a objetos simples:</p>
<div class="sourceCode" id="cb639"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb639-1"><a href="#cb639-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Pasa un puntero a un int con valor 3490</span></span>
<span id="cb639-2"><a href="#cb639-2" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(&amp;(</span><span class="dt">int</span><span class="op">){</span><span class="dv">3490</span><span class="op">});</span></span></code></pre></div>
<p>Así de fácil.</p>
<p></p>
<h3 data-number="32.1.4" id="objetos-sin-nombre-y-alcance"><span class="header-section-number">32.1.4</span> Objetos sin nombre y alcance</h3>
<p></p>
<p>El tiempo de vida de un objeto sin nombre termina al final de su ámbito. La forma más grave de que esto ocurra es si creas un nuevo objeto sin nombre, obtienes un puntero a él y luego abandonas el ámbito del objeto. En ese caso, el puntero se referirá a un objeto muerto.</p>
<p>Esto es un comportamiento indefinido:</p>
<div class="sourceCode" id="cb640"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb640-1"><a href="#cb640-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb640-2"><a href="#cb640-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb640-3"><a href="#cb640-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb640-4"><a href="#cb640-4" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="op">&amp;(</span><span class="dt">int</span><span class="op">){</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb640-5"><a href="#cb640-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb640-6"><a href="#cb640-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb640-7"><a href="#cb640-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// INVÁLIDO: El (int){10} se ha salido de ámbito</span></span></code></pre></div>
<p>Del mismo modo, no se puede devolver un puntero a un objeto sin nombre desde una función. El objeto se desasigna cuando sale del ámbito:</p>
<div class="sourceCode" id="cb641"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb641-1"><a href="#cb641-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb641-2"><a href="#cb641-2"></a></span>
<span id="cb641-3"><a href="#cb641-3"></a><span class="dt">int</span> <span class="op">*</span>get3490<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb641-4"><a href="#cb641-4"></a><span class="op">{</span></span>
<span id="cb641-5"><a href="#cb641-5"></a>    <span class="co">// No hagas esto</span></span>
<span id="cb641-6"><a href="#cb641-6"></a>    <span class="cf">return</span> <span class="op">&amp;(</span><span class="dt">int</span><span class="op">){</span><span class="dv">3490</span><span class="op">};</span></span>
<span id="cb641-7"><a href="#cb641-7"></a><span class="op">}</span></span>
<span id="cb641-8"><a href="#cb641-8"></a></span>
<span id="cb641-9"><a href="#cb641-9"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb641-10"><a href="#cb641-10"></a><span class="op">{</span></span>
<span id="cb641-11"><a href="#cb641-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>get3490<span class="op">());</span>  <span class="co">// INVALID: (int){3490} cayó fuera de ámbito</span></span>
<span id="cb641-12"><a href="#cb641-12"></a><span class="op">}</span></span></code></pre></div>
<p>Piense en su alcance como en el de una variable local normal. Tampoco puedes devolver un puntero a una variable local.</p>
<p></p>
<h3 data-number="32.1.5" id="ejemplo-tonto-de-objeto-sin-nombre"><span class="header-section-number">32.1.5</span> Ejemplo tonto de objeto sin nombre</h3>
<p>Puedes poner cualquier tipo y hacer un objeto sin nombre.</p>
<p>Por ejemplo, estos son efectivamente equivalentes:</p>
<div class="sourceCode" id="cb642"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb642-1"><a href="#cb642-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb642-2"><a href="#cb642-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb642-3"><a href="#cb642-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>               <span class="co">// 3490 (variable)</span></span>
<span id="cb642-4"><a href="#cb642-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">3490</span><span class="op">);</span>            <span class="co">// 3490 (constant)</span></span>
<span id="cb642-5"><a href="#cb642-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span><span class="dt">int</span><span class="op">){</span><span class="dv">3490</span><span class="op">});</span>     <span class="co">// 3490 (unnamed object)</span></span></code></pre></div>
<p>Esto último no tiene nombre, pero es una tontería. También podría hacer el simple en la línea anterior.</p>
<p>Pero espero que proporciona un poco más de claridad en la sintaxis.</p>
<p></p>
<h2 data-number="32.2" id="type-generics"><span class="header-section-number">32.2</span> Selecciones genéricas</h2>
<p></p>
<p>Se trata de una expresión que permite seleccionar diferentes fragmentos de código en función del <em>tipo</em> del primer argumento de la expresión.</p>
<p>Veremos un ejemplo en un segundo, pero es importante saber que esto se procesa en tiempo de compilación, <em>no en tiempo de ejecución</em>. No hay ningún análisis en tiempo de ejecución. </p>
<p>La expresión empieza por <code>_Generic</code>, funciona como un <code>switch</code>, y toma al menos dos argumentos</p>
<p>El primer argumento es una expresión (o variable<a href="#fn177" class="footnote-ref" id="fnref177" role="doc-noteref"><sup>177</sup></a>) que tiene un <em>tipo</em>. Todas las expresiones tienen un tipo. El resto de argumentos de <code>_Generic</code> son los casos, de qué sustituir en el resultado de la expresión, si el primer argumento es de ese tipo.</p>
<p>¿Qué?</p>
<p>Probemos a ver.</p>
<div class="sourceCode" id="cb643"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb643-1"><a href="#cb643-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb643-2"><a href="#cb643-2"></a></span>
<span id="cb643-3"><a href="#cb643-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb643-4"><a href="#cb643-4"></a><span class="op">{</span></span>
<span id="cb643-5"><a href="#cb643-5"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb643-6"><a href="#cb643-6"></a>    <span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb643-7"><a href="#cb643-7"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb643-8"><a href="#cb643-8"></a></span>
<span id="cb643-9"><a href="#cb643-9"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="dt">_Generic</span><span class="op">(</span>i<span class="op">,</span></span>
<span id="cb643-10"><a href="#cb643-10"></a>                    <span class="dt">int</span><span class="op">:</span> <span class="st">&quot;that variable is an int&quot;</span><span class="op">,</span></span>
<span id="cb643-11"><a href="#cb643-11"></a>                    <span class="dt">float</span><span class="op">:</span> <span class="st">&quot;that variable is a float&quot;</span><span class="op">,</span></span>
<span id="cb643-12"><a href="#cb643-12"></a>                    <span class="cf">default</span><span class="op">:</span> <span class="st">&quot;that variable is some type&quot;</span></span>
<span id="cb643-13"><a href="#cb643-13"></a>                <span class="op">);</span></span>
<span id="cb643-14"><a href="#cb643-14"></a></span>
<span id="cb643-15"><a href="#cb643-15"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span></span>
<span id="cb643-16"><a href="#cb643-16"></a><span class="op">}</span></span></code></pre></div>
<p>Fíjate en la expresión <code>_Generic</code> que empieza en la línea 9.</p>
<p>Cuando el compilador la ve, mira el tipo del primer argumento. (En este ejemplo, el tipo de la variable <code>i</code>.) Luego busca en los casos algo de ese tipo. Y entonces sustituye el argumento en lugar de toda la expresión <code>_Generic</code>.</p>
<p>En este caso, <code>i</code> es un <code>int</code>, por lo que coincide con ese caso. Entonces la cadena es sustituida por la expresión. Así que la línea se convierte en esto cuando el compilador lo ve:</p>
<div class="sourceCode" id="cb644"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb644-1"><a href="#cb644-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;that variable is an int&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Si el compilador no puede encontrar una coincidencia de tipo en <code>_Generic</code>, busca el caso opcional <code>default</code> y lo utiliza.</p>
<p>Si no puede encontrar una coincidencia de tipo y no hay “default”, obtendrá un error de compilación. error de compilación. La primera expresión <strong>debe</strong> coincidir con uno de los tipos o con <code>default</code>.</p>
<p>Como es inconveniente escribir <code>_Generic</code> una y otra vez, se usa a menudo para hacer el cuerpo de una macro que pueda ser fácilmente reutilizada repetidamente.</p>
<p>Hagamos una macro <code>TYPESTR(x)</code> que toma un argumento y devuelve una cadena con el tipo del argumento.</p>
<p>Así, <code>TYPESTR(1)</code> devolverá la cadena <code>"int"</code>, por ejemplo.</p>
<p>Allá vamos:</p>
<div class="sourceCode" id="cb645"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb645-1"><a href="#cb645-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb645-2"><a href="#cb645-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb645-3"><a href="#cb645-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TYPESTR</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="dt">_Generic</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb645-4"><a href="#cb645-4" aria-hidden="true" tabindex="-1"></a><span class="pp">                        </span><span class="dt">int</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;int&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb645-5"><a href="#cb645-5" aria-hidden="true" tabindex="-1"></a><span class="pp">                        </span><span class="dt">long</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;long&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb645-6"><a href="#cb645-6" aria-hidden="true" tabindex="-1"></a><span class="pp">                        </span><span class="dt">float</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;float&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb645-7"><a href="#cb645-7" aria-hidden="true" tabindex="-1"></a><span class="pp">                        </span><span class="dt">double</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;double&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb645-8"><a href="#cb645-8" aria-hidden="true" tabindex="-1"></a><span class="pp">                        </span><span class="cf">default</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;something else&quot;</span><span class="op">)</span></span>
<span id="cb645-9"><a href="#cb645-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb645-10"><a href="#cb645-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb645-11"><a href="#cb645-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb645-12"><a href="#cb645-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb645-13"><a href="#cb645-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> l<span class="op">;</span></span>
<span id="cb645-14"><a href="#cb645-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb645-15"><a href="#cb645-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d<span class="op">;</span></span>
<span id="cb645-16"><a href="#cb645-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb645-17"><a href="#cb645-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb645-18"><a href="#cb645-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> TYPESTR<span class="op">(</span>i<span class="op">));</span></span>
<span id="cb645-19"><a href="#cb645-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;l is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> TYPESTR<span class="op">(</span>l<span class="op">));</span></span>
<span id="cb645-20"><a href="#cb645-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;f is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> TYPESTR<span class="op">(</span>f<span class="op">));</span></span>
<span id="cb645-21"><a href="#cb645-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;d is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> TYPESTR<span class="op">(</span>d<span class="op">));</span></span>
<span id="cb645-22"><a href="#cb645-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;c is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> TYPESTR<span class="op">(</span>c<span class="op">));</span></span>
<span id="cb645-23"><a href="#cb645-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Estas salidas:</p>
<div class="sourceCode" id="cb646"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb646-1"><a href="#cb646-1" aria-hidden="true" tabindex="-1"></a>i is type int</span>
<span id="cb646-2"><a href="#cb646-2" aria-hidden="true" tabindex="-1"></a>l is type long</span>
<span id="cb646-3"><a href="#cb646-3" aria-hidden="true" tabindex="-1"></a>f is type float</span>
<span id="cb646-4"><a href="#cb646-4" aria-hidden="true" tabindex="-1"></a>d is type double</span>
<span id="cb646-5"><a href="#cb646-5" aria-hidden="true" tabindex="-1"></a>c is type something else</span></code></pre></div>
<p>Lo cual no debería sorprender, porque, como dijimos, ese código en <code>main()</code> es reemplazado por lo siguiente cuando se compila:</p>
<div class="sourceCode" id="cb647"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb647-1"><a href="#cb647-1" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;i is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;int&quot;</span><span class="op">);</span></span>
<span id="cb647-2"><a href="#cb647-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;l is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;long&quot;</span><span class="op">);</span></span>
<span id="cb647-3"><a href="#cb647-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;f is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;float&quot;</span><span class="op">);</span></span>
<span id="cb647-4"><a href="#cb647-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;d is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;double&quot;</span><span class="op">);</span></span>
<span id="cb647-5"><a href="#cb647-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;c is type </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;something else&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Y esa es exactamente la salida que vemos.</p>
<p>Vamos a hacer una más. He incluido algunas macros aquí para que cuando se ejecuta:</p>
<div class="sourceCode" id="cb648"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb648-1"><a href="#cb648-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb648-2"><a href="#cb648-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Foo!&quot;</span><span class="op">;</span></span>
<span id="cb648-3"><a href="#cb648-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb648-4"><a href="#cb648-4" aria-hidden="true" tabindex="-1"></a>PRINT_VAL<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb648-5"><a href="#cb648-5" aria-hidden="true" tabindex="-1"></a>PRINT_VAL<span class="op">(</span>s<span class="op">);</span></span></code></pre></div>
<p>se obtiene la salida:</p>
<div class="sourceCode" id="cb649"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb649-1"><a href="#cb649-1" aria-hidden="true" tabindex="-1"></a>i = 10</span>
<span id="cb649-2"><a href="#cb649-2" aria-hidden="true" tabindex="-1"></a>s = Foo!</span></code></pre></div>
<p>Para ello tendremos que recurrir a la magia de las macros.</p>
<div class="sourceCode" id="cb650"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb650-1"><a href="#cb650-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb650-2"><a href="#cb650-2"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb650-3"><a href="#cb650-3"></a></span>
<span id="cb650-4"><a href="#cb650-4"></a><span class="co">// Macro que devuelve un especificador de formato para un tipo</span></span>
<span id="cb650-5"><a href="#cb650-5"></a><span class="pp">#define FMTSPEC</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="dt">_Generic</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-6"><a href="#cb650-6"></a><span class="pp">                        </span><span class="dt">int</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-7"><a href="#cb650-7"></a><span class="pp">                        </span><span class="dt">long</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;</span><span class="sc">%ld</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-8"><a href="#cb650-8"></a><span class="pp">                        </span><span class="dt">float</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;</span><span class="sc">%f</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-9"><a href="#cb650-9"></a><span class="pp">                        </span><span class="dt">double</span><span class="op">:</span><span class="pp"> </span><span class="st">&quot;</span><span class="sc">%f</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-10"><a href="#cb650-10"></a><span class="pp">                        </span><span class="dt">char</span><span class="pp"> </span><span class="op">*:</span><span class="pp"> </span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb650-11"><a href="#cb650-11"></a>                        <span class="co">// </span><span class="al">TODO</span><span class="co">: add more types</span></span>
<span id="cb650-12"><a href="#cb650-12"></a>                        </span>
<span id="cb650-13"><a href="#cb650-13"></a><span class="co">// Macro que imprime una variable de la forma &quot;nombre = valor&quot;</span></span>
<span id="cb650-14"><a href="#cb650-14"></a><span class="pp">#define PRINT_VAL</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="cf">do</span><span class="pp"> </span><span class="op">{</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-15"><a href="#cb650-15"></a><span class="pp">    </span><span class="dt">char</span><span class="pp"> fmt</span><span class="op">[</span><span class="dv">512</span><span class="op">];</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-16"><a href="#cb650-16"></a><span class="pp">    snprintf</span><span class="op">(</span><span class="pp">fmt</span><span class="op">,</span><span class="pp"> </span><span class="kw">sizeof</span><span class="pp"> fmt</span><span class="op">,</span><span class="pp"> </span><span class="op">#</span><span class="pp">x </span><span class="st">&quot; = </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span><span class="pp"> FMTSPEC</span><span class="op">(</span><span class="pp">x</span><span class="op">));</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-17"><a href="#cb650-17"></a><span class="pp">    printf</span><span class="op">(</span><span class="pp">fmt</span><span class="op">,</span><span class="pp"> </span><span class="op">(</span><span class="pp">x</span><span class="op">));</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb650-18"><a href="#cb650-18"></a><span class="op">}</span><span class="pp"> </span><span class="cf">while</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb650-19"><a href="#cb650-19"></a></span>
<span id="cb650-20"><a href="#cb650-20"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb650-21"><a href="#cb650-21"></a><span class="op">{</span></span>
<span id="cb650-22"><a href="#cb650-22"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb650-23"><a href="#cb650-23"></a>    <span class="dt">float</span> f <span class="op">=</span> <span class="fl">3.14159</span><span class="op">;</span></span>
<span id="cb650-24"><a href="#cb650-24"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb650-25"><a href="#cb650-25"></a></span>
<span id="cb650-26"><a href="#cb650-26"></a>    PRINT_VAL<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb650-27"><a href="#cb650-27"></a>    PRINT_VAL<span class="op">(</span>f<span class="op">);</span></span>
<span id="cb650-28"><a href="#cb650-28"></a>    PRINT_VAL<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb650-29"><a href="#cb650-29"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>para la salida:</p>
<div class="sourceCode" id="cb651"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb651-1"><a href="#cb651-1" aria-hidden="true" tabindex="-1"></a>i = 10</span>
<span id="cb651-2"><a href="#cb651-2" aria-hidden="true" tabindex="-1"></a>f = 3.141590</span>
<span id="cb651-3"><a href="#cb651-3" aria-hidden="true" tabindex="-1"></a>s = Hello, world!</span></code></pre></div>
<p>Podríamos haberlo metido todo en una gran macro, pero lo dividí en dos para evitar el sangrado de los ojos.</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="33" id="matrices-parte-ii"><span class="header-section-number">33</span> Matrices Parte II</h1>
<p>En este capítulo vamos a repasar algunas cosas extra relacionadas con los arrays.</p>
<ul>
<li>Calificadores de tipo con parámetros de arrays</li>
<li>La palabra clave <code>static</code> con parámetros de arrays</li>
<li>Inicializadores parciales de arrays multidimensionales</li>
</ul>
<p>No son muy comunes, pero los veremos ya que son parte de la nueva especificación.</p>
<h2 data-number="33.1" id="calificadores-de-tipo-para-matrices-en-listas-de-parámetros"><span class="header-section-number">33.1</span> Calificadores de tipo para matrices en listas de parámetros</h2>
<p> </p>
<p>Si lo recuerdas de antes, estas dos cosas son equivalentes en las listas de parámetros de funciones:</p>
<div class="sourceCode" id="cb652"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb652-1"><a href="#cb652-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>p<span class="op">)</span> <span class="op">{...}</span></span>
<span id="cb652-2"><a href="#cb652-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="dt">int</span> p<span class="op">[])</span> <span class="op">{...}</span></span></code></pre></div>
<p>Y puede que también recuerdes que puedes añadir calificadores de tipo a una variable puntero de esta forma:</p>
<div class="sourceCode" id="cb653"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb653-1"><a href="#cb653-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p<span class="op">;</span></span>
<span id="cb653-2"><a href="#cb653-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">volatile</span> p<span class="op">;</span></span>
<span id="cb653-3"><a href="#cb653-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> <span class="dt">volatile</span> p<span class="op">;</span></span>
<span id="cb653-4"><a href="#cb653-4" aria-hidden="true" tabindex="-1"></a><span class="co">// etc.</span></span></code></pre></div>
<p>Pero, ¿cómo podemos hacer eso cuando estamos utilizando la notación de matriz en su lista de parámetros?</p>
<p>Resulta que va entre paréntesis. Y puedes poner el recuento opcional después. Las dos líneas siguientes son equivalentes:</p>
<div class="sourceCode" id="cb654"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb654-1"><a href="#cb654-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> <span class="dt">volatile</span> p<span class="op">)</span> <span class="op">{...}</span></span>
<span id="cb654-2"><a href="#cb654-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="dt">int</span> p<span class="op">[</span><span class="dt">const</span> <span class="dt">volatile</span><span class="op">])</span> <span class="op">{...}</span></span>
<span id="cb654-3"><a href="#cb654-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="dt">int</span> p<span class="op">[</span><span class="dt">const</span> <span class="dt">volatile</span> <span class="dv">10</span><span class="op">])</span> <span class="op">{...}</span></span></code></pre></div>
<p>Si tiene una matriz multidimensional, debe colocar los calificadores de tipo en el primer conjunto de corchetes.</p>
<p> </p>
<h2 data-number="33.2" id="static-para-matrices-en-listas-de-parámetros"><span class="header-section-number">33.2</span> <code>static</code> para matrices en listas de parámetros</h2>
<p></p>
<p>Del mismo modo, puede utilizar la palabra clave static en la matriz en una lista de parámetros.</p>
<p>Esto es algo que nunca he visto en la naturaleza. Es <strong>siempre</strong> seguido de una dimensión:</p>
<div class="sourceCode" id="cb655"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb655-1"><a href="#cb655-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="dt">int</span> p<span class="op">[</span><span class="dt">static</span> <span class="dv">4</span><span class="op">])</span> <span class="op">{...}</span></span></code></pre></div>
<p>Lo que esto significa, en el ejemplo anterior, es que el compilador va a asumir que cualquier array que pases a la función tendrá <em>al menos</em> 4 elementos.</p>
<p>Cualquier otra cosa es un comportamiento indefinido.</p>
<div class="sourceCode" id="cb656"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb656-1"><a href="#cb656-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="dt">int</span> p<span class="op">[</span><span class="dt">static</span> <span class="dv">4</span><span class="op">])</span> <span class="op">{...}</span></span>
<span id="cb656-2"><a href="#cb656-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb656-3"><a href="#cb656-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb656-4"><a href="#cb656-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb656-5"><a href="#cb656-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">};</span></span>
<span id="cb656-6"><a href="#cb656-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb656-7"><a href="#cb656-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">};</span></span>
<span id="cb656-8"><a href="#cb656-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb656-9"><a href="#cb656-9" aria-hidden="true" tabindex="-1"></a>    func<span class="op">(</span>a<span class="op">);</span> <span class="co">// ¡OK! a tiene 4 elementos, el mínimo</span></span>
<span id="cb656-10"><a href="#cb656-10" aria-hidden="true" tabindex="-1"></a>    func<span class="op">(</span>b<span class="op">);</span> <span class="co">// ¡Bien! b tiene al menos 4 elementos</span></span>
<span id="cb656-11"><a href="#cb656-11" aria-hidden="true" tabindex="-1"></a>    func<span class="op">(</span>c<span class="op">);</span> <span class="co">// ¡Comportamiento indefinido! c tiene menos de 4 elementos!</span></span>
<span id="cb656-12"><a href="#cb656-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Esto básicamente establece el tamaño mínimo de array que puedes tener.</p>
<p>Nota importante: no hay nada en el compilador que te prohíba pasar un array más pequeño. El compilador probablemente no te advertirá, y no lo detectará en tiempo de ejecución.</p>
<p>Poniendo <code>static</code> ahí, estás diciendo, “Prometo en doble secreto que nunca pasaré un array más pequeño que este”. Y el compilador dice, “Sí, bien”, y confía en que no lo harás.</p>
<p>Y entonces el compilador puede hacer ciertas optimizaciones de código, con la seguridad de que tú, el programador, siempre harás lo correcto.</p>
<p></p>
<h2 data-number="33.3" id="inicializadores-equivalentes"><span class="header-section-number">33.3</span> Inicializadores equivalentes</h2>
<p></p>
<p>C es un poco, digamos, <em>flexible</em> cuando se trata de inicializadores de arrays.</p>
<p>Ya hemos visto algo de esto, donde cualquier valor que falte es reemplazado por cero.</p>
<p>Por ejemplo, podemos inicializar un array de 5 elementos a <code>1,2,0,0,0</code> con esto:</p>
<div class="sourceCode" id="cb657"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb657-1"><a href="#cb657-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span></code></pre></div>
<p>O poner un array completamente a cero con:</p>
<div class="sourceCode" id="cb658"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb658-1"><a href="#cb658-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span></code></pre></div>
<p>Pero las cosas se ponen interesantes cuando se inicializan matrices multidimensionales.</p>
<p>Hagamos un array de 3 filas y 2 columnas:</p>
<div class="sourceCode" id="cb659"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb659-1"><a href="#cb659-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span></code></pre></div>
<p>Escribamos algo de código para inicializarlo e imprimir el resultado:</p>
<div class="sourceCode" id="cb660"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb660-1"><a href="#cb660-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb660-2"><a href="#cb660-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb660-3"><a href="#cb660-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb660-4"><a href="#cb660-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb660-5"><a href="#cb660-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb660-6"><a href="#cb660-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span></span>
<span id="cb660-7"><a href="#cb660-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span></span>
<span id="cb660-8"><a href="#cb660-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}</span></span>
<span id="cb660-9"><a href="#cb660-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb660-10"><a href="#cb660-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb660-11"><a href="#cb660-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> row <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> row <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> row<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb660-12"><a href="#cb660-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> col <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> col<span class="op">++)</span></span>
<span id="cb660-13"><a href="#cb660-13" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span><span class="op">,</span> a<span class="op">[</span>row<span class="op">][</span>col<span class="op">]);</span></span>
<span id="cb660-14"><a href="#cb660-14" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb660-15"><a href="#cb660-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb660-16"><a href="#cb660-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Y cuando lo ejecutamos, obtenemos lo esperado:</p>
<div class="sourceCode" id="cb661"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb661-1"><a href="#cb661-1" aria-hidden="true" tabindex="-1"></a>1 2</span>
<span id="cb661-2"><a href="#cb661-2" aria-hidden="true" tabindex="-1"></a>3 4</span>
<span id="cb661-3"><a href="#cb661-3" aria-hidden="true" tabindex="-1"></a>5 6</span></code></pre></div>
<p>Dejemos fuera algunos de los elementos inicializadores y veamos cómo se ponen a cero:</p>
<div class="sourceCode" id="cb662"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb662-1"><a href="#cb662-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb662-2"><a href="#cb662-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span></span>
<span id="cb662-3"><a href="#cb662-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">3</span><span class="op">},</span>    <span class="co">// ¡Deja el 4!</span></span>
<span id="cb662-4"><a href="#cb662-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}</span></span>
<span id="cb662-5"><a href="#cb662-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>que produce:</p>
<div class="sourceCode" id="cb663"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb663-1"><a href="#cb663-1" aria-hidden="true" tabindex="-1"></a>1 2</span>
<span id="cb663-2"><a href="#cb663-2" aria-hidden="true" tabindex="-1"></a>3 0</span>
<span id="cb663-3"><a href="#cb663-3" aria-hidden="true" tabindex="-1"></a>5 6</span></code></pre></div>
<p>Ahora dejemos todo el último elemento del medio:</p>
<div class="sourceCode" id="cb664"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb664-1"><a href="#cb664-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb664-2"><a href="#cb664-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span></span>
<span id="cb664-3"><a href="#cb664-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// {3, 4},   // Solo corta todo esto</span></span>
<span id="cb664-4"><a href="#cb664-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}</span></span>
<span id="cb664-5"><a href="#cb664-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>Y ahora tenemos esto, que puede que no sea lo que esperas:</p>
<div class="sourceCode" id="cb665"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb665-1"><a href="#cb665-1" aria-hidden="true" tabindex="-1"></a>1 2</span>
<span id="cb665-2"><a href="#cb665-2" aria-hidden="true" tabindex="-1"></a>5 6</span>
<span id="cb665-3"><a href="#cb665-3" aria-hidden="true" tabindex="-1"></a>0 0</span></code></pre></div>
<p>Pero si te paras a pensarlo, sólo proporcionamos inicializadores suficientes para dos filas, por lo que se utilizaron para las dos primeras filas. Y los elementos restantes se inicializaron a cero.</p>
<p>Hasta aquí todo bien. Generalmente, si omitimos partes del inicializador, el compilador pone los elementos correspondientes a “0”.</p>
<p>Pero pongámonos <em>locos</em>.</p>
<div class="sourceCode" id="cb666"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb666-1"><a href="#cb666-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span> <span class="op">};</span></span></code></pre></div>
<p>¿Qué…? Es un array 2D, ¡pero sólo tiene un inicializador 1D!</p>
<p>Resulta que es legal (aunque GCC avisará de ello con las advertencias adecuadas activadas).</p>
<p>Básicamente, lo que hace es empezar a rellenar los elementos de la fila 0, luego la fila 1, luego la fila 2 de izquierda a derecha.</p>
<p>Así que cuando imprimimos, imprime en orden:</p>
<div class="sourceCode" id="cb667"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb667-1"><a href="#cb667-1" aria-hidden="true" tabindex="-1"></a>1 2</span>
<span id="cb667-2"><a href="#cb667-2" aria-hidden="true" tabindex="-1"></a>3 4</span>
<span id="cb667-3"><a href="#cb667-3" aria-hidden="true" tabindex="-1"></a>5 6</span></code></pre></div>
<p>Si dejamos algunos fuera:</p>
<div class="sourceCode" id="cb668"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb668-1"><a href="#cb668-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span></code></pre></div>
<p>se llenan con “0”:</p>
<div class="sourceCode" id="cb669"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb669-1"><a href="#cb669-1" aria-hidden="true" tabindex="-1"></a>1 2</span>
<span id="cb669-2"><a href="#cb669-2" aria-hidden="true" tabindex="-1"></a>3 0</span>
<span id="cb669-3"><a href="#cb669-3" aria-hidden="true" tabindex="-1"></a>0 0</span></code></pre></div>
<p>Así que si quieres llenar todo el array con <code>0</code>, entonces adelante:</p>
<div class="sourceCode" id="cb670"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb670-1"><a href="#cb670-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span></code></pre></div>
<p>Pero mi recomendación es que si tienes un array 2D, uses un inicializador 2D. Hace el código más legible. (Excepto para inicializar todo el array con <code>0</code>, en cuyo caso es idiomático usar <code>{0}</code> sin importar la dimensión del array).</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="34" id="setjmp-longjmp"><span class="header-section-number">34</span> Saltos largos con <code>setjmp</code>, <code>longjmp</code></h1>
<p></p>
<p>Ya hemos visto <code>goto</code>, que salta en el ámbito de la función. Pero <code>longjmp()</code> te permite saltar a un punto anterior en la ejecución, a una función que llamó a ésta.</p>
<p>Hay muchas limitaciones y advertencias, pero puede ser una función útil para saltar desde lo profundo de la pila de llamadas a un estado anterior.</p>
<p>En mi experiencia, esta funcionalidad se utiliza muy raramente.</p>
<h2 data-number="34.1" id="usando-setjmp-y-longjmp"><span class="header-section-number">34.1</span> Usando <code>setjmp</code> y <code>longjmp</code></h2>
<p> </p>
<p>El baile que vamos a hacer aquí es básicamente poner un marcador en ejecución con <code>setjmp()</code>. Más tarde, llamaremos a <code>longjmp()</code> y volverá al punto anterior de la ejecución donde pusimos el marcador con <code>setjmp()</code>.</p>
<p>Y puede hacer esto incluso si has llamado a subfunciones.</p>
<p>Aquí hay una demostración rápida donde llamamos a funciones de un par de niveles de profundidad y luego salimos de ellas.</p>
<p>Vamos a usar una variable de ámbito de fichero <code>env</code> para mantener el <em>estado</em> de las cosas cuando llamemos a <code>setjmp()</code> de forma que podamos restaurarlas cuando llamemos a <code>longjmp()</code> más tarde. Esta es la variable en la que recordamos nuestro “lugar”.</p>
<p>La variable <code>env</code> es de tipo <code>jmp_buf</code>, un tipo opaco declarado en <code>&lt;setjmp.h&gt;</code>.</p>
<div class="sourceCode" id="cb671"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb671-1"><a href="#cb671-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb671-2"><a href="#cb671-2"></a><span class="pp">#include </span><span class="im">&lt;setjmp.h&gt;</span></span>
<span id="cb671-3"><a href="#cb671-3"></a></span>
<span id="cb671-4"><a href="#cb671-4"></a>jmp_buf env<span class="op">;</span></span>
<span id="cb671-5"><a href="#cb671-5"></a></span>
<span id="cb671-6"><a href="#cb671-6"></a><span class="dt">void</span> depth2<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb671-7"><a href="#cb671-7"></a><span class="op">{</span></span>
<span id="cb671-8"><a href="#cb671-8"></a>    printf<span class="op">(</span><span class="st">&quot;Entering depth 2</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb671-9"><a href="#cb671-9"></a>    longjmp<span class="op">(</span>env<span class="op">,</span> <span class="dv">3490</span><span class="op">);</span>           <span class="co">// Libertad bajo fianza</span></span>
<span id="cb671-10"><a href="#cb671-10"></a>    printf<span class="op">(</span><span class="st">&quot;Leaving depth 2</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// Esto no sucederá</span></span>
<span id="cb671-11"><a href="#cb671-11"></a><span class="op">}</span></span>
<span id="cb671-12"><a href="#cb671-12"></a></span>
<span id="cb671-13"><a href="#cb671-13"></a><span class="dt">void</span> depth1<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb671-14"><a href="#cb671-14"></a><span class="op">{</span></span>
<span id="cb671-15"><a href="#cb671-15"></a>    printf<span class="op">(</span><span class="st">&quot;Entering depth 1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb671-16"><a href="#cb671-16"></a>    depth2<span class="op">();</span></span>
<span id="cb671-17"><a href="#cb671-17"></a>    printf<span class="op">(</span><span class="st">&quot;Leaving depth 1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// Esto no sucederá</span></span>
<span id="cb671-18"><a href="#cb671-18"></a><span class="op">}</span></span>
<span id="cb671-19"><a href="#cb671-19"></a></span>
<span id="cb671-20"><a href="#cb671-20"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb671-21"><a href="#cb671-21"></a><span class="op">{</span></span>
<span id="cb671-22"><a href="#cb671-22"></a>    <span class="cf">switch</span> <span class="op">(</span>setjmp<span class="op">(</span>env<span class="op">))</span> <span class="op">{</span></span>
<span id="cb671-23"><a href="#cb671-23"></a>      <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb671-24"><a href="#cb671-24"></a>          printf<span class="op">(</span><span class="st">&quot;Calling into functions, setjmp() returned 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb671-25"><a href="#cb671-25"></a>          depth1<span class="op">();</span></span>
<span id="cb671-26"><a href="#cb671-26"></a>          printf<span class="op">(</span><span class="st">&quot;Returned from functions</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="co">// Esto no sucederá</span></span>
<span id="cb671-27"><a href="#cb671-27"></a>          <span class="cf">break</span><span class="op">;</span></span>
<span id="cb671-28"><a href="#cb671-28"></a></span>
<span id="cb671-29"><a href="#cb671-29"></a>      <span class="cf">case</span> <span class="dv">3490</span><span class="op">:</span></span>
<span id="cb671-30"><a href="#cb671-30"></a>          printf<span class="op">(</span><span class="st">&quot;Bailed back to main, setjmp() returned 3490</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb671-31"><a href="#cb671-31"></a>          <span class="cf">break</span><span class="op">;</span></span>
<span id="cb671-32"><a href="#cb671-32"></a>    <span class="op">}</span></span>
<span id="cb671-33"><a href="#cb671-33"></a><span class="op">}</span></span></code></pre></div>
<p>Cuando se ejecuta, esta salida:</p>
<div class="sourceCode" id="cb672"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb672-1"><a href="#cb672-1" aria-hidden="true" tabindex="-1"></a>Calling into functions, setjmp() returned 0</span>
<span id="cb672-2"><a href="#cb672-2" aria-hidden="true" tabindex="-1"></a>Entering depth 1</span>
<span id="cb672-3"><a href="#cb672-3" aria-hidden="true" tabindex="-1"></a>Entering depth 2</span>
<span id="cb672-4"><a href="#cb672-4" aria-hidden="true" tabindex="-1"></a>Bailed back to main, setjmp() returned 3490</span></code></pre></div>
<p>Si intentas cotejar esa salida con el código, está claro que están pasando cosas realmente <em>funky</em>.</p>
<p>Una de las cosas más notables es que <code>setjmp()</code> devuelve <em>twice</em>. ¿Qué demonios? ¡¿Qué es esta brujería?!</p>
<p>Así que esto es lo que pasa: si <code>setjmp()</code> devuelve <code>0</code>, significa que has establecido con éxito el “marcador” en ese punto.</p>
<p>Si devuelve un valor distinto de cero, significa que has vuelto al “marcador” establecido anteriormente. (Y el valor devuelto es el que pasas a <code>longjmp()</code>.)</p>
<p>De esta forma puedes diferenciar entre establecer el marcador y volver a él más tarde.</p>
<p>Así que cuando el código de arriba llama a <code>setjmp()</code> la primera vez, <code>setjmp()</code> <em>almacena</em> el estado en la variable <code>env</code> y devuelve <code>0</code>. Más tarde, cuando llamamos a <code>longjmp()</code> con ese mismo <code>env</code>, se restaura el estado y <code>setjmp()</code> devuelve el valor que se le pasó a <code>longjmp()</code>.</p>
<p> </p>
<h2 data-number="34.2" id="errores-pitfalls"><span class="header-section-number">34.2</span> Errores (Pitfalls)</h2>
<p>Bajo el capó, esto es bastante sencillo. Normalmente, el <em>puntero de pila</em> mantiene un registro de las ubicaciones en memoria en las que se almacenan las variables locales, y el <em>contador de programa</em> mantiene un registro de la dirección de la instrucción que se está ejecutando en ese momento<a href="#fn178" class="footnote-ref" id="fnref178" role="doc-noteref"><sup>178</sup></a>.</p>
<p>Así que si queremos saltar de nuevo a una función anterior, es básicamente sólo una cuestión de restaurar el puntero de la pila y el contador de programa a los valores guardados en la variable . <code>jmp_buf</code>, y asegurarse de que el valor de retorno se establece correctamente. Y entonces la ejecución se reanudará allí.</p>
<p>Pero una variedad de factores confunden esto, haciendo un número significativo de trampas de comportamiento indefinido.</p>
<h3 data-number="34.2.1" id="los-valores-de-las-variables-locales"><span class="header-section-number">34.2.1</span> Los valores de las variables locales</h3>
<p></p>
<p>Si quieres que los valores de las variables locales automáticas (no <code>static</code> y no <code>extern</code>) persistan en la función que llamó a <code>setjmp()</code> después de que ocurra un <code>longjmp()</code>, debe declarar que esas variables son <code>volatile</code>.</p>
<p>Técnicamente, sólo tienen que ser <code>volátiles</code> si cambian entre el momento en que se llama a <code>setjmp()</code> y se llama a <code>longjmp()</code><a href="#fn179" class="footnote-ref" id="fnref179" role="doc-noteref"><sup>179</sup></a>.</p>
<p>Por ejemplo, si ejecutamos este código</p>
<div class="sourceCode" id="cb673"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb673-1"><a href="#cb673-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb673-2"><a href="#cb673-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb673-3"><a href="#cb673-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>setjmp<span class="op">(</span>env<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb673-4"><a href="#cb673-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">30</span><span class="op">;</span></span>
<span id="cb673-5"><a href="#cb673-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>y luego <code>longjmp()</code> de vuelta, el valor de <code>x</code> será indeterminado.</p>
<p>Si queremos solucionar esto, <code>x</code> debe ser <code>volátil</code>:</p>
<div class="sourceCode" id="cb674"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb674-1"><a href="#cb674-1" aria-hidden="true" tabindex="-1"></a><span class="dt">volatile</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb674-2"><a href="#cb674-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb674-3"><a href="#cb674-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>setjmp<span class="op">(</span>env<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb674-4"><a href="#cb674-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">30</span><span class="op">;</span></span>
<span id="cb674-5"><a href="#cb674-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p></p>
<p>Ahora el valor será el correcto <code>30</code> después de que un <code>longjmp()</code> nos devuelve a este punto.</p>
<h3 data-number="34.2.2" id="cuánto-estado-se-ahorra"><span class="header-section-number">34.2.2</span> ¿Cuánto Estado se ahorra?</h3>
<p> </p>
<p>Cuando usted <code>longjmp()</code>, la ejecución se reanuda en el punto del <code>setjmp()</code> correspondiente. Y eso es todo.</p>
<p></p>
<p>La especificación señala que es como si hubieras vuelto a la función en ese punto con las variables locales establecidas a los valores que tenían cuando se hizo la llamada a <code>longjmp()</code>. </p>
<p>Las cosas que no se restauran incluyen, parafraseando la especificación:</p>
<ul>
<li>Banderas de estado de punto flotante</li>
<li>Archivos abiertos</li>
<li>Cualquier otro componente de la máquina abstracta</li>
</ul>
<h3 data-number="34.2.3" id="no-puedes-nombrar-nada-setjmp"><span class="header-section-number">34.2.3</span> No Puedes Nombrar Nada <code>setjmp</code></h3>
<p>No puedes tener ningún identificador <code>extern</code> con el nombre <code>setjmp</code>. O, si <code>setjmp</code> es una macro, no puedes redefinirla.</p>
<p>Ambos son comportamientos indefinidos.</p>
<h3 data-number="34.2.4" id="no-puede-setjmp-en-una-expresión-mayor"><span class="header-section-number">34.2.4</span> No Puede <code>setjmp()</code> en una Expresión Mayor</h3>
<p></p>
<p>Es decir, no puedes hacer algo así:</p>
<div class="sourceCode" id="cb675"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb675-1"><a href="#cb675-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="dv">12</span> <span class="op">&amp;&amp;</span> setjmp<span class="op">(</span>env<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>Eso es demasiado complejo para que lo permita la especificación debido a las maquinaciones que deben ocurrir al desenrollar la pila y todo eso. No podemos <code>longjmp()</code> volver a una expresión compleja que sólo se ha ejecutado parcialmente.</p>
<p>Así que hay límites en la complejidad de esa expresión.</p>
<ul>
<li><p>Puede ser toda la expresión controladora de la condicional.</p>
<div class="sourceCode" id="cb676"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb676-1"><a href="#cb676-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>setjmp<span class="op">(</span>env<span class="op">))</span> <span class="op">{...}</span></span></code></pre></div>
<div class="sourceCode" id="cb677"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb677-1"><a href="#cb677-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>setjmp<span class="op">(</span>env<span class="op">))</span> <span class="op">{...}</span></span></code></pre></div></li>
<li><p>Puede formar parte de una expresión relacional o de igualdad, siempre que el otro operando sea una constante entera. Y el entero es la expresión controladora del condicional.</p>
<div class="sourceCode" id="cb678"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb678-1"><a href="#cb678-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>setjmp<span class="op">(</span>env<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{...}</span></span></code></pre></div></li>
<li><p>El operando de una operación lógica NOT (<code>!</code>), siendo toda la expresión controladora.</p>
<div class="sourceCode" id="cb679"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb679-1"><a href="#cb679-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!</span>setjmp<span class="op">(</span>env<span class="op">))</span> <span class="op">{...}</span></span></code></pre></div></li>
<li><p>Una expresión independiente, posiblemente convertida en <code>void</code>.</p>
<div class="sourceCode" id="cb680"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb680-1"><a href="#cb680-1" aria-hidden="true" tabindex="-1"></a>setjmp<span class="op">(</span>env<span class="op">);</span></span></code></pre></div>
<div class="sourceCode" id="cb681"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb681-1"><a href="#cb681-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="dt">void</span><span class="op">)</span>setjmp<span class="op">(</span>env<span class="op">);</span></span></code></pre></div></li>
</ul>
<p></p>
<h3 data-number="34.2.5" id="cuándo-no-se-puede-longjmp"><span class="header-section-number">34.2.5</span> ¿Cuándo no se puede <code>longjmp()</code>?</h3>
<p></p>
<p>Es un comportamiento indefinido si:</p>
<ul>
<li>No has llamado antes a <code>setjmp()</code>.</li>
<li>Llamó a <code>setjmp()</code> desde otro thread</li>
<li>Llamó a <code>setjmp()</code> en el ámbito de un array de longitud variable (VLA), y la ejecución dejó el ámbito de ese VLA antes de que <code>longjmp()</code> fuera llamado.</li>
<li>La función que contiene <code>setjmp()</code> salió antes de que <code>longjmp()</code> fuera llamada.</li>
</ul>
<p>En este último caso, “salió” incluye los retornos normales de la función, así como el caso de que otro <code>longjmp()</code> saltara “antes” en la pila de llamadas que la función en cuestión.</p>
<h3 data-number="34.2.6" id="no-se-puede-pasar-0-a-longjmp."><span class="header-section-number">34.2.6</span> No se puede pasar <code>0</code> a <code>longjmp()</code>.</h3>
<p>Si intenta pasar el valor <code>0</code> a <code>longjmp()</code>, cambiará silenciosamente ese valor a <code>1</code>.</p>
<p>Dado que <code>setjmp()</code> devuelve este valor, y que <code>setjmp()</code> devuelve <code>0</code> tiene un significado especial, devolver <code>0</code> está prohibido.</p>
<h3 data-number="34.2.7" id="longjmp-y-los-arrays-de-longitud-variable"><span class="header-section-number">34.2.7</span> <code>longjmp()</code> y los Arrays de Longitud Variable</h3>
<p>Si estás en el ámbito de un VLA y haces <code>longjmp()</code> fuera de él, la memoria asignada al VLA podría tener fugas<a href="#fn180" class="footnote-ref" id="fnref180" role="doc-noteref"><sup>180</sup></a>.</p>
<p>Lo mismo ocurre si haces <code>longjmp()</code> hacia atrás sobre cualquier función anterior que tuviera VLAs todavía en scope.</p>
<p>Esto es algo que realmente me molestaba de los VLAs—que podías escribir código C perfectamente legítimo que derrochaba memoria. Pero, oye… yo no estoy a cargo de la especificación.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="35" id="tipos-incompletos"><span class="header-section-number">35</span> Tipos incompletos</h1>
<p></p>
<p>Puede que le sorprenda saber que esto se construye sin errores:</p>
<div class="sourceCode" id="cb682"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb682-1"><a href="#cb682-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="dt">int</span> a<span class="op">[];</span></span>
<span id="cb682-2"><a href="#cb682-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb682-3"><a href="#cb682-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb682-4"><a href="#cb682-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb682-5"><a href="#cb682-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> foo <span class="op">*</span>x<span class="op">;</span></span>
<span id="cb682-6"><a href="#cb682-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> bar <span class="op">*</span>y<span class="op">;</span></span>
<span id="cb682-7"><a href="#cb682-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> baz <span class="op">*</span>z<span class="op">;</span></span>
<span id="cb682-8"><a href="#cb682-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Nunca hemos dado un tamaño para “a”. Y tenemos punteros a <code>struct</code>s <code>foo</code>, <code>bar</code>, y <code>baz</code> que nunca parecen estar declarados en ninguna parte.</p>
<p>Y las únicas advertencias que recibo son que <code>x</code>, <code>y</code>, y <code>z</code> no se usan.</p>
<p>Estos son ejemplos de <em>tipos incompletos</em>.</p>
<p>Un tipo incompleto es un tipo cuyo tamaño (es decir, el tamaño que obtendrías de <code>sizeof</code>) no se conoce. Otra forma de verlo es un tipo que no has terminado de declarar.</p>
<p>Puedes tener un puntero a un tipo incompleto, pero no puedes desreferenciarlo o usar aritmética de punteros en él. Y no se puede <code>sizeof</code>.</p>
<p>¿Qué puedes hacer con él?</p>
<h2 data-number="35.1" id="caso-práctico-estructuras-autorreferenciales"><span class="header-section-number">35.1</span> Caso práctico: estructuras autorreferenciales</h2>
<p></p>
<p>Sólo conozco un caso de uso real: referencias hacia adelante a <code>struct</code>s o <code>union</code>s con estructuras autorreferenciales o codependientes. (Voy a utilizar <code>struct</code> para el resto de estos ejemplos, pero todos se aplican igualmente a <code>union</code>s, también).</p>
<p>Hagamos primero el ejemplo clásico.</p>
<p>Pero antes, ¡ten esto en cuenta! Cuando declaras una <code>struct</code>, ¡la <code>struct</code> está incompleta hasta que se alcanza la llave de cierre!</p>
<div class="sourceCode" id="cb683"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb683-1"><a href="#cb683-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> antelope <span class="op">{</span>              <span class="co">// struct antelope está incompleto aquí</span></span>
<span id="cb683-2"><a href="#cb683-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> leg_count<span class="op">;</span>             <span class="co">// Aún incompleto</span></span>
<span id="cb683-3"><a href="#cb683-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> stomach_fullness<span class="op">;</span>    <span class="co">// Aún incompleto</span></span>
<span id="cb683-4"><a href="#cb683-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> top_speed<span class="op">;</span>           <span class="co">// Aún incompleto</span></span>
<span id="cb683-5"><a href="#cb683-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>nickname<span class="op">;</span>            <span class="co">// Aún incompleto</span></span>
<span id="cb683-6"><a href="#cb683-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span>                             <span class="co">// AHORA está completo.</span></span></code></pre></div>
<p>¿Y qué? Parece bastante sensato.</p>
<p>¿Pero qué pasa si estamos haciendo una lista enlazada? Cada nodo de la lista enlazada necesita tener una referencia a otro nodo. ¿Pero cómo podemos crear una referencia a otro nodo si ni siquiera hemos terminado de declarar el nodo?</p>
<p>C permite tipos incompletos. No podemos declarar un nodo, pero <em>podemos</em> declarar un puntero a uno, ¡incluso si está incompleto!</p>
<div class="sourceCode" id="cb684"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb684-1"><a href="#cb684-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> node <span class="op">{</span></span>
<span id="cb684-2"><a href="#cb684-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb684-3"><a href="#cb684-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> node <span class="op">*</span>next<span class="op">;</span>  <span class="co">// El nodo struct está incompleto, ¡pero no pasa nada!</span></span>
<span id="cb684-4"><a href="#cb684-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Aunque el nodo <code>struct</code> está incompleto en la línea 3, aún podemos declarar un puntero a uno<a href="#fn181" class="footnote-ref" id="fnref181" role="doc-noteref"><sup>181</sup></a>.</p>
<p>Podemos hacer lo mismo si tenemos dos <code>struct</code>s diferentes que se refieren la una a la otra:</p>
<div class="sourceCode" id="cb685"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb685-1"><a href="#cb685-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> a <span class="op">{</span></span>
<span id="cb685-2"><a href="#cb685-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> b <span class="op">*</span>x<span class="op">;</span>  <span class="co">// Se refiere a una `estructura b`</span></span>
<span id="cb685-3"><a href="#cb685-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb685-4"><a href="#cb685-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb685-5"><a href="#cb685-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> b <span class="op">{</span></span>
<span id="cb685-6"><a href="#cb685-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> a <span class="op">*</span>x<span class="op">;</span>  <span class="co">// Se refiere a una `estructura a`.</span></span>
<span id="cb685-7"><a href="#cb685-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Nunca seríamos capaces de hacer ese par de estructuras sin las reglas relajadas para tipos incompletos.</p>
<p></p>
<h2 data-number="35.2" id="mensajes-de-error-de-tipo-incompleto"><span class="header-section-number">35.2</span> Mensajes de error de tipo incompleto</h2>
<p>¿Recibe errores como éstos?</p>
<div class="sourceCode" id="cb686"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb686-1"><a href="#cb686-1" aria-hidden="true" tabindex="-1"></a>invalid application of ‘sizeof’ to incomplete type</span>
<span id="cb686-2"><a href="#cb686-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb686-3"><a href="#cb686-3" aria-hidden="true" tabindex="-1"></a>invalid use of undefined type</span>
<span id="cb686-4"><a href="#cb686-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb686-5"><a href="#cb686-5" aria-hidden="true" tabindex="-1"></a>dereferencing pointer to incomplete type</span></code></pre></div>
<p>Culpable más probable: probablemente olvidó <code>#incluir</code> el fichero de cabecera que declara el tipo.</p>
<h2 data-number="35.3" id="otros-tipos-incompletos"><span class="header-section-number">35.3</span> Otros tipos incompletos</h2>
<p>Declarar una <code>struct</code> o <code>union</code> sin cuerpo hace un tipo incompleto, por ejemplo <code>struct foo;</code>.</p>
<p>Los <code>enums</code> son incompletos hasta la llave de cierre.</p>
<p>Los <code>void</code> son tipos incompletos.</p>
<p>Los arrays declarados <code>extern</code> sin tamaño son incompletos, p.e.:</p>
<div class="sourceCode" id="cb687"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb687-1"><a href="#cb687-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="dt">int</span> a<span class="op">[];</span></span></code></pre></div>
<p>Si es un array no <code>externo</code> sin tamaño seguido de un inicializador, está incompleto hasta la llave de cierre del inicializador.</p>
<h2 data-number="35.4" id="caso-de-uso-arrays-en-ficheros-de-cabecera"><span class="header-section-number">35.4</span> Caso de Uso: Arrays en ficheros de cabecera</h2>
<p>Puede ser útil declarar tipos de array incompletos en ficheros de cabecera. En esos casos, el almacenamiento real (donde se declara el array completo) debería estar en un único fichero <code>.c</code>. Si lo pones en el fichero <code>.h</code>, se duplicará cada vez que se incluya el fichero de cabecera.</p>
<p>Así que lo que puedes hacer es crear un fichero de cabecera con un tipo incompleto que haga referencia al array, así:</p>
<div class="sourceCode" id="cb688"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb688-1"><a href="#cb688-1"></a><span class="co">// File: bar.h</span></span>
<span id="cb688-2"><a href="#cb688-2"></a></span>
<span id="cb688-3"><a href="#cb688-3"></a><span class="pp">#ifndef BAR_H</span></span>
<span id="cb688-4"><a href="#cb688-4"></a><span class="pp">#define BAR_H</span></span>
<span id="cb688-5"><a href="#cb688-5"></a></span>
<span id="cb688-6"><a href="#cb688-6"></a><span class="kw">extern</span> <span class="dt">int</span> my_array<span class="op">[];</span>  <span class="co">// Tipo incompleto</span></span>
<span id="cb688-7"><a href="#cb688-7"></a></span>
<span id="cb688-8"><a href="#cb688-8"></a><span class="pp">#endif</span></span></code></pre></div>
<p>Y el en el archivo <code>.c</code>, en realidad definir la matriz:</p>
<div class="sourceCode" id="cb689"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb689-1"><a href="#cb689-1"></a><span class="co">// File: bar.c</span></span>
<span id="cb689-2"><a href="#cb689-2"></a></span>
<span id="cb689-3"><a href="#cb689-3"></a><span class="dt">int</span> my_array<span class="op">[</span><span class="dv">1024</span><span class="op">];</span>     <span class="co">// ¡Tipo completo!</span></span></code></pre></div>
<p>A continuación, puede incluir el encabezado de tantos lugares como desee, y cada uno de esos lugares se refieren a la misma subyacente <code>my_array</code>.</p>
<div class="sourceCode" id="cb690"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb690-1"><a href="#cb690-1"></a><span class="co">// File: foo.c</span></span>
<span id="cb690-2"><a href="#cb690-2"></a></span>
<span id="cb690-3"><a href="#cb690-3"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb690-4"><a href="#cb690-4"></a><span class="pp">#include </span><span class="im">&quot;bar.h&quot;</span><span class="pp">    </span><span class="co">// incluye el tipo incompleto para mi_array</span></span>
<span id="cb690-5"><a href="#cb690-5"></a></span>
<span id="cb690-6"><a href="#cb690-6"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb690-7"><a href="#cb690-7"></a><span class="op">{</span></span>
<span id="cb690-8"><a href="#cb690-8"></a>    my_array<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb690-9"><a href="#cb690-9"></a></span>
<span id="cb690-10"><a href="#cb690-10"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> my_array<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb690-11"><a href="#cb690-11"></a><span class="op">}</span></span></code></pre></div>
<p>Cuando compile varios archivos, recuerde especificar todos los archivos <code>.c</code> al compilador, pero no los archivos <code>.h</code>, p. ej:</p>
<div class="sourceCode" id="cb691"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb691-1"><a href="#cb691-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-o</span> foo foo.c bar.c</span></code></pre></div>
<h2 data-number="35.5" id="completar-tipos-incompletos"><span class="header-section-number">35.5</span> Completar tipos incompletos</h2>
<p>Si tienes un tipo incompleto, puedes completarlo definiendo el <code>struct</code>, <code>union</code>, <code>enum</code>, o array completo en el mismo ámbito.</p>
<div class="sourceCode" id="cb692"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb692-1"><a href="#cb692-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo<span class="op">;</span>        <span class="co">// tipo incompleto</span></span>
<span id="cb692-2"><a href="#cb692-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-3"><a href="#cb692-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">*</span>p<span class="op">;</span>     <span class="co">// puntero, no hay problema</span></span>
<span id="cb692-4"><a href="#cb692-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-5"><a href="#cb692-5" aria-hidden="true" tabindex="-1"></a><span class="co">// struct foo f;   // Error: ¡tipo incompleto!</span></span>
<span id="cb692-6"><a href="#cb692-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-7"><a href="#cb692-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb692-8"><a href="#cb692-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">,</span> z<span class="op">;</span></span>
<span id="cb692-9"><a href="#cb692-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span> <span class="co">// ¡Ahora la estructura foo está completa!</span></span>
<span id="cb692-10"><a href="#cb692-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-11"><a href="#cb692-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo f<span class="op">;</span>      <span class="co">// ¡Éxito!</span></span></code></pre></div>
<p>Ten en cuenta que aunque <code>void</code> es un tipo incompleto, no hay forma de completarlo. No es que a nadie se le ocurra hacer esa cosa rara. Pero explica por qué se puede hacer esto:</p>
<div class="sourceCode" id="cb693"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb693-1"><a href="#cb693-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>p<span class="op">;</span>             <span class="co">// OK: puntero a tipo incompleto</span></span></code></pre></div>
<p>y no ninguno de estos:</p>
<div class="sourceCode" id="cb694"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb694-1"><a href="#cb694-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> v<span class="op">;</span>              <span class="co">// Error: declarar variable de tipo incompleto</span></span>
<span id="cb694-2"><a href="#cb694-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb694-3"><a href="#cb694-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// Error: referencia a un tipo incompleto</span></span></code></pre></div>
<p>Cuanto más sepas…</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="36" id="números-complejos"><span class="header-section-number">36</span> Números complejos</h1>
<p></p>
<p>Un pequeño manual sobre <a href="https://en.wikipedia.org/wiki/Complex_number">Números complejos</a><a href="#fn182" class="footnote-ref" id="fnref182" role="doc-noteref"><sup>182</sup></a> robado directamente de Wikipedia:</p>
<blockquote>
<p>Un <strong>número complejo</strong> es un número que puede expresarse de la forma <span class="math inline">\(a+bi\)</span>, donde <span class="math inline">\(a\)</span> y <span class="math inline">\(b\)</span> son números reales [es decir, tipos de coma flotante en C], y <span class="math inline">\(i\)</span> representa la unidad imaginaria, satisfaciendo la ecuación <span class="math inline">\(i^2=-1\)</span>. Dado que ningún número real satisface esta ecuación, <span class="math inline">\(i\)</span> se denomina número imaginario. Para el número complejo <span class="math inline">\(a+bi\)</span>, <span class="math inline">\(a\)</span> se denomina se llama <strong>parte real</strong>, y <span class="math inline">\(b\)</span> se llama <strong>parte imaginaria</strong>.</p>
</blockquote>
<p>Pero hasta aquí voy a llegar. Asumiremos que si estás leyendo este capítulo, sabes lo que es un número complejo y lo que quieres hacer con ellos.</p>
<p>Y todo lo que necesitamos cubrir son las facultades de C para hacerlo.</p>
<p>Resulta, sin embargo, que el soporte de números complejos en un compilador es una característica <em>opcional</em>. No todos los compiladores compatibles pueden hacerlo. Y los que lo hacen, puede que lo hagan con distintos grados de completitud.</p>
<p>Puedes comprobar si tu sistema soporta números complejos con:</p>
<p></p>
<div class="sourceCode" id="cb695"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb695-1"><a href="#cb695-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef __STDC_NO_COMPLEX__</span></span>
<span id="cb695-2"><a href="#cb695-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#error Complex numbers not supported!</span></span>
<span id="cb695-3"><a href="#cb695-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p></p>
<p></p>
<p>Además, hay una macro que indica la adhesión a la norma ISO 60559 (IEEE 754) para matemáticas en coma flotante con números complejos, así como la presencia del tipo <code>_Imaginary</code>.</p>
<div class="sourceCode" id="cb696"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb696-1"><a href="#cb696-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if __STDC_IEC_559_COMPLEX__ != 1</span></span>
<span id="cb696-2"><a href="#cb696-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#error Need IEC 60559 complex support!</span></span>
<span id="cb696-3"><a href="#cb696-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p></p>
<p>Encontrará más información al respecto en el Anexo G de la especificación C11.</p>
<h2 data-number="36.1" id="tipos-complejos"><span class="header-section-number">36.1</span> Tipos complejos</h2>
<p>Para usar números complejos, <code>#include &lt;complex.h&gt;</code>.</p>
<p>Con eso, se obtienen al menos dos tipos:</p>
<p> </p>
<div class="sourceCode" id="cb697"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb697-1"><a href="#cb697-1" aria-hidden="true" tabindex="-1"></a><span class="dt">_Complex</span></span>
<span id="cb697-2"><a href="#cb697-2" aria-hidden="true" tabindex="-1"></a><span class="dt">complex</span></span></code></pre></div>
<p>Ambos significan lo mismo, por lo que es mejor utilizar el más bonito <code>complex</code>. </p>
<p>También dispone de algunos tipos para números imaginarios si su aplicación cumple la norma IEC 60559:</p>
<p> </p>
<div class="sourceCode" id="cb698"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb698-1"><a href="#cb698-1" aria-hidden="true" tabindex="-1"></a><span class="dt">_Imaginary</span></span>
<span id="cb698-2"><a href="#cb698-2" aria-hidden="true" tabindex="-1"></a><span class="dt">imaginary</span></span></code></pre></div>
<p>Ambos significan lo mismo, así que puedes usar el más bonito <code>imaginary</code>.</p>
<p></p>
<p>También se obtienen valores para el propio número imaginario <span class="math inline">\(i\)</span>:</p>
<p> </p>
<div class="sourceCode" id="cb699"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb699-1"><a href="#cb699-1" aria-hidden="true" tabindex="-1"></a>I</span>
<span id="cb699-2"><a href="#cb699-2" aria-hidden="true" tabindex="-1"></a>_Complex_I</span>
<span id="cb699-3"><a href="#cb699-3" aria-hidden="true" tabindex="-1"></a>_Imaginary_I</span></code></pre></div>
<p>La macro <code>I</code> se establece en <code>_Imaginario_I</code> (si está disponible), o <code>_I_Complejo</code>. Así que sólo tiene que utilizar <code>I</code> para el número imaginario.</p>
<p> </p>
<p></p>
<p>Un inciso: he dicho que si un compilador tiene <code>__STDC_IEC_559_COMPLEX__</code> a <code>1</code>, debe soportar tipos <code>_Imaginary</code> para ser compatible. Esa es mi lectura de la especificación. Sin embargo, no conozco ningún compilador que soporte <code>_Imaginary</code> aunque tenga <code>__STDC_IEC_559_COMPLEX__</code>. Así que voy a escribir algo de código con ese tipo que no tengo forma de probar. Lo siento.</p>
<p> </p>
<p>Bien, ahora que sabemos que existe un tipo <code>complejo</code>, ¿cómo podemos usarlo?</p>
<h2 data-number="36.2" id="asignando-números-complejos"><span class="header-section-number">36.2</span> Asignando Números Complejos</h2>
<p></p>
<p>Dado que el número complejo tiene una parte real y otra imaginaria, pero ambas se basan en números de coma flotante para almacenar valores, también tenemos que decirle a C qué precisión utilizar para esas partes del número complejo.</p>
<p> </p>
<p>Para ello, basta con fijar un <code>float</code>, un <code>double</code> o un <code>long double</code> al <code>complex</code>, antes o después de él.</p>
<p></p>
<p>Definamos un número complejo que utilice <code>float</code> para sus componentes:</p>
<div class="sourceCode" id="cb700"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb700-1"><a href="#cb700-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="dt">complex</span> c<span class="op">;</span> <span class="co">// Spec prefiere esta forma</span></span>
<span id="cb700-2"><a href="#cb700-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="dt">complex</span> c<span class="op">;</span> <span class="co">// Lo mismo--el orden no importa</span></span></code></pre></div>
<p>Eso está muy bien para las declaraciones, pero ¿cómo las inicializamos o asignamos?</p>
<p>Resulta que podemos utilizar una notación bastante natural. Ejemplo</p>
<p></p>
<div class="sourceCode" id="cb701"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb701-1"><a href="#cb701-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>I<span class="op">;</span></span>
<span id="cb701-2"><a href="#cb701-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> y <span class="op">=</span> <span class="dv">10</span> <span class="op">+</span> <span class="dv">3</span><span class="op">*</span>I<span class="op">;</span></span></code></pre></div>
<p></p>
<p>Para 5+2i$ y 10+3i$, respectivamente.</p>
<p> </p>
<h2 data-number="36.3" id="construir-deconstruir-e-imprimir"><span class="header-section-number">36.3</span> Construir, deconstruir e imprimir</h2>
<p>Ya estamos llegando…</p>
<p>Ya hemos visto una forma de escribir un número complejo:</p>
<div class="sourceCode" id="cb702"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb702-1"><a href="#cb702-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>I<span class="op">;</span></span></code></pre></div>
<p>Tampoco hay problema en utilizar otros números de coma flotante para construirlo:</p>
<div class="sourceCode" id="cb703"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb703-1"><a href="#cb703-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb703-2"><a href="#cb703-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> b <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb703-3"><a href="#cb703-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> a <span class="op">+</span> b<span class="op">*</span>I<span class="op">;</span></span></code></pre></div>
<p></p>
<p>También hay un conjunto de macros para ayudar a construir estos. El código anterior podría escribirse utilizando la macro <code>CMPLX()</code>, así:</p>
<div class="sourceCode" id="cb704"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb704-1"><a href="#cb704-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> CMPLX<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<p>Según mis investigaciones, son casi equivalentes:</p>
<div class="sourceCode" id="cb705"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb705-1"><a href="#cb705-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>I<span class="op">;</span></span>
<span id="cb705-2"><a href="#cb705-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> CMPLX<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<p>Pero la macro <code>CMPLX()</code> tratará siempre correctamente los ceros negativos en la parte imaginaria, mientras que la otra forma podría convertirlos en ceros positivos. Yo <em>pienso</em><a href="#fn183" class="footnote-ref" id="fnref183" role="doc-noteref"><sup>183</sup></a>. Esto parece implicar que si existe la posibilidad de que la parte imaginaria sea cero, debería usar la macro… ¡pero que alguien me corrija si me equivoco!</p>
<p>La macro <code>CMPLX()</code> funciona con tipos <code>doble</code>. Hay otras dos macros para <code>float</code> y <code>long double</code>: <code>CMPLXF()</code> y <code>CMPLXL()</code>. (Estos sufijos “f” y “l” aparecen en prácticamente todas las funciones relacionadas con los números complejos).</p>
<p></p>
<p>Ahora intentemos lo contrario: si tenemos un número complejo, ¿cómo lo descomponemos en sus partes real e imaginaria?</p>
<p> </p>
<p>Aquí tenemos un par de funciones que extraerán las partes real e imaginaria del número: <code>creal()</code> y <code>cimag()</code>:</p>
<div class="sourceCode" id="cb706"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb706-1"><a href="#cb706-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>I<span class="op">;</span></span>
<span id="cb706-2"><a href="#cb706-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="dt">complex</span> y <span class="op">=</span> <span class="dv">10</span> <span class="op">+</span> <span class="dv">3</span><span class="op">*</span>I<span class="op">;</span></span>
<span id="cb706-3"><a href="#cb706-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb706-4"><a href="#cb706-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;x = </span><span class="sc">%f</span><span class="st"> + </span><span class="sc">%f</span><span class="st">i</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> creal<span class="op">(</span>x<span class="op">),</span> cimag<span class="op">(</span>x<span class="op">));</span></span>
<span id="cb706-5"><a href="#cb706-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;y = </span><span class="sc">%f</span><span class="st"> + </span><span class="sc">%f</span><span class="st">i</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> creal<span class="op">(</span>y<span class="op">),</span> cimag<span class="op">(</span>y<span class="op">));</span></span></code></pre></div>
<p>para la salida:</p>
<div class="sourceCode" id="cb707"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb707-1"><a href="#cb707-1" aria-hidden="true" tabindex="-1"></a>x = 5.000000 + 2.000000i</span>
<span id="cb707-2"><a href="#cb707-2" aria-hidden="true" tabindex="-1"></a>y = 10.000000 + 3.000000i</span></code></pre></div>
<p>Tenga en cuenta que la <code>i</code> que tengo en la cadena de formato <code>printf()</code> es una <code>i</code> literal que se imprime—no es parte del especificador de formato. Ambos valores devueltos por <code>creal()</code> y <code>cimag()</code> son <code>double</code>.</p>
<p>Y como siempre, hay variantes <code>float</code> y <code>long double</code> de estas funciones: <code>crealf()</code>, <code>cimagf()</code>, <code>creall()</code>, and <code>cimagl()</code>.</p>
<p> </p>
<h2 data-number="36.4" id="aritmética-compleja-y-comparaciones"><span class="header-section-number">36.4</span> Aritmética compleja y comparaciones</h2>
<p></p>
<p>Es posible realizar operaciones aritméticas con números complejos, aunque su funcionamiento matemático queda fuera del alcance de esta guía.</p>
<div class="sourceCode" id="cb708"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb708-1"><a href="#cb708-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb708-2"><a href="#cb708-2"></a><span class="pp">#include </span><span class="im">&lt;complex.h&gt;</span></span>
<span id="cb708-3"><a href="#cb708-3"></a></span>
<span id="cb708-4"><a href="#cb708-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb708-5"><a href="#cb708-5"></a><span class="op">{</span></span>
<span id="cb708-6"><a href="#cb708-6"></a>    <span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>I<span class="op">;</span></span>
<span id="cb708-7"><a href="#cb708-7"></a>    <span class="dt">double</span> <span class="dt">complex</span> y <span class="op">=</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span><span class="op">*</span>I<span class="op">;</span></span>
<span id="cb708-8"><a href="#cb708-8"></a>    <span class="dt">double</span> <span class="dt">complex</span> z<span class="op">;</span></span>
<span id="cb708-9"><a href="#cb708-9"></a></span>
<span id="cb708-10"><a href="#cb708-10"></a>    z <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb708-11"><a href="#cb708-11"></a>    printf<span class="op">(</span><span class="st">&quot;x + y = </span><span class="sc">%f</span><span class="st"> + </span><span class="sc">%f</span><span class="st">i</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> creal<span class="op">(</span>z<span class="op">),</span> cimag<span class="op">(</span>z<span class="op">));</span></span>
<span id="cb708-12"><a href="#cb708-12"></a></span>
<span id="cb708-13"><a href="#cb708-13"></a>    z <span class="op">=</span> x <span class="op">-</span> y<span class="op">;</span></span>
<span id="cb708-14"><a href="#cb708-14"></a>    printf<span class="op">(</span><span class="st">&quot;x - y = </span><span class="sc">%f</span><span class="st"> + </span><span class="sc">%f</span><span class="st">i</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> creal<span class="op">(</span>z<span class="op">),</span> cimag<span class="op">(</span>z<span class="op">));</span></span>
<span id="cb708-15"><a href="#cb708-15"></a></span>
<span id="cb708-16"><a href="#cb708-16"></a>    z <span class="op">=</span> x <span class="op">*</span> y<span class="op">;</span></span>
<span id="cb708-17"><a href="#cb708-17"></a>    printf<span class="op">(</span><span class="st">&quot;x * y = </span><span class="sc">%f</span><span class="st"> + </span><span class="sc">%f</span><span class="st">i</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> creal<span class="op">(</span>z<span class="op">),</span> cimag<span class="op">(</span>z<span class="op">));</span></span>
<span id="cb708-18"><a href="#cb708-18"></a></span>
<span id="cb708-19"><a href="#cb708-19"></a>    z <span class="op">=</span> x <span class="op">/</span> y<span class="op">;</span></span>
<span id="cb708-20"><a href="#cb708-20"></a>    printf<span class="op">(</span><span class="st">&quot;x / y = </span><span class="sc">%f</span><span class="st"> + </span><span class="sc">%f</span><span class="st">i</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> creal<span class="op">(</span>z<span class="op">),</span> cimag<span class="op">(</span>z<span class="op">));</span></span>
<span id="cb708-21"><a href="#cb708-21"></a><span class="op">}</span></span></code></pre></div>
<p>por un resultado de:</p>
<div class="sourceCode" id="cb709"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb709-1"><a href="#cb709-1" aria-hidden="true" tabindex="-1"></a>x + y = 4.000000 + 6.000000i</span>
<span id="cb709-2"><a href="#cb709-2" aria-hidden="true" tabindex="-1"></a>x - y = -2.000000 + -2.000000i</span>
<span id="cb709-3"><a href="#cb709-3" aria-hidden="true" tabindex="-1"></a>x * y = -5.000000 + 10.000000i</span>
<span id="cb709-4"><a href="#cb709-4" aria-hidden="true" tabindex="-1"></a>x / y = 0.440000 + 0.080000i</span></code></pre></div>
<p>También puede comparar dos números complejos para la igualdad (o desigualdad):</p>
<div class="sourceCode" id="cb710"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb710-1"><a href="#cb710-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb710-2"><a href="#cb710-2"></a><span class="pp">#include </span><span class="im">&lt;complex.h&gt;</span></span>
<span id="cb710-3"><a href="#cb710-3"></a></span>
<span id="cb710-4"><a href="#cb710-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb710-5"><a href="#cb710-5"></a><span class="op">{</span></span>
<span id="cb710-6"><a href="#cb710-6"></a>    <span class="dt">double</span> <span class="dt">complex</span> x <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>I<span class="op">;</span></span>
<span id="cb710-7"><a href="#cb710-7"></a>    <span class="dt">double</span> <span class="dt">complex</span> y <span class="op">=</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span><span class="op">*</span>I<span class="op">;</span></span>
<span id="cb710-8"><a href="#cb710-8"></a></span>
<span id="cb710-9"><a href="#cb710-9"></a>    printf<span class="op">(</span><span class="st">&quot;x == y = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x <span class="op">==</span> y<span class="op">);</span>  <span class="co">// 0</span></span>
<span id="cb710-10"><a href="#cb710-10"></a>    printf<span class="op">(</span><span class="st">&quot;x != y = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x <span class="op">!=</span> y<span class="op">);</span>  <span class="co">// 1</span></span>
<span id="cb710-11"><a href="#cb710-11"></a><span class="op">}</span></span></code></pre></div>
<p>con la salida:</p>
<div class="sourceCode" id="cb711"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb711-1"><a href="#cb711-1" aria-hidden="true" tabindex="-1"></a>x == y = 0</span>
<span id="cb711-2"><a href="#cb711-2" aria-hidden="true" tabindex="-1"></a>x != y = 1</span></code></pre></div>
<p>Son iguales si ambos componentes prueban igual. Tenga en cuenta que, al igual que ocurre con todas las operaciones en coma flotante, podrían ser iguales si se aproximan lo suficiente debido a un error de redondeo<a href="#fn184" class="footnote-ref" id="fnref184" role="doc-noteref"><sup>184</sup></a>.</p>
<p></p>
<h2 data-number="36.5" id="matemáticas-complejas"><span class="header-section-number">36.5</span> Matemáticas complejas</h2>
<p>Pero, ¡espera! Hay mucho más que simple aritmética compleja.</p>
<p>Aquí tienes una tabla resumen de todas las funciones matemáticas disponibles con números complejos.</p>
<p>Sólo voy a listar la versión <code>doble</code> de cada función, pero para todas ellas hay una versión <code>float</code> que puedes obtener añadiendo <code>f</code> al nombre de la función, y una versión <code>long double</code> que puedes obtener añadiendo <code>l</code>.</p>
<p>Por ejemplo, la función <code>cabs()</code> para calcular el valor absoluto de un número complejo también tiene variantes <code>cabsf()</code> y <code>cabsl()</code>. Las omito por brevedad.</p>
<h3 data-number="36.5.1" id="funciones-de-trigonometría"><span class="header-section-number">36.5.1</span> Funciones de trigonometría</h3>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ccos()</code></td>
<td>Coseno</td>
</tr>
<tr class="even">
<td><code>csin()</code></td>
<td>Seno</td>
</tr>
<tr class="odd">
<td><code>ctan()</code></td>
<td>Tangente</td>
</tr>
<tr class="even">
<td><code>cacos()</code></td>
<td>Arco coseno</td>
</tr>
<tr class="odd">
<td><code>casin()</code></td>
<td>Arco seno</td>
</tr>
<tr class="even">
<td><code>catan()</code></td>
<td>Jugar a <em>Settlers of Catan</em></td>
</tr>
<tr class="odd">
<td><code>ccosh()</code></td>
<td>Coseno hiperbólico</td>
</tr>
<tr class="even">
<td><code>csinh()</code></td>
<td>Hyperbolic sine</td>
</tr>
<tr class="odd">
<td><code>ctanh()</code></td>
<td>Tangente hiperbólica</td>
</tr>
<tr class="even">
<td><code>cacosh()</code></td>
<td>Arco coseno hiperbólico</td>
</tr>
<tr class="odd">
<td><code>casinh()</code></td>
<td>Arco seno hiperbólico</td>
</tr>
<tr class="even">
<td><code>catanh()</code></td>
<td>Arco hiperbólico tangente</td>
</tr>
</tbody>
</table>
<h3 data-number="36.5.2" id="funciones-exponenciales-y-logarítmicas"><span class="header-section-number">36.5.2</span> Funciones exponenciales y logarítmicas</h3>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Función</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>cexp()</code></td>
<td>Base-<span class="math inline">\(e\)</span> exponente</td>
</tr>
<tr class="even">
<td><code>clog()</code></td>
<td>Logaritmo natural (base-<span class="math inline">\(e\)</span>)</td>
</tr>
</tbody>
</table>
<h3 data-number="36.5.3" id="funciones-de-potencia-y-valor-absoluto"><span class="header-section-number">36.5.3</span> Funciones de potencia y valor absoluto</h3>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Función</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>cabs()</code></td>
<td>Valor absoluto</td>
</tr>
<tr class="even">
<td><code>cpow()</code></td>
<td>Potencia</td>
</tr>
<tr class="odd">
<td><code>csqrt()</code></td>
<td>Raíz cuadrada</td>
</tr>
</tbody>
</table>
<h3 data-number="36.5.4" id="funciones-de-manipulación"><span class="header-section-number">36.5.4</span> Funciones de manipulación</h3>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Función</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>creal()</code></td>
<td>Devolver parte real</td>
</tr>
<tr class="even">
<td><code>cimag()</code></td>
<td>Devolver parte imaginaria</td>
</tr>
<tr class="odd">
<td><code>CMPLX()</code></td>
<td>Construir un número complejo</td>
</tr>
<tr class="even">
<td><code>carg()</code></td>
<td>Argumento/ángulo de fase</td>
</tr>
<tr class="odd">
<td><code>conj()</code></td>
<td>Conjugar<a href="#fn185" class="footnote-ref" id="fnref185" role="doc-noteref"><sup>185</sup></a></td>
</tr>
<tr class="even">
<td><code>cproj()</code></td>
<td>Proyección sobre la esfera de Riemann</td>
</tr>
</tbody>
</table>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="37" id="tipos-enteros-de-anchura-fija"><span class="header-section-number">37</span> Tipos enteros de anchura fija</h1>
<p></p>
<p>C tiene todos esos tipos de enteros pequeños, grandes y más grandes como <code>int</code> y <code>long</code> y todo eso. Y puedes mirar en <a href="#limits-macros">la sección sobre límites</a> para ver cuál es el int más grande con <code>INT_MAX</code> y así sucesivamente.</p>
<p>¿Qué tamaño tienen esos tipos? Es decir, ¿cuántos bytes ocupan? Podríamos usar <code>sizeof</code> para obtener esa respuesta.</p>
<p>Pero, ¿y si quisiera ir por otro camino? ¿Y si necesitara un tipo que tuviera exactamente 32 bits (4 bytes) o al menos 16 bits o algo así?</p>
<p>¿Cómo podemos declarar un tipo que tenga un tamaño determinado? La cabecera <code>&lt;stdint.h&gt;</code> nos da una manera.</p>
<h2 data-number="37.1" id="tipos-con-tamaño-de-bit"><span class="header-section-number">37.1</span> Tipos con tamaño de bit</h2>
<p>Tanto para los enteros con signo como para los enteros sin signo, podemos especificar un tipo que tenga un cierto número de bits, con algunas salvedades, por supuesto.</p>
<p>Y hay tres clases principales de estos tipos (en estos ejemplos, el <code>N</code> sería reemplazado por un cierto número de bits):</p>
<ul>
<li>Enteros de exactamente un cierto tamaño (<code>intN_t</code>)</li>
<li>Enteros que tienen al menos un cierto tamaño (<code>int_leastN_t</code>)</li>
<li>Enteros que tienen al menos un cierto tamaño y son lo más rápidos posible (<code>int_fastN_t</code>)<a href="#fn186" class="footnote-ref" id="fnref186" role="doc-noteref"><sup>186</sup></a></li>
</ul>
<p>¿Cuánto más rápido es <code>fast</code>? Definitivamente, quizás algo más rápido. Probablemente. La especificación no dice cuánto más rápido, sólo que será el más rápido en esta arquitectura. Sin embargo, la mayoría de los compiladores de C son bastante buenos, por lo que probablemente sólo lo veas usado en lugares donde se necesita garantizar la mayor velocidad posible (en lugar de simplemente esperar que el compilador produzca un código bastante rápido, como es el caso).</p>
<p>Finalmente, estos tipos de números sin signo tienen una “u” inicial para diferenciarlos.</p>
<p>Por ejemplo, estos tipos tienen el significado listado correspondiente:</p>
<p> </p>
<div class="sourceCode" id="cb712"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb712-1"><a href="#cb712-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int32_t</span> w<span class="op">;</span> <span class="co">// x es exactamente 32 bits, con signo</span></span>
<span id="cb712-2"><a href="#cb712-2" aria-hidden="true" tabindex="-1"></a><span class="dt">uint16_t</span> x<span class="op">;</span> <span class="co">// y es exactamente 16 bits, sin signo</span></span>
<span id="cb712-3"><a href="#cb712-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb712-4"><a href="#cb712-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int_least8_t</span> y<span class="op">;</span> <span class="co">// y es de al menos 8 bits, con signo</span></span>
<span id="cb712-5"><a href="#cb712-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb712-6"><a href="#cb712-6" aria-hidden="true" tabindex="-1"></a><span class="dt">uint_fast64_t</span> z<span class="op">;</span> <span class="co">//z es la representación más rápida</span></span>
<span id="cb712-7"><a href="#cb712-7" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// sin signo de al menos 64 bits.</span></span></code></pre></div>
<p>Se garantiza la definición de los siguientes tipos:</p>
<div class="sourceCode" id="cb713"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb713-1"><a href="#cb713-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int_least8_t</span>      <span class="dt">uint_least8_t</span></span>
<span id="cb713-2"><a href="#cb713-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int_least16_t</span>     <span class="dt">uint_least16_t</span></span>
<span id="cb713-3"><a href="#cb713-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int_least32_t</span>     <span class="dt">uint_least32_t</span></span>
<span id="cb713-4"><a href="#cb713-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int_least64_t</span>     <span class="dt">uint_least64_t</span></span>
<span id="cb713-5"><a href="#cb713-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-6"><a href="#cb713-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int_fast8_t</span>       <span class="dt">uint_fast8_t</span></span>
<span id="cb713-7"><a href="#cb713-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int_fast16_t</span>      <span class="dt">uint_fast16_t</span></span>
<span id="cb713-8"><a href="#cb713-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int_fast32_t</span>      <span class="dt">uint_fast32_t</span></span>
<span id="cb713-9"><a href="#cb713-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int_fast64_t</span>      <span class="dt">uint_fast64_t</span></span></code></pre></div>
<p>También puede haber otros de diferentes anchos, pero son opcionales.</p>
<p>¿Dónde están los tipos fijos como <code>int16_t</code>? Resulta que son completamente opcionales… a menos que se cumplan ciertas condiciones<a href="#fn187" class="footnote-ref" id="fnref187" role="doc-noteref"><sup>187</sup></a>. Y si tienes un sistema informático moderno normal y corriente, probablemente se cumplan esas condiciones. Y si lo son, tendrás estos tipos:</p>
<div class="sourceCode" id="cb714"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb714-1"><a href="#cb714-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int8_t</span>      <span class="dt">uint8_t</span></span>
<span id="cb714-2"><a href="#cb714-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int16_t</span>     <span class="dt">uint16_t</span></span>
<span id="cb714-3"><a href="#cb714-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int32_t</span>     <span class="dt">uint32_t</span></span>
<span id="cb714-4"><a href="#cb714-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int64_t</span>     <span class="dt">uint64_t</span></span></code></pre></div>
<p>Pueden definirse otras variantes con anchuras diferentes, pero son opcionales.</p>
<p> </p>
<h2 data-number="37.2" id="tipo-de-tamaño-entero-máximo"><span class="header-section-number">37.2</span> Tipo de tamaño entero máximo</h2>
<p>Hay un tipo que puedes usar que contiene los enteros representables más grandes disponibles en el sistema, tanto con signo como sin signo:</p>
<p> </p>
<div class="sourceCode" id="cb715"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb715-1"><a href="#cb715-1" aria-hidden="true" tabindex="-1"></a><span class="dt">intmax_t</span></span>
<span id="cb715-2"><a href="#cb715-2" aria-hidden="true" tabindex="-1"></a><span class="dt">uintmax_t</span></span></code></pre></div>
<p> </p>
<p>Utilice estos tipos cuando quiera ir lo más grande posible.</p>
<p>Obviamente los valores de cualquier otro tipo entero del mismo signo cabrán en este tipo, necesariamente.</p>
<h2 data-number="37.3" id="uso-de-constantes-de-tamaño-fijo"><span class="header-section-number">37.3</span> Uso de Constantes de Tamaño Fijo</h2>
<p>Si tienes una constante que quieres que quepa en un cierto número de bits, puedes usar estas macros para añadir automáticamente el sufijo apropiado al número (por ejemplo <code>22L</code> o <code>3490ULL</code>).</p>
<p> </p>
<div class="sourceCode" id="cb716"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb716-1"><a href="#cb716-1" aria-hidden="true" tabindex="-1"></a>INT8_C<span class="op">(</span>x<span class="op">)</span>     UINT8_C<span class="op">(</span>x<span class="op">)</span></span>
<span id="cb716-2"><a href="#cb716-2" aria-hidden="true" tabindex="-1"></a>INT16_C<span class="op">(</span>x<span class="op">)</span>    UINT16_C<span class="op">(</span>x<span class="op">)</span></span>
<span id="cb716-3"><a href="#cb716-3" aria-hidden="true" tabindex="-1"></a>INT32_C<span class="op">(</span>x<span class="op">)</span>    UINT32_C<span class="op">(</span>x<span class="op">)</span></span>
<span id="cb716-4"><a href="#cb716-4" aria-hidden="true" tabindex="-1"></a>INT64_C<span class="op">(</span>x<span class="op">)</span>    UINT64_C<span class="op">(</span>x<span class="op">)</span></span>
<span id="cb716-5"><a href="#cb716-5" aria-hidden="true" tabindex="-1"></a>INTMAX_C<span class="op">(</span>x<span class="op">)</span>   UINTMAX_C<span class="op">(</span>x<span class="op">)</span></span></code></pre></div>
<p> </p>
<p>De nuevo, sólo funcionan con valores enteros constantes.</p>
<p>Por ejemplo, podemos utilizar uno de estos para asignar valores constantes así:</p>
<div class="sourceCode" id="cb717"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb717-1"><a href="#cb717-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint16_t</span> x <span class="op">=</span> UINT16_C<span class="op">(</span><span class="dv">12</span><span class="op">);</span></span>
<span id="cb717-2"><a href="#cb717-2" aria-hidden="true" tabindex="-1"></a><span class="dt">intmax_t</span> y <span class="op">=</span> INTMAX_C<span class="op">(</span><span class="dv">3490</span><span class="op">);</span></span></code></pre></div>
<p> </p>
<h2 data-number="37.4" id="límites-de-enteros-de-tamaño-fijo"><span class="header-section-number">37.4</span> Límites de enteros de tamaño fijo</h2>
<p>También tenemos definidos algunos límites para que puedas obtener los valores máximos y mínimos de estos tipos:</p>
<p> </p>
<div class="sourceCode" id="cb718"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb718-1"><a href="#cb718-1" aria-hidden="true" tabindex="-1"></a>INT8_MAX           INT8_MIN           UINT8_MAX</span>
<span id="cb718-2"><a href="#cb718-2" aria-hidden="true" tabindex="-1"></a>INT16_MAX          INT16_MIN          UINT16_MAX</span>
<span id="cb718-3"><a href="#cb718-3" aria-hidden="true" tabindex="-1"></a>INT32_MAX          INT32_MIN          UINT32_MAX</span>
<span id="cb718-4"><a href="#cb718-4" aria-hidden="true" tabindex="-1"></a>INT64_MAX          INT64_MIN          UINT64_MAX</span>
<span id="cb718-5"><a href="#cb718-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb718-6"><a href="#cb718-6" aria-hidden="true" tabindex="-1"></a>INT_LEAST8_MAX     INT_LEAST8_MIN     UINT_LEAST8_MAX</span>
<span id="cb718-7"><a href="#cb718-7" aria-hidden="true" tabindex="-1"></a>INT_LEAST16_MAX    INT_LEAST16_MIN    UINT_LEAST16_MAX</span>
<span id="cb718-8"><a href="#cb718-8" aria-hidden="true" tabindex="-1"></a>INT_LEAST32_MAX    INT_LEAST32_MIN    UINT_LEAST32_MAX</span>
<span id="cb718-9"><a href="#cb718-9" aria-hidden="true" tabindex="-1"></a>INT_LEAST64_MAX    INT_LEAST64_MIN    UINT_LEAST64_MAX</span>
<span id="cb718-10"><a href="#cb718-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb718-11"><a href="#cb718-11" aria-hidden="true" tabindex="-1"></a>INT_FAST8_MAX      INT_FAST8_MIN      UINT_FAST8_MAX</span>
<span id="cb718-12"><a href="#cb718-12" aria-hidden="true" tabindex="-1"></a>INT_FAST16_MAX     INT_FAST16_MIN     UINT_FAST16_MAX</span>
<span id="cb718-13"><a href="#cb718-13" aria-hidden="true" tabindex="-1"></a>INT_FAST32_MAX     INT_FAST32_MIN     UINT_FAST32_MAX</span>
<span id="cb718-14"><a href="#cb718-14" aria-hidden="true" tabindex="-1"></a>INT_FAST64_MAX     INT_FAST64_MIN     UINT_FAST64_MAX</span>
<span id="cb718-15"><a href="#cb718-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb718-16"><a href="#cb718-16" aria-hidden="true" tabindex="-1"></a>INTMAX_MAX         INTMAX_MIN         UINTMAX_MAX</span></code></pre></div>
<p> </p>
<p>Tenga en cuenta que <code>MIN</code> para todos los tipos sin signo es <code>0</code>, por lo que, como tal, no hay macro para ello.</p>
<p> </p>
<h2 data-number="37.5" id="especificadores-de-formato"><span class="header-section-number">37.5</span> Especificadores de formato</h2>
<p>Para imprimir estos tipos, necesita enviar el especificador de formato correcto a <code>printf()</code>. (Y lo mismo para obtener la entrada con la función <code>scanf()</code>). <code>scanf()</code>.)</p>
<p>Pero, ¿cómo vas a saber qué tamaño tienen los tipos bajo el capó? Por suerte, una vez más, C proporciona algunas macros para ayudar con esto.</p>
<p>Todo esto se puede encontrar en <code>&lt;inttypes.h&gt;</code>.</p>
<p>Ahora, tenemos un montón de macros. Como una explosión de complejidad de macros. Así que voy a dejar de enumerar cada una y sólo voy a poner la letra minúscula <code>n</code> en el lugar donde deberías poner <code>8</code>, <code>16</code>, <code>32</code>, o <code>64</code> dependiendo de tus necesidades.</p>
<p>Veamos las macros para imprimir enteros con signo:</p>
<p> </p>
<div class="sourceCode" id="cb719"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb719-1"><a href="#cb719-1" aria-hidden="true" tabindex="-1"></a>PRIdn    PRIdLEASTn    PRIdFASTn    PRIdMAX</span>
<span id="cb719-2"><a href="#cb719-2" aria-hidden="true" tabindex="-1"></a>PRIin    PRIiLEASTn    PRIiFASTn    PRIiMAX</span></code></pre></div>
<p>Busque allí los patrones. Puedes ver que hay variantes para los tipos fijo, mínimo, rápido y máximo.</p>
<p>Y también tienes una “d” minúscula y una “i” minúscula. Corresponden a los especificadores de formato <code>printf()</code> <code>%d</code> y <code>%i</code>.</p>
<p>Así que si tengo algo de tipo</p>
<div class="sourceCode" id="cb720"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb720-1"><a href="#cb720-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int_least16_t</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span></code></pre></div>
<p>Puedo imprimirlo con el especificador de formato equivalente para <code>%d</code> utilizando <code>PRIdLEAST16</code>.</p>
<p>¿Pero cómo? ¿Cómo usamos esa macro?</p>
<p>En primer lugar, esa macro especifica una cadena que contiene la letra o letras que <code>printf()</code> necesita usar para imprimir ese tipo. Como, por ejemplo, podría ser <code>"d"</code> o <code>"ld"</code>.</p>
<p>Así que todo lo que tenemos que hacer es incrustar eso en nuestra cadena de formato para la llamada a <code>printf()</code>.</p>
<p>Para ello, podemos aprovechar un hecho sobre C que puede que hayas olvidado: las cadenas literales adyacentes se concatenan automáticamente en una sola cadena. Por ejemplo</p>
<div class="sourceCode" id="cb721"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb721-1"><a href="#cb721-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Hello, &quot;</span> <span class="st">&quot;world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>   <span class="co">// Imprime &quot;Hello, world!&quot;</span></span></code></pre></div>
<p>Y como estas macros son literales de cadena, podemos usarlas así:</p>
<div class="sourceCode" id="cb722"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb722-1"><a href="#cb722-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb722-2"><a href="#cb722-2"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb722-3"><a href="#cb722-3"></a><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span></span>
<span id="cb722-4"><a href="#cb722-4"></a></span>
<span id="cb722-5"><a href="#cb722-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb722-6"><a href="#cb722-6"></a><span class="op">{</span></span>
<span id="cb722-7"><a href="#cb722-7"></a>    <span class="dt">int_least16_t</span> x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb722-8"><a href="#cb722-8"></a></span>
<span id="cb722-9"><a href="#cb722-9"></a>    printf<span class="op">(</span><span class="st">&quot;The value is %&quot;</span> PRIdLEAST16 <span class="st">&quot;!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb722-10"><a href="#cb722-10"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>También tenemos un montón de macros para imprimir tipos sin signo:</p>
<p> </p>
<div class="sourceCode" id="cb723"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb723-1"><a href="#cb723-1" aria-hidden="true" tabindex="-1"></a>PRIon    PRIoLEASTn    PRIoFASTn    PRIoMAX</span>
<span id="cb723-2"><a href="#cb723-2" aria-hidden="true" tabindex="-1"></a>PRIun    PRIuLEASTn    PRIuFASTn    PRIuMAX</span>
<span id="cb723-3"><a href="#cb723-3" aria-hidden="true" tabindex="-1"></a>PRIxn    PRIxLEASTn    PRIxFASTn    PRIxMAX</span>
<span id="cb723-4"><a href="#cb723-4" aria-hidden="true" tabindex="-1"></a>PRIXn    PRIXLEASTn    PRIXFASTn    PRIXMAX</span></code></pre></div>
<p>En este caso, <code>o</code>, <code>u</code>, <code>x</code>, y <code>X</code> corresponden a los especificadores de formato documentados en <code>printf()</code>.</p>
<p>Y, como antes, la minúscula <code>n</code> debe sustituirse por <code>8</code>, <code>16</code>, <code>32</code>, o <code>64</code>.</p>
<p> </p>
<p>Pero justo cuando crees que ya has tenido suficiente con las macros, resulta que tenemos un completo conjunto complementario de ellas para ¡<code>scanf()</code>!</p>
<p> </p>
<div class="sourceCode" id="cb724"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb724-1"><a href="#cb724-1" aria-hidden="true" tabindex="-1"></a>SCNdn    SCNdLEASTn    SCNdFASTn    SCNdMAX</span>
<span id="cb724-2"><a href="#cb724-2" aria-hidden="true" tabindex="-1"></a>SCNin    SCNiLEASTn    SCNiFASTn    SCNiMAX</span>
<span id="cb724-3"><a href="#cb724-3" aria-hidden="true" tabindex="-1"></a>SCNon    SCNoLEASTn    SCNoFASTn    SCNoMAX</span>
<span id="cb724-4"><a href="#cb724-4" aria-hidden="true" tabindex="-1"></a>SCNun    SCNuLEASTn    SCNuFASTn    SCNuMAX</span>
<span id="cb724-5"><a href="#cb724-5" aria-hidden="true" tabindex="-1"></a>SCNxn    SCNxLEASTn    SCNxFASTn    SCNxMAX</span></code></pre></div>
<p> </p>
<p>Recuerde: cuando quiera imprimir un tipo entero de tamaño fijo con <code>printf()</code> o <code>scanf()</code>, tome la especificación de formato correspondiente de <code>&lt;inttypes.h&gt;</code>.</p>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="38" id="funciones-de-fecha-y-hora"><span class="header-section-number">38</span> Funciones de fecha y hora</h1>
<blockquote>
<p>“El tiempo es una ilusión. La hora de comer doblemente”.<br />
—Ford Prefect, La guía del autoestopista galáctico</p>
</blockquote>
<p></p>
<p>Esto no es demasiado complejo, pero puede ser un poco intimidante al principio, tanto con los diferentes tipos disponibles y la forma en que podemos convertir entre ellos.</p>
<p>Mezcla GMT (UTC) y la hora local y tenemos toda la <em>Usual Fun</em>™ que uno consigue con horas y fechas.</p>
<p>Y, por supuesto, nunca olvides la regla de oro de las fechas y horas: <em>Nunca intentes escribir tu propia funcionalidad de fecha y hora. Sólo usa lo que te da la librería.</em></p>
<p>El tiempo es demasiado complejo para que los simples programadores mortales lo manejen correctamente. En serio, todos debemos un punto a todos los que trabajaron en cualquier librería de fecha y hora, así que ponlo en tu presupuesto.</p>
<h2 data-number="38.1" id="terminología-rápida-e-información"><span class="header-section-number">38.1</span> Terminología rápida e información</h2>
<p>Sólo un par de términos rápidos en caso de que no los tengas apuntados. * <strong>UTC</strong>: El Tiempo Universal Coordinado (Universal Time Coordinated) es una hora absoluta acordada universalmente<a href="#fn188" class="footnote-ref" id="fnref188" role="doc-noteref"><sup>188</sup></a>. Todo el mundo en el planeta piensa que es la misma hora ahora mismo en UTC… aunque tengan diferentes horas locales.</p>
<ul>
<li><p> <strong>GMT</strong>: Hora del meridiano de Greenwich, efectivamente la misma que la UTC<a href="#fn189" class="footnote-ref" id="fnref189" role="doc-noteref"><sup>189</sup></a>. Probablemente quieras decir UTC, o “hora universal”. Si te refieres específicamente a la zona horaria GMT, di GMT. Confusamente, muchas de las funciones UTC de C son anteriores a UTC y todavía se refieren a la hora media de Greenwich. Cuando vea eso, sepa que C quiere decir UTC.</p></li>
<li><p> <strong>Hora local</strong>: qué hora es en el lugar donde se encuentra el ordenador que ejecuta el programa. Se describe como un desfase con respecto a UTC. Aunque hay muchas zonas horarias en el mundo, la mayoría de los ordenadores trabajan en hora local o UTC.</p></li>
</ul>
<p></p>
<p>Como regla general, si estás describiendo un evento que ocurre una sola vez, como una entrada de registro, o el lanzamiento de un cohete, o cuando los punteros finalmente hicieron clic para ti, utiliza UTC.</p>
<p></p>
<p>En cambio, si se trata de algo que ocurre a la misma hora <em>en todas las zonas horarias</em>, como Nochevieja o la hora de cenar, utiliza la hora local.</p>
<p>Dado que muchos lenguajes sólo son buenos en la conversión entre UTC y hora local, puedes causarte mucho dolor si eliges almacenar tus fechas en la forma incorrecta. (Pregúntame cómo lo sé).</p>
<p> </p>
<h2 data-number="38.2" id="tipos-de-fecha"><span class="header-section-number">38.2</span> Tipos de fecha</h2>
<p>Hay dos<a href="#fn190" class="footnote-ref" id="fnref190" role="doc-noteref"><sup>190</sup></a> tipos principales en C cuando se trata de fechas: <code>time_t</code> y <code>struct tm</code>.</p>
<p>La especificación no dice mucho sobre ellos:</p>
<ul>
<li><p> <code>time_t</code>: un tipo real capaz de contener un tiempo. Según la especificación, puede ser un tipo flotante o un tipo entero. En POSIX (Unix-likes), es un entero. Esto contiene <em>tiempo de calendario</em>. Que se puede considerar como la hora UTC.</p></li>
<li><p> <code>struct tm</code>: contiene los componentes de una hora de calendario. Se trata de una <em>hora desglosada</em>, es decir, los componentes de la hora, como hora, minuto, segundo, día, mes, año, etc.</p></li>
</ul>
<p></p>
<p>En muchos sistemas, <code>time_t</code> representa el número de segundos transcurridos desde <a href="https://en.wikipedia.org/wiki/Unix_time"><em>Época(Epoch)</em></a><a href="#fn191" class="footnote-ref" id="fnref191" role="doc-noteref"><sup>191</sup></a>.. Epoch es en cierto modo el comienzo del tiempo desde la perspectiva del ordenador, que es comúnmente el 1 de enero de 1970 UTC. <code>time_t</code> puede ser negativo para representar tiempos anteriores a Epoch. Windows se comporta de la misma manera que Unix por lo que puedo decir.</p>
<p> </p>
<p>¿Y qué hay en una <code>struct tm</code>? Los siguientes campos:</p>
<div class="sourceCode" id="cb725"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb725-1"><a href="#cb725-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> tm <span class="op">{</span></span>
<span id="cb725-2"><a href="#cb725-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_sec<span class="op">;</span> <span class="co">// segundos después del minuto -- [0, 60]</span></span>
<span id="cb725-3"><a href="#cb725-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_min<span class="op">;</span> <span class="co">// minutos después de la hora -- [0, 59]</span></span>
<span id="cb725-4"><a href="#cb725-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_hour<span class="op">;</span> <span class="co">// horas desde medianoche -- [0, 23]</span></span>
<span id="cb725-5"><a href="#cb725-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_mday<span class="op">;</span> <span class="co">// día del mes -- [1, 31]</span></span>
<span id="cb725-6"><a href="#cb725-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_mon<span class="op">;</span> <span class="co">// meses desde enero -- [0, 11]</span></span>
<span id="cb725-7"><a href="#cb725-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_year<span class="op">;</span> <span class="co">// años desde 1900</span></span>
<span id="cb725-8"><a href="#cb725-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_wday<span class="op">;</span> <span class="co">// días desde el domingo -- [0, 6]</span></span>
<span id="cb725-9"><a href="#cb725-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_yday<span class="op">;</span> <span class="co">// días desde el 1 de enero -- [0, 365]</span></span>
<span id="cb725-10"><a href="#cb725-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tm_isdst<span class="op">;</span> <span class="co">// indicador del horario de verano</span></span>
<span id="cb725-11"><a href="#cb725-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Tenga en cuenta que todo tiene base cero excepto el día del mes.</p>
<p>Es importante saber que puedes poner los valores que quieras en estos tipos. Hay funciones que ayudan a obtener la hora <em>ahora</em>, pero los tipos contienen <em>una</em> hora, no <em>la</em> hora.</p>
<p></p>
<p>Así que la pregunta es: “¿Cómo se inicializan los datos de estos tipos, y cómo se convierten entre ellos?”</p>
<h2 data-number="38.3" id="inicialización-y-conversión-entre-tipos"><span class="header-section-number">38.3</span> Inicialización y conversión entre tipos</h2>
<p></p>
<p>En primer lugar, puedes obtener la hora actual y almacenarla en un <code>time_t</code> con la función <code>time()</code>.</p>
<div class="sourceCode" id="cb726"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb726-1"><a href="#cb726-1" aria-hidden="true" tabindex="-1"></a><span class="dt">time_t</span> now<span class="op">;</span>  <span class="co">// Variable para mantener la hora actual</span></span>
<span id="cb726-2"><a href="#cb726-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb726-3"><a href="#cb726-3" aria-hidden="true" tabindex="-1"></a>now <span class="op">=</span> time<span class="op">(</span>NULL<span class="op">);</span>  <span class="co">// Puedes conseguirlo así...</span></span>
<span id="cb726-4"><a href="#cb726-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb726-5"><a href="#cb726-5" aria-hidden="true" tabindex="-1"></a>time<span class="op">(&amp;</span>now<span class="op">);</span>        <span class="co">// ...o esto. Igual que la línea anterior.</span></span></code></pre></div>
<p>Estupendo. Ahora tienes una variable que te da la hora.</p>
<p> </p>
<p>Curiosamente, sólo hay una forma portable de imprimir lo que hay en un <code>time_t</code>, y es la función <code>ctime()</code>, raramente utilizada, que imprime el valor en tiempo local:</p>
<div class="sourceCode" id="cb727"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb727-1"><a href="#cb727-1" aria-hidden="true" tabindex="-1"></a>now <span class="op">=</span> time<span class="op">(</span>NULL<span class="op">);</span></span>
<span id="cb727-2"><a href="#cb727-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> ctime<span class="op">(&amp;</span>now<span class="op">));</span></span></code></pre></div>
<p>Devuelve una cadena con una forma muy específica que incluye una nueva línea al final:</p>
<div class="sourceCode" id="cb728"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb728-1"><a href="#cb728-1" aria-hidden="true" tabindex="-1"></a>Sun Feb 28 18:47:25 2021</span></code></pre></div>
<p></p>
<p>Así que eso es un poco inflexible. Si quieres más control, deberías convertir ese <code>time_t</code> en un <code>struct tm</code>.</p>
<h3 data-number="38.3.1" id="convertir-time_t-en-struct-tm"><span class="header-section-number">38.3.1</span> Convertir <code>time_t</code> en <code>struct tm</code></h3>
<p></p>
<p>Hay dos formas increíbles de hacer esta conversión:</p>
<p></p>
<ul>
<li><code>localtime()</code>: esta función convierte un <code>time_t</code> en un <code>struct tm</code> en tiempo local.</li>
</ul>
<p></p>
<ul>
<li><code>gmtime()</code>: esta función convierte un <code>time_t</code> en un <code>struct tm</code> en UTC. (¿Ves el antiguo GMT en el nombre de la función?)</li>
</ul>
<p></p>
<p>Veamos qué hora es ahora imprimiendo una <code>struct tm</code> con la función <code>asctime()</code>:</p>
<div class="sourceCode" id="cb729"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb729-1"><a href="#cb729-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Local: </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> asctime<span class="op">(</span>localtime<span class="op">(&amp;</span>now<span class="op">)));</span></span>
<span id="cb729-2"><a href="#cb729-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;  UTC: </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> asctime<span class="op">(</span>gmtime<span class="op">(&amp;</span>now<span class="op">)));</span></span></code></pre></div>
<p> </p>
<p>Salida (estoy en la zona horaria estándar del Pacífico):</p>
<div class="sourceCode" id="cb730"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb730-1"><a href="#cb730-1" aria-hidden="true" tabindex="-1"></a>Local: Sun Feb 28 20:15:27 2021</span>
<span id="cb730-2"><a href="#cb730-2" aria-hidden="true" tabindex="-1"></a>  UTC: Mon Mar  1 04:15:27 2021</span></code></pre></div>
<p>Una vez que tienes tu <code>time_t</code> en una <code>struct tm</code>, se abren todo tipo de puertas. Puede imprimir la hora de varias maneras, averiguar qué día de la semana es una fecha, y así sucesivamente. O convertirlo de nuevo en un <code>time_t</code>.</p>
<p>Pronto hablaremos de ello.</p>
<p></p>
<h3 data-number="38.3.2" id="convertir-struct-tm-a-time_t"><span class="header-section-number">38.3.2</span> Convertir <code>struct tm</code> a <code>time_t</code></h3>
<p> </p>
<p>Si quieres ir por otro camino, puedes usar <code>mktime()</code> para obtener esa información.</p>
<p><code>mktime()</code> establece los valores de <code>tm_wday</code> y <code>tm_yday</code> por ti, así que no te molestes en rellenarlos porque serán sobrescritos.</p>
<p>Además, puedes poner <code>tm_isdst</code> a <code>-1</code> para que lo determine por ti. O puede establecerlo manualmente en verdadero o falso.</p>
<div class="sourceCode" id="cb731"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb731-1"><a href="#cb731-1" aria-hidden="true" tabindex="-1"></a><span class="co">// No tenga la tentación de poner ceros a la izquierda en estos números</span></span>
<span id="cb731-2"><a href="#cb731-2" aria-hidden="true" tabindex="-1"></a><span class="co">// (a menos que usted quiera que estén en octal)</span></span>
<span id="cb731-3"><a href="#cb731-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb731-4"><a href="#cb731-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> tm algún_tiempo <span class="op">=</span> <span class="op">{</span></span>
<span id="cb731-5"><a href="#cb731-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>tm_year<span class="op">=</span><span class="dv">82</span><span class="op">,</span> <span class="co">// años desde 1900</span></span>
<span id="cb731-6"><a href="#cb731-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>tm_mon<span class="op">=</span><span class="dv">3</span><span class="op">,</span> <span class="co">// meses desde enero -- [0, 11]</span></span>
<span id="cb731-7"><a href="#cb731-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>tm_mday<span class="op">=</span><span class="dv">12</span><span class="op">,</span> <span class="co">// día del mes -- [1, 31]</span></span>
<span id="cb731-8"><a href="#cb731-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>tm_hour<span class="op">=</span><span class="dv">12</span><span class="op">,</span> <span class="co">// horas desde medianoche -- [0, 23]</span></span>
<span id="cb731-9"><a href="#cb731-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>tm_min<span class="op">=</span><span class="dv">0</span><span class="op">,</span> <span class="co">// minutos después de la hora -- [0, 59]</span></span>
<span id="cb731-10"><a href="#cb731-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>tm_sec<span class="op">=</span><span class="dv">4</span><span class="op">,</span> <span class="co">// segundos después del minuto -- [0, 60]</span></span>
<span id="cb731-11"><a href="#cb731-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>tm_isdst<span class="op">=-</span><span class="dv">1</span><span class="op">,</span> <span class="co">// indicador del horario de verano</span></span>
<span id="cb731-12"><a href="#cb731-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb731-13"><a href="#cb731-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb731-14"><a href="#cb731-14" aria-hidden="true" tabindex="-1"></a><span class="dt">time_t</span> some_time_epoch<span class="op">;</span></span>
<span id="cb731-15"><a href="#cb731-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb731-16"><a href="#cb731-16" aria-hidden="true" tabindex="-1"></a>some_time_epoch <span class="op">=</span> mktime<span class="op">(&amp;</span>some_time<span class="op">);</span></span>
<span id="cb731-17"><a href="#cb731-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb731-18"><a href="#cb731-18" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> ctime<span class="op">(&amp;</span>some_time_epoch<span class="op">));</span></span>
<span id="cb731-19"><a href="#cb731-19" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Is DST: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> some_time<span class="op">.</span>tm_isdst<span class="op">);</span></span></code></pre></div>
<p>Salida:</p>
<div class="sourceCode" id="cb732"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb732-1"><a href="#cb732-1" aria-hidden="true" tabindex="-1"></a>Mon Apr 12 12:00:04 1982</span>
<span id="cb732-2"><a href="#cb732-2" aria-hidden="true" tabindex="-1"></a>Is DST: 0</span></code></pre></div>
<p>Cuando cargas manualmente una <code>struct tm</code> como esa, debería estar en hora local. <code>mktime()</code> convertirá esa hora local en una hora de calendario <code>time_t</code>.</p>
<p></p>
<p>Extrañamente, sin embargo, el estándar no nos da una manera de cargar una <code>struct tm</code> con una hora UTC y convertirla en un <code>time_t</code>. Si quieres hacer eso con Unix-likes, prueba la no-estándar . <code>timegm()</code>. En Windows, <code>_mkgmtime()</code>.</p>
<p></p>
<h2 data-number="38.4" id="salida-de-fecha-formateada"><span class="header-section-number">38.4</span> Salida de fecha formateada</h2>
<p>Ya hemos visto un par de formas de imprimir fechas formateadas en la pantalla. Con <code>time_t</code> podemos usar <code>ctime()</code>, y con <code>struct tm</code> podemos usar <code>asctime()</code>.</p>
<div class="sourceCode" id="cb733"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb733-1"><a href="#cb733-1" aria-hidden="true" tabindex="-1"></a><span class="dt">time_t</span> now <span class="op">=</span> time<span class="op">(</span>NULL<span class="op">);</span></span>
<span id="cb733-2"><a href="#cb733-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> tm <span class="op">*</span>local <span class="op">=</span> localtime<span class="op">(&amp;</span>now<span class="op">);</span></span>
<span id="cb733-3"><a href="#cb733-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> tm <span class="op">*</span>utc <span class="op">=</span> gmtime<span class="op">(&amp;</span>now<span class="op">);</span></span>
<span id="cb733-4"><a href="#cb733-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb733-5"><a href="#cb733-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Hora local: </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> ctime<span class="op">(&amp;</span>now<span class="op">));</span> <span class="co">// Hora local con time_t</span></span>
<span id="cb733-6"><a href="#cb733-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Hora local: </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> asctime<span class="op">(</span>local<span class="op">));</span> <span class="co">// Hora local con struct tm</span></span>
<span id="cb733-7"><a href="#cb733-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;UTC : </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> asctime<span class="op">(</span>utc<span class="op">));</span> <span class="co">// UTC con struct tm</span></span></code></pre></div>
<p>Pero, ¿y si te dijera, querido lector, que hay una forma de tener mucho más control sobre la impresión de la fecha?</p>
<p></p>
<p>Claro, podríamos pescar campos individuales de la <code>struct tm</code>, pero hay una gran función llamada <code>strftime()</code> que hará mucho del trabajo duro por ti. Es como <code>printf()</code>, ¡pero para fechas!</p>
<p>Veamos algunos ejemplos. En cada uno de ellos, pasamos un buffer de destino, un número máximo de caracteres a escribir, y luego una cadena de formato (al estilo de—pero no igual que—<code>printf()</code>) que le dice a <code>strftime()</code> qué componentes de una <code>struct tm</code> imprimir y cómo.</p>
<p>Puede añadir otros caracteres constantes para incluir en la salida de la cadena de formato, así, al igual que con <code>printf()</code>.</p>
<p>Obtenemos un <code>struct tm</code> en este caso de <code>localtime()</code>, pero cualquier fuente funciona bien.</p>
<div class="sourceCode" id="cb734"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb734-1"><a href="#cb734-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb734-2"><a href="#cb734-2"></a><span class="pp">#include </span><span class="im">&lt;time.h&gt;</span></span>
<span id="cb734-3"><a href="#cb734-3"></a></span>
<span id="cb734-4"><a href="#cb734-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb734-5"><a href="#cb734-5"></a><span class="op">{</span></span>
<span id="cb734-6"><a href="#cb734-6"></a>    <span class="dt">char</span> s<span class="op">[</span><span class="dv">128</span><span class="op">];</span></span>
<span id="cb734-7"><a href="#cb734-7"></a>    <span class="dt">time_t</span> now <span class="op">=</span> time<span class="op">(</span>NULL<span class="op">);</span></span>
<span id="cb734-8"><a href="#cb734-8"></a></span>
<span id="cb734-9"><a href="#cb734-9"></a>    <span class="co">// %c: print date as per current locale</span></span>
<span id="cb734-10"><a href="#cb734-10"></a>    strftime<span class="op">(</span>s<span class="op">,</span> <span class="kw">sizeof</span> s<span class="op">,</span> <span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span><span class="op">,</span> localtime<span class="op">(&amp;</span>now<span class="op">));</span></span>
<span id="cb734-11"><a href="#cb734-11"></a>    puts<span class="op">(</span>s<span class="op">);</span>   <span class="co">// Sun Feb 28 22:29:00 2021</span></span>
<span id="cb734-12"><a href="#cb734-12"></a></span>
<span id="cb734-13"><a href="#cb734-13"></a>    <span class="co">// %A: full weekday name</span></span>
<span id="cb734-14"><a href="#cb734-14"></a>    <span class="co">// %B: full month name</span></span>
<span id="cb734-15"><a href="#cb734-15"></a>    <span class="co">// %d: day of the month</span></span>
<span id="cb734-16"><a href="#cb734-16"></a>    strftime<span class="op">(</span>s<span class="op">,</span> <span class="kw">sizeof</span> s<span class="op">,</span> <span class="st">&quot;</span><span class="sc">%A</span><span class="st">, %B </span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> localtime<span class="op">(&amp;</span>now<span class="op">));</span></span>
<span id="cb734-17"><a href="#cb734-17"></a>    puts<span class="op">(</span>s<span class="op">);</span>   <span class="co">// Sunday, February 28</span></span>
<span id="cb734-18"><a href="#cb734-18"></a></span>
<span id="cb734-19"><a href="#cb734-19"></a>    <span class="co">// %I: hour (12 hour clock)</span></span>
<span id="cb734-20"><a href="#cb734-20"></a>    <span class="co">// %M: minute</span></span>
<span id="cb734-21"><a href="#cb734-21"></a>    <span class="co">// %S: second</span></span>
<span id="cb734-22"><a href="#cb734-22"></a>    <span class="co">// %p: AM or PM</span></span>
<span id="cb734-23"><a href="#cb734-23"></a>    strftime<span class="op">(</span>s<span class="op">,</span> <span class="kw">sizeof</span> s<span class="op">,</span> <span class="st">&quot;It&#39;s %I:%M:%S </span><span class="sc">%p</span><span class="st">&quot;</span><span class="op">,</span> localtime<span class="op">(&amp;</span>now<span class="op">));</span></span>
<span id="cb734-24"><a href="#cb734-24"></a>    puts<span class="op">(</span>s<span class="op">);</span>   <span class="co">// Es 10:29:00 PM</span></span>
<span id="cb734-25"><a href="#cb734-25"></a></span>
<span id="cb734-26"><a href="#cb734-26"></a>    <span class="co">// %F: ISO 8601 yyyy-mm-dd</span></span>
<span id="cb734-27"><a href="#cb734-27"></a>    <span class="co">// %T: ISO 8601 hh:mm:ss</span></span>
<span id="cb734-28"><a href="#cb734-28"></a>    <span class="co">// %z: ISO 8601 time zone offset</span></span>
<span id="cb734-29"><a href="#cb734-29"></a>    strftime<span class="op">(</span>s<span class="op">,</span> <span class="kw">sizeof</span> s<span class="op">,</span> <span class="st">&quot;ISO 8601: </span><span class="sc">%F</span><span class="st">T%T%z&quot;</span><span class="op">,</span> localtime<span class="op">(&amp;</span>now<span class="op">));</span></span>
<span id="cb734-30"><a href="#cb734-30"></a>    puts<span class="op">(</span>s<span class="op">);</span>   <span class="co">// ISO 8601: 2021-02-28T22:29:00-0800</span></span>
<span id="cb734-31"><a href="#cb734-31"></a><span class="op">}</span></span></code></pre></div>
<p>Hay <em>toneladas</em> de especificadores de formato de impresión de fecha para <code>strftime()</code>, así que asegúrese de comprobarlos en la fl[ página de referencia <code>strftime()</code> |https://beej.us/guide/bgclr/html/split/time.html#man-strftime]].</p>
<p></p>
<h2 data-number="38.5" id="más-resolución-con-timespec_get"><span class="header-section-number">38.5</span> Más Resolución con <code>timespec_get()</code></h2>
<p></p>
<p>Puede obtener el número de segundos y nanosegundos desde Epoch con <code>timespec_get()</code>.</p>
<p>Quizás.</p>
<p>Es posible que las implementaciones no tengan una resolución de nanosegundos (que es una milmillonésima parte de un segundo), así que quién sabe cuántos lugares significativos obtendrás, pero inténtalo y verás.</p>
<p></p>
<p>La función <code>timespec_get()</code> recibe dos argumentos. Uno es un puntero a una <code>struct timespec</code> que contiene la información horaria. Y el otro es la <code>base</code>, que la especificación te permite establecer a <code>TIME_UTC</code> indicando que estás interesado en segundos desde Epoch. (Otras implementaciones pueden ofrecer más opciones para la “base”).</p>
<p>Y la propia estructura tiene dos campos:</p>
<div class="sourceCode" id="cb735"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb735-1"><a href="#cb735-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> timespec <span class="op">{</span></span>
<span id="cb735-2"><a href="#cb735-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">time_t</span> tv_sec<span class="op">;</span>   <span class="co">// Segundos</span></span>
<span id="cb735-3"><a href="#cb735-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span>   tv_nsec<span class="op">;</span>  <span class="co">// Nanosegundos (milmillonésimas de segundo)</span></span>
<span id="cb735-4"><a href="#cb735-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>He aquí un ejemplo en el que obtenemos la hora y la imprimimos como valor entero y también como valor flotante:</p>
<div class="sourceCode" id="cb736"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb736-1"><a href="#cb736-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> timespec ts<span class="op">;</span></span>
<span id="cb736-2"><a href="#cb736-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb736-3"><a href="#cb736-3" aria-hidden="true" tabindex="-1"></a>timespec_get<span class="op">(&amp;</span>ts<span class="op">,</span> TIME_UTC<span class="op">);</span></span>
<span id="cb736-4"><a href="#cb736-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb736-5"><a href="#cb736-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%ld</span><span class="st"> s, </span><span class="sc">%ld</span><span class="st"> ns</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> ts<span class="op">.</span>tv_sec<span class="op">,</span> ts<span class="op">.</span>tv_nsec<span class="op">);</span></span>
<span id="cb736-6"><a href="#cb736-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb736-7"><a href="#cb736-7" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> float_time <span class="op">=</span> ts<span class="op">.</span>tv_sec <span class="op">+</span> ts<span class="op">.</span>tv_nsec<span class="op">/</span><span class="fl">1000000000.0</span><span class="op">;</span></span>
<span id="cb736-8"><a href="#cb736-8" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f</span><span class="st"> seconds since epoch</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> float_time<span class="op">);</span></span></code></pre></div>
<p>Ejemplo de salida:</p>
<div class="sourceCode" id="cb737"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb737-1"><a href="#cb737-1" aria-hidden="true" tabindex="-1"></a>1614581530 s, 806325800 ns</span>
<span id="cb737-2"><a href="#cb737-2" aria-hidden="true" tabindex="-1"></a>1614581530.806326 seconds since epoch</span></code></pre></div>
<p><code>struct timespec</code> también hace su aparición en un número de funciones de threading que necesitan ser capaces de especificar el tiempo con esa resolución.</p>
<p> </p>
<h2 data-number="38.6" id="diferencias-entre-tiempos"><span class="header-section-number">38.6</span> Diferencias entre tiempos</h2>
<p></p>
<p>Una nota rápida sobre cómo obtener la diferencia entre dos <code>time_t</code>s: ya que la especificación no dicta cómo ese tipo representa un tiempo, puede que no seas capaz de simplemente restar dos <code>time_t</code>s y obtener algo sensato<a href="#fn192" class="footnote-ref" id="fnref192" role="doc-noteref"><sup>192</sup></a>.</p>
<p></p>
<p>Por suerte, puede utilizar <code>difftime()</code> para calcular la diferencia en segundos entre dos fechas.</p>
<p>En el siguiente ejemplo, tenemos dos eventos que ocurren con cierta diferencia de tiempo, y usamos <code>difftime()</code> para calcular la diferencia.</p>
<div class="sourceCode" id="cb738"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb738-1"><a href="#cb738-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb738-2"><a href="#cb738-2"></a><span class="pp">#include </span><span class="im">&lt;time.h&gt;</span></span>
<span id="cb738-3"><a href="#cb738-3"></a></span>
<span id="cb738-4"><a href="#cb738-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb738-5"><a href="#cb738-5"></a><span class="op">{</span></span>
<span id="cb738-6"><a href="#cb738-6"></a>    <span class="kw">struct</span> tm time_a <span class="op">=</span> <span class="op">{</span></span>
<span id="cb738-7"><a href="#cb738-7"></a>        <span class="op">.</span>tm_year<span class="op">=</span><span class="dv">82</span><span class="op">,</span> <span class="co">// años desde 1900</span></span>
<span id="cb738-8"><a href="#cb738-8"></a>        <span class="op">.</span>tm_mon<span class="op">=</span><span class="dv">3</span><span class="op">,</span> <span class="co">// meses desde enero -- [0, 11]</span></span>
<span id="cb738-9"><a href="#cb738-9"></a>        <span class="op">.</span>tm_mday<span class="op">=</span><span class="dv">12</span><span class="op">,</span> <span class="co">// día del mes -- [1, 31]</span></span>
<span id="cb738-10"><a href="#cb738-10"></a>        <span class="op">.</span>tm_hour<span class="op">=</span><span class="dv">4</span><span class="op">,</span> <span class="co">// horas desde medianoche -- [0, 23]</span></span>
<span id="cb738-11"><a href="#cb738-11"></a>        <span class="op">.</span>tm_min<span class="op">=</span><span class="bn">00</span><span class="op">,</span> <span class="co">// minutos después de la hora -- [0, 59]</span></span>
<span id="cb738-12"><a href="#cb738-12"></a>        <span class="op">.</span>tm_sec<span class="op">=</span><span class="bn">04</span><span class="op">,</span> <span class="co">// segundos después del minuto -- [0, 60]</span></span>
<span id="cb738-13"><a href="#cb738-13"></a>        <span class="op">.</span>tm_isdst<span class="op">=-</span><span class="dv">1</span><span class="op">,</span> <span class="co">// indicador del horario de verano</span></span>
<span id="cb738-14"><a href="#cb738-14"></a>    <span class="op">};</span></span>
<span id="cb738-15"><a href="#cb738-15"></a></span>
<span id="cb738-16"><a href="#cb738-16"></a>    <span class="kw">struct</span> tm time_b <span class="op">=</span> <span class="op">{</span></span>
<span id="cb738-17"><a href="#cb738-17"></a>        <span class="op">.</span>tm_year<span class="op">=</span><span class="dv">120</span><span class="op">,</span> <span class="co">// años desde 1900</span></span>
<span id="cb738-18"><a href="#cb738-18"></a>        <span class="op">.</span>tm_mon<span class="op">=</span><span class="dv">10</span><span class="op">,</span> <span class="co">// meses desde enero -- [0, 11]</span></span>
<span id="cb738-19"><a href="#cb738-19"></a>        <span class="op">.</span>tm_mday<span class="op">=</span><span class="dv">15</span><span class="op">,</span> <span class="co">// día del mes -- [1, 31]</span></span>
<span id="cb738-20"><a href="#cb738-20"></a>        <span class="op">.</span>tm_hour<span class="op">=</span><span class="dv">16</span><span class="op">,</span> <span class="co">// horas desde medianoche -- [0, 23]</span></span>
<span id="cb738-21"><a href="#cb738-21"></a>        <span class="op">.</span>tm_min<span class="op">=</span><span class="dv">27</span><span class="op">,</span> <span class="co">// minutos después de la hora -- [0, 59]</span></span>
<span id="cb738-22"><a href="#cb738-22"></a>        <span class="op">.</span>tm_sec<span class="op">=</span><span class="bn">00</span><span class="op">,</span> <span class="co">// segundos después del minuto -- [0, 60]</span></span>
<span id="cb738-23"><a href="#cb738-23"></a>        <span class="op">.</span>tm_isdst<span class="op">=-</span><span class="dv">1</span><span class="op">,</span> <span class="co">// indicador del horario de verano</span></span>
<span id="cb738-24"><a href="#cb738-24"></a>    <span class="op">};</span></span>
<span id="cb738-25"><a href="#cb738-25"></a></span>
<span id="cb738-26"><a href="#cb738-26"></a>    <span class="dt">time_t</span> cal_a <span class="op">=</span> mktime<span class="op">(&amp;</span>time_a<span class="op">);</span></span>
<span id="cb738-27"><a href="#cb738-27"></a>    <span class="dt">time_t</span> cal_b <span class="op">=</span> mktime<span class="op">(&amp;</span>time_b<span class="op">);</span></span>
<span id="cb738-28"><a href="#cb738-28"></a></span>
<span id="cb738-29"><a href="#cb738-29"></a>    <span class="dt">double</span> diff <span class="op">=</span> difftime<span class="op">(</span>cal_b<span class="op">,</span> cal_a<span class="op">);</span></span>
<span id="cb738-30"><a href="#cb738-30"></a></span>
<span id="cb738-31"><a href="#cb738-31"></a>    <span class="dt">double</span> years <span class="op">=</span> diff <span class="op">/</span> <span class="dv">60</span> <span class="op">/</span> <span class="dv">60</span> <span class="op">/</span> <span class="dv">24</span> <span class="op">/</span> <span class="fl">365.2425</span><span class="op">;</span>  <span class="co">// bastante cerca</span></span>
<span id="cb738-32"><a href="#cb738-32"></a></span>
<span id="cb738-33"><a href="#cb738-33"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f</span><span class="st"> seconds (</span><span class="sc">%f</span><span class="st"> years) between events</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> diff<span class="op">,</span> years<span class="op">);</span></span>
<span id="cb738-34"><a href="#cb738-34"></a><span class="op">}</span></span></code></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb739"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb739-1"><a href="#cb739-1" aria-hidden="true" tabindex="-1"></a>1217996816.000000 seconds (38.596783 years) between events</span></code></pre></div>
<p>Y ya está. Recuerda usar <code>difftime()</code> para tomar la diferencia de tiempo. Aunque puedes simplemente restar en un sistema POSIX, es mejor ser portable.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="39" id="multihilo-multithreading"><span class="header-section-number">39</span> Multihilo (Multithreading)</h1>
<p></p>
<p>C11 introdujo, formalmente, el multithreading en el lenguaje C. Es muy similar a <a href="https://en.wikipedia.org/wiki/POSIX_Threads">POSIX threads</a><a href="#fn193" class="footnote-ref" id="fnref193" role="doc-noteref"><sup>193</sup></a>, si alguna vez los has usado.</p>
<p>Y si no, no te preocupes. Hablaremos de ello.</p>
<p>Sin embargo, ten en cuenta, que no pretendo que esto sea un tutorial completo de multihilo clásico<a href="#fn194" class="footnote-ref" id="fnref194" role="doc-noteref"><sup>194</sup></a>; tendrás que coger un libro diferente y muy grueso específicamente para eso. Lo siento.</p>
<p></p>
<p>El roscado es una característica opcional. Si un compilador C11+ define <code>__STDC_NO_THREADS__</code>, los hilos <strong>no</strong> estarán presentes en la librería. Por qué decidieron usar un sentido negativo en esa macro es algo que se me escapa, pero ahí estamos.</p>
<p>Puedes comprobarlo así:</p>
<div class="sourceCode" id="cb740"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb740-1"><a href="#cb740-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef __STDC_NO_THREADS__</span></span>
<span id="cb740-2"><a href="#cb740-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#error I need threads to build this program!</span></span>
<span id="cb740-3"><a href="#cb740-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p></p>
<p></p>
<p>Además, es posible que tenga que especificar ciertas opciones del enlazador durante la compilación. En el caso de los Unix, prueba añadir <code>-lpthreads</code> al final de la línea de órdenes para enlazar la librería <code>pthreads</code><a href="#fn195" class="footnote-ref" id="fnref195" role="doc-noteref"><sup>195</sup></a>:</p>
<div class="sourceCode" id="cb741"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb741-1"><a href="#cb741-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-std</span><span class="op">=</span>c11 <span class="at">-o</span> foo foo.c <span class="at">-lpthreads</span></span></code></pre></div>
<p></p>
<p>Si obtiene errores del enlazador en su sistema, podría deberse a que no se incluyó la biblioteca apropiada.</p>
<h2 data-number="39.1" id="background"><span class="header-section-number">39.1</span> Background</h2>
<p>Los hilos son una forma de hacer que todos esos brillantes núcleos de CPU por los que has pagado trabajen para ti en el mismo programa.</p>
<p>Normalmente, un programa en C se ejecuta en un único núcleo de la CPU. Pero si sabes cómo dividir el trabajo, puedes dar partes de él a un número de hilos y hacer que lo hagan simultáneamente.</p>
<p>Aunque la especificación no lo dice, en tu sistema es muy probable que C (o el SO a sus órdenes) intente equilibrar los hilos entre todos los núcleos de la CPU.</p>
<p>Y si tienes más hilos que núcleos, no pasa nada. Simplemente no te darás cuenta de todas esas ganancias si todos ellos están tratando de competir por el tiempo de CPU.</p>
<h2 data-number="39.2" id="cosas-que-puedes-hacer"><span class="header-section-number">39.2</span> Cosas que puedes hacer</h2>
<p>Puedes crear un hilo. Comenzará a ejecutar la función que especifiques. El hilo padre que lo generó también continuará ejecutándose.</p>
<p>Y puedes esperar a que el hilo se complete. Esto se llama <em>joining</em> (<em>unirse</em>).</p>
<p>O si no te importa cuando se complete el hilo y no quieres esperar, puedes <em>detach it</em> (<em>separarlo</em>).</p>
<p>Un hilo puede <em>exit</em> (<em>salir</em>) explícitamente, o puede llamarlo implícitamente <em>quits</em> (<em>se retira</em>) al volver de su función principal.</p>
<p>Un hilo también puede <em>Sleep</em> (<em>dormir</em>) durante un periodo de tiempo, sin hacer nada mientras otros hilos se ejecutan.</p>
<p>El programa <code>main()</code> también es un hilo.</p>
<p>Además, tenemos almacenamiento local de hilos, mutexes y variables condicionales. Pero hablaremos de ello más adelante. Por ahora, veamos sólo lo básico.</p>
<h2 data-number="39.3" id="razas-de-datos-y-la-biblioteca-estándar"><span class="header-section-number">39.3</span> Razas de datos y la biblioteca estándar</h2>
<p></p>
<p>Algunas de las funciones de la biblioteca estándar (por ejemplo, <code>asctime()</code> y <code>strtok()</code>) devuelven o utilizan elementos de datos <code>static</code> que no son threadsafe. Pero en general, a menos que se diga lo contrario, la biblioteca estándar hace un esfuerzo para serlo<a href="#fn196" class="footnote-ref" id="fnref196" role="doc-noteref"><sup>196</sup></a>.</p>
<p>Pero tenga cuidado. Si una función de la biblioteca estándar mantiene el estado entre llamadas en una variable que no te pertenece, o si una función devuelve un puntero a algo que no has pasado, no es threadsafe. </p>
<h2 data-number="39.4" id="creando-y-esperando-hilos"><span class="header-section-number">39.4</span> Creando y Esperando Hilos</h2>
<p>¡Vamos a hackear algo!</p>
<p>Crearemos algunos hilos (create) y esperaremos a que se completen (join).</p>
<p>Aunque primero tenemos que entender un poco.</p>
<p>Cada hilo se identifica por una variable opaca de tipo <code>thrd_t</code>. Es un identificador único por hilo en tu programa. Cuando creas un hilo, se le da un nuevo ID.</p>
<p>También, cuando creas el hilo, tienes que darle un puntero a una función para ejecutar, y un puntero a un argumento para pasarle (o <code>NULL</code> si no tienes nada que pasar).</p>
<p>El hilo comenzará la ejecución de la función que especifiques.</p>
<p>Cuando quieras esperar a que un hilo se complete, tienes que especificar su ID de hilo para que C sepa a cuál esperar.</p>
<p>Así que la idea básica es</p>
<ol type="1">
<li>Escribe una función que actúe como “<code>main</code>” del hilo. No es <code>main()</code> propiamente dicha, pero es análoga a ella. El hilo comenzará a ejecutarse allí.</li>
<li>Desde el hilo principal, lanzar un nuevo hilo con <code>thrd_create()</code>, y pasarle un puntero a la función a ejecutar.</li>
<li>En esa función, haz que el hilo haga lo que tenga que hacer.</li>
<li>Mientras tanto, el hilo principal puede seguir haciendo lo que tenga que hacer.</li>
<li>Cuando el hilo principal lo decida, puede esperar a que el hilo hijo termine llamando a la función . <code>thrd_join()</code>. Generalmente <strong>debe</strong> <code>thrd_join()</code> el hilo para limpiar después de él o de lo contrario perderá memoria<a href="#fn197" class="footnote-ref" id="fnref197" role="doc-noteref"><sup>197</sup></a>.</li>
</ol>
<p> </p>
<p><code>thrd_create()</code> toma un puntero a la función a ejecutar, y es de tipo <code>thrd_start_t</code>, que es <code>int (*)(void *)</code>. Esto significa en griego “un puntero a una función que toma un <code>void*</code> como argumento, y devuelve un <code>int</code>”.</p>
<p></p>
<p>¡Vamos a crear un hilo! Lo lanzaremos desde el hilo principal con <code>thrd_create()</code> para ejecutar una función, hacer algunas otras cosas, y luego esperar a que se complete con <code>thrd_join()</code>. He llamado a la función principal del hilo <code>run()</code>, pero puedes llamarla como quieras siempre que los tipos coincidan con <code>thrd_start_t</code>.</p>
<div class="sourceCode" id="cb742"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb742-1"><a href="#cb742-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb742-2"><a href="#cb742-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb742-3"><a href="#cb742-3"></a></span>
<span id="cb742-4"><a href="#cb742-4"></a><span class="co">// Esta es la función que el hilo ejecutará. Puede llamarse cualquier cosa.</span></span>
<span id="cb742-5"><a href="#cb742-5"></a><span class="co">//</span></span>
<span id="cb742-6"><a href="#cb742-6"></a><span class="co">// arg es el puntero del argumento pasado a `thrd_create()`.</span></span>
<span id="cb742-7"><a href="#cb742-7"></a><span class="co">//</span></span>
<span id="cb742-8"><a href="#cb742-8"></a><span class="co">// El hilo padre obtendrá el valor de retorno de `thrd_join()`&#39;</span></span>
<span id="cb742-9"><a href="#cb742-9"></a><span class="co">// más tarde.</span></span>
<span id="cb742-10"><a href="#cb742-10"></a></span>
<span id="cb742-11"><a href="#cb742-11"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb742-12"><a href="#cb742-12"></a><span class="op">{</span></span>
<span id="cb742-13"><a href="#cb742-13"></a>    <span class="dt">int</span> <span class="op">*</span>a <span class="op">=</span> arg<span class="op">;</span> <span class="co">// Pasaremos un int* desde thrd_create()</span></span>
<span id="cb742-14"><a href="#cb742-14"></a></span>
<span id="cb742-15"><a href="#cb742-15"></a>    printf<span class="op">(</span><span class="st">&quot;THREAD: Running thread with arg </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>a<span class="op">);</span></span>
<span id="cb742-16"><a href="#cb742-16"></a></span>
<span id="cb742-17"><a href="#cb742-17"></a>    <span class="cf">return</span> <span class="dv">12</span><span class="op">;</span> <span class="co">// Valor que recogerá thrd_join() (eligió 12 al azar)</span></span>
<span id="cb742-18"><a href="#cb742-18"></a><span class="op">}</span></span>
<span id="cb742-19"><a href="#cb742-19"></a></span>
<span id="cb742-20"><a href="#cb742-20"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb742-21"><a href="#cb742-21"></a><span class="op">{</span></span>
<span id="cb742-22"><a href="#cb742-22"></a>    thrd_t t<span class="op">;</span>  <span class="co">// t contendrá el ID del hilo</span></span>
<span id="cb742-23"><a href="#cb742-23"></a>    <span class="dt">int</span> arg <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb742-24"><a href="#cb742-24"></a></span>
<span id="cb742-25"><a href="#cb742-25"></a>    printf<span class="op">(</span><span class="st">&quot;Launching a thread</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb742-26"><a href="#cb742-26"></a></span>
<span id="cb742-27"><a href="#cb742-27"></a>    <span class="co">// Lanza un hilo a la función run(), pasando un puntero a 3490</span></span>
<span id="cb742-28"><a href="#cb742-28"></a>    <span class="co">// como argumento. También almacena el ID del hilo en t:</span></span>
<span id="cb742-29"><a href="#cb742-29"></a></span>
<span id="cb742-30"><a href="#cb742-30"></a>    thrd_create<span class="op">(&amp;</span>t<span class="op">,</span> run<span class="op">,</span> <span class="op">&amp;</span>arg<span class="op">);</span></span>
<span id="cb742-31"><a href="#cb742-31"></a></span>
<span id="cb742-32"><a href="#cb742-32"></a>    printf<span class="op">(</span><span class="st">&quot;Hacer otras cosas mientras se ejecuta el hilo</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb742-33"><a href="#cb742-33"></a></span>
<span id="cb742-34"><a href="#cb742-34"></a>    printf<span class="op">(</span><span class="st">&quot;Esperando a que se complete el hilo...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb742-35"><a href="#cb742-35"></a></span>
<span id="cb742-36"><a href="#cb742-36"></a>    <span class="dt">int</span> res<span class="op">;</span>  <span class="co">// Mantiene el valor de retorno de la salida del hilo</span></span>
<span id="cb742-37"><a href="#cb742-37"></a></span>
<span id="cb742-38"><a href="#cb742-38"></a>    <span class="co">// Espera aquí a que el hilo termine; almacena el valor de retorno</span></span>
<span id="cb742-39"><a href="#cb742-39"></a>    <span class="co">// en res:</span></span>
<span id="cb742-40"><a href="#cb742-40"></a></span>
<span id="cb742-41"><a href="#cb742-41"></a>    thrd_join<span class="op">(</span>t<span class="op">,</span> <span class="op">&amp;</span>res<span class="op">);</span></span>
<span id="cb742-42"><a href="#cb742-42"></a></span>
<span id="cb742-43"><a href="#cb742-43"></a>    printf<span class="op">(</span><span class="st">&quot;Thread finalizado con valor de retorno </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> res<span class="op">);</span></span>
<span id="cb742-44"><a href="#cb742-44"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>¿Ves cómo hicimos el <code>thrd_create()</code> allí para llamar a la función <code>run()</code>? Luego hicimos otras cosas en <code>main()</code> y luego paramos y esperamos a que el hilo se complete con <code>thrd_join()</code>.</p>
<p> </p>
<p>Ejemplos de resultados (los suyos pueden variar):</p>
<div class="sourceCode" id="cb743"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb743-1"><a href="#cb743-1" aria-hidden="true" tabindex="-1"></a>Launching a thread</span>
<span id="cb743-2"><a href="#cb743-2" aria-hidden="true" tabindex="-1"></a>Doing other things while the thread runs</span>
<span id="cb743-3"><a href="#cb743-3" aria-hidden="true" tabindex="-1"></a>Waiting for thread to complete...</span>
<span id="cb743-4"><a href="#cb743-4" aria-hidden="true" tabindex="-1"></a>THREAD: Running thread with arg 3490</span>
<span id="cb743-5"><a href="#cb743-5" aria-hidden="true" tabindex="-1"></a>Thread exited with return value 12</span></code></pre></div>
<p>La <code>arg</code> que pases a la función tiene que tener un tiempo de vida lo suficientemente largo como para que el hilo pueda recogerla antes de que desaparezca. Además, no debe ser sobrescrita por el hilo principal antes de que el nuevo hilo pueda utilizarla.</p>
<p>Veamos un ejemplo que lanza 5 hilos. Una cosa a tener en cuenta aquí es cómo usamos un array de <code>thrd_t</code>s para mantener un registro de todos los IDs de los hilos.</p>
<p> </p>
<div class="sourceCode" id="cb744"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb744-1"><a href="#cb744-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb744-2"><a href="#cb744-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb744-3"><a href="#cb744-3"></a></span>
<span id="cb744-4"><a href="#cb744-4"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb744-5"><a href="#cb744-5"></a><span class="op">{</span></span>
<span id="cb744-6"><a href="#cb744-6"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span></span>
<span id="cb744-7"><a href="#cb744-7"></a></span>
<span id="cb744-8"><a href="#cb744-8"></a>    printf<span class="op">(</span><span class="st">&quot;THREAD </span><span class="sc">%d</span><span class="st">: running!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb744-9"><a href="#cb744-9"></a></span>
<span id="cb744-10"><a href="#cb744-10"></a>    <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb744-11"><a href="#cb744-11"></a><span class="op">}</span></span>
<span id="cb744-12"><a href="#cb744-12"></a></span>
<span id="cb744-13"><a href="#cb744-13"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">5</span></span>
<span id="cb744-14"><a href="#cb744-14"></a></span>
<span id="cb744-15"><a href="#cb744-15"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb744-16"><a href="#cb744-16"></a><span class="op">{</span></span>
<span id="cb744-17"><a href="#cb744-17"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb744-18"><a href="#cb744-18"></a></span>
<span id="cb744-19"><a href="#cb744-19"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb744-20"><a href="#cb744-20"></a></span>
<span id="cb744-21"><a href="#cb744-21"></a>    printf<span class="op">(</span><span class="st">&quot;Launching threads...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb744-22"><a href="#cb744-22"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb744-23"><a href="#cb744-23"></a></span>
<span id="cb744-24"><a href="#cb744-24"></a>        <span class="co">// ¡NOTA! En la siguiente línea, pasamos un puntero a i, </span></span>
<span id="cb744-25"><a href="#cb744-25"></a>        <span class="co">// pero cada hilo ve el mismo puntero. Así que</span></span>
<span id="cb744-26"><a href="#cb744-26"></a>        <span class="co">// imprimirán cosas raras cuando i cambie de valor aquí en</span></span>
<span id="cb744-27"><a href="#cb744-27"></a>        <span class="co">// el hilo principal! (Más en el texto, abajo.)</span></span>
<span id="cb744-28"><a href="#cb744-28"></a></span>
<span id="cb744-29"><a href="#cb744-29"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span>
<span id="cb744-30"><a href="#cb744-30"></a></span>
<span id="cb744-31"><a href="#cb744-31"></a>    printf<span class="op">(</span><span class="st">&quot;Doing other things while the thread runs...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb744-32"><a href="#cb744-32"></a>    printf<span class="op">(</span><span class="st">&quot;Waiting for thread to complete...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb744-33"><a href="#cb744-33"></a></span>
<span id="cb744-34"><a href="#cb744-34"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb744-35"><a href="#cb744-35"></a>        <span class="dt">int</span> res<span class="op">;</span></span>
<span id="cb744-36"><a href="#cb744-36"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> <span class="op">&amp;</span>res<span class="op">);</span></span>
<span id="cb744-37"><a href="#cb744-37"></a></span>
<span id="cb744-38"><a href="#cb744-38"></a>        printf<span class="op">(</span><span class="st">&quot;Thread </span><span class="sc">%d</span><span class="st"> complete!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> res<span class="op">);</span></span>
<span id="cb744-39"><a href="#cb744-39"></a>    <span class="op">}</span></span>
<span id="cb744-40"><a href="#cb744-40"></a></span>
<span id="cb744-41"><a href="#cb744-41"></a>    printf<span class="op">(</span><span class="st">&quot;All threads complete!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb744-42"><a href="#cb744-42"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Cuando ejecuto los hilos, cuento <code>i</code> de 0 a 4. Y le paso un puntero a <code>thrd_create()</code>. Este puntero termina en la rutina <code>run()</code> donde hacemos una copia del mismo.</p>
<p></p>
<p>¿Es sencillo? Aquí está el resultado:</p>
<div class="sourceCode" id="cb745"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb745-1"><a href="#cb745-1" aria-hidden="true" tabindex="-1"></a>Launching threads...</span>
<span id="cb745-2"><a href="#cb745-2" aria-hidden="true" tabindex="-1"></a>THREAD 2: running!</span>
<span id="cb745-3"><a href="#cb745-3" aria-hidden="true" tabindex="-1"></a>THREAD 3: running!</span>
<span id="cb745-4"><a href="#cb745-4" aria-hidden="true" tabindex="-1"></a>THREAD 4: running!</span>
<span id="cb745-5"><a href="#cb745-5" aria-hidden="true" tabindex="-1"></a>THREAD 2: running!</span>
<span id="cb745-6"><a href="#cb745-6" aria-hidden="true" tabindex="-1"></a>Doing other things while the thread runs...</span>
<span id="cb745-7"><a href="#cb745-7" aria-hidden="true" tabindex="-1"></a>Waiting for thread to complete...</span>
<span id="cb745-8"><a href="#cb745-8" aria-hidden="true" tabindex="-1"></a>Thread 2 complete!</span>
<span id="cb745-9"><a href="#cb745-9" aria-hidden="true" tabindex="-1"></a>Thread 2 complete!</span>
<span id="cb745-10"><a href="#cb745-10" aria-hidden="true" tabindex="-1"></a>THREAD 5: running!</span>
<span id="cb745-11"><a href="#cb745-11" aria-hidden="true" tabindex="-1"></a>Thread 3 complete!</span>
<span id="cb745-12"><a href="#cb745-12" aria-hidden="true" tabindex="-1"></a>Thread 4 complete!</span>
<span id="cb745-13"><a href="#cb745-13" aria-hidden="true" tabindex="-1"></a>Thread 5 complete!</span>
<span id="cb745-14"><a href="#cb745-14" aria-hidden="true" tabindex="-1"></a>All threads complete!</span></code></pre></div>
<p>¿Qué…? ¿Dónde está el “HILO 0”? ¿Y por qué tenemos un <code>THREAD 5</code> cuando claramente <code>i</code> nunca es más de <code>4</code> cuando llamamos a <code>thrd_create()</code>? ¿Y dos “THREAD 2”? ¡Qué locura!</p>
<p>Esto es entrar en la divertida tierra de <em>condiciones de carrera</em>. El hilo principal está modificando <code>i</code> antes de que el hilo tenga la oportunidad de copiarlo. De hecho, <code>i</code> llega hasta <code>5</code> y termina el bucle antes de que el último hilo tenga la oportunidad de copiarlo.</p>
<p>Tenemos que tener una variable por hilo a la que podamos referirnos para poder pasarla como <code>arg</code>.</p>
<p>Podríamos tener un gran array de ellas. O podríamos <code>malloc()</code> espacio (y liberarlo en algún lugar - tal vez en el propio hilo.)</p>
<p>Vamos a intentarlo:</p>
<div class="sourceCode" id="cb746"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb746-1"><a href="#cb746-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb746-2"><a href="#cb746-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb746-3"><a href="#cb746-3"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb746-4"><a href="#cb746-4"></a></span>
<span id="cb746-5"><a href="#cb746-5"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb746-6"><a href="#cb746-6"></a><span class="op">{</span></span>
<span id="cb746-7"><a href="#cb746-7"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span>  <span class="co">// Copia el arg</span></span>
<span id="cb746-8"><a href="#cb746-8"></a></span>
<span id="cb746-9"><a href="#cb746-9"></a>    free<span class="op">(</span>arg<span class="op">);</span>  <span class="co">// Terminado con esto</span></span>
<span id="cb746-10"><a href="#cb746-10"></a></span>
<span id="cb746-11"><a href="#cb746-11"></a>    printf<span class="op">(</span><span class="st">&quot;THREAD </span><span class="sc">%d</span><span class="st">: running!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb746-12"><a href="#cb746-12"></a></span>
<span id="cb746-13"><a href="#cb746-13"></a>    <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb746-14"><a href="#cb746-14"></a><span class="op">}</span></span>
<span id="cb746-15"><a href="#cb746-15"></a></span>
<span id="cb746-16"><a href="#cb746-16"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">5</span></span>
<span id="cb746-17"><a href="#cb746-17"></a></span>
<span id="cb746-18"><a href="#cb746-18"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb746-19"><a href="#cb746-19"></a><span class="op">{</span></span>
<span id="cb746-20"><a href="#cb746-20"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb746-21"><a href="#cb746-21"></a></span>
<span id="cb746-22"><a href="#cb746-22"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb746-23"><a href="#cb746-23"></a></span>
<span id="cb746-24"><a href="#cb746-24"></a>    printf<span class="op">(</span><span class="st">&quot;Launching threads...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb746-25"><a href="#cb746-25"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb746-26"><a href="#cb746-26"></a></span>
<span id="cb746-27"><a href="#cb746-27"></a>        <span class="co">// Obtener espacio para un argumento por hilo:</span></span>
<span id="cb746-28"><a href="#cb746-28"></a></span>
<span id="cb746-29"><a href="#cb746-29"></a>        <span class="dt">int</span> <span class="op">*</span>arg <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>arg<span class="op">);</span></span>
<span id="cb746-30"><a href="#cb746-30"></a>        <span class="op">*</span>arg <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb746-31"><a href="#cb746-31"></a></span>
<span id="cb746-32"><a href="#cb746-32"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> arg<span class="op">);</span></span>
<span id="cb746-33"><a href="#cb746-33"></a>    <span class="op">}</span></span>
<span id="cb746-34"><a href="#cb746-34"></a></span>
<span id="cb746-35"><a href="#cb746-35"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>Observa que en las líneas 27-30 hacemos <code>malloc()</code> para un <code>int</code> y copiamos el valor de <code>i</code> en él. Cada nuevo hilo obtiene su propia variable recién <code>malloc()</code> y le pasamos un puntero a la función <code>run()</code>.</p>
<p>Una vez que <code>run()</code> hace su propia copia de la <code>arg</code> en la línea 7, <code>free()</code>s la <code>malloc()</code> <code>int</code>. Y ahora que tiene su propia copia, puede hacer con ella lo que le plazca.</p>
<p>Y una ejecución muestra el resultado:</p>
<div class="sourceCode" id="cb747"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb747-1"><a href="#cb747-1" aria-hidden="true" tabindex="-1"></a>Launching threads...</span>
<span id="cb747-2"><a href="#cb747-2" aria-hidden="true" tabindex="-1"></a>THREAD 0: running!</span>
<span id="cb747-3"><a href="#cb747-3" aria-hidden="true" tabindex="-1"></a>THREAD 1: running!</span>
<span id="cb747-4"><a href="#cb747-4" aria-hidden="true" tabindex="-1"></a>THREAD 2: running!</span>
<span id="cb747-5"><a href="#cb747-5" aria-hidden="true" tabindex="-1"></a>THREAD 3: running!</span>
<span id="cb747-6"><a href="#cb747-6" aria-hidden="true" tabindex="-1"></a>Doing other things while the thread runs...</span>
<span id="cb747-7"><a href="#cb747-7" aria-hidden="true" tabindex="-1"></a>Waiting for thread to complete...</span>
<span id="cb747-8"><a href="#cb747-8" aria-hidden="true" tabindex="-1"></a>Thread 0 complete!</span>
<span id="cb747-9"><a href="#cb747-9" aria-hidden="true" tabindex="-1"></a>Thread 1 complete!</span>
<span id="cb747-10"><a href="#cb747-10" aria-hidden="true" tabindex="-1"></a>Thread 2 complete!</span>
<span id="cb747-11"><a href="#cb747-11" aria-hidden="true" tabindex="-1"></a>Thread 3 complete!</span>
<span id="cb747-12"><a href="#cb747-12" aria-hidden="true" tabindex="-1"></a>THREAD 4: running!</span>
<span id="cb747-13"><a href="#cb747-13" aria-hidden="true" tabindex="-1"></a>Thread 4 complete!</span>
<span id="cb747-14"><a href="#cb747-14" aria-hidden="true" tabindex="-1"></a>All threads complete!</span></code></pre></div>
<p>¡Allá vamos! ¡Hilos 0-4 todos en efecto!</p>
<p>Tu ejecución puede variar—cómo los hilos se programan para ejecutarse, está más allá de la especificación C. Vemos en el ejemplo anterior que el subproceso 4 ni siquiera comenzó hasta que los subprocesos 0-1 se completaron. De hecho, si ejecuto esto de nuevo, es probable que obtenga resultados diferentes. No podemos garantizar un orden de ejecución de hilos.</p>
<h2 data-number="39.5" id="separación-de-hilos"><span class="header-section-number">39.5</span> Separación de hilos</h2>
<p>Si desea despedir y olvidar un hilo (es decir, para no tener que <code>thrd_join()</code> más tarde), puede hacerlo con <code>thrd_detach()</code>.</p>
<p>Esto elimina la capacidad de la hebra padre de obtener el valor de retorno de la hebra hija, pero si no te importa eso y sólo quieres que las hebras se limpien bien por sí solas, este es el camino a seguir.</p>
<p>Básicamente vamos a hacer esto:</p>
<p></p>
<div class="sourceCode" id="cb748"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb748-1"><a href="#cb748-1" aria-hidden="true" tabindex="-1"></a>thrd_create<span class="op">(&amp;</span>t<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb748-2"><a href="#cb748-2" aria-hidden="true" tabindex="-1"></a>thrd_detach<span class="op">(</span>t<span class="op">);</span></span></code></pre></div>
<p>donde la llamada a <code>thrd_detach()</code> es la hebra padre diciendo, “Hey, no voy a esperar a que esta hebra hija termine con <code>thrd_join()</code>. Así que sigue adelante y límpialo por tu cuenta cuando se complete”.</p>
<div class="sourceCode" id="cb749"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb749-1"><a href="#cb749-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb749-2"><a href="#cb749-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb749-3"><a href="#cb749-3"></a></span>
<span id="cb749-4"><a href="#cb749-4"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb749-5"><a href="#cb749-5"></a><span class="op">{</span></span>
<span id="cb749-6"><a href="#cb749-6"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb749-7"><a href="#cb749-7"></a></span>
<span id="cb749-8"><a href="#cb749-8"></a>    <span class="co">//printf(&quot;¡Hilo en ejecución! %lu\n&quot;, thrd_current()); // ¡no portable!</span></span>
<span id="cb749-9"><a href="#cb749-9"></a>    printf<span class="op">(</span><span class="st">&quot;Thread running!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb749-10"><a href="#cb749-10"></a></span>
<span id="cb749-11"><a href="#cb749-11"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb749-12"><a href="#cb749-12"></a><span class="op">}</span></span>
<span id="cb749-13"><a href="#cb749-13"></a></span>
<span id="cb749-14"><a href="#cb749-14"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">10</span></span>
<span id="cb749-15"><a href="#cb749-15"></a></span>
<span id="cb749-16"><a href="#cb749-16"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb749-17"><a href="#cb749-17"></a><span class="op">{</span></span>
<span id="cb749-18"><a href="#cb749-18"></a>    thrd_t t<span class="op">;</span></span>
<span id="cb749-19"><a href="#cb749-19"></a></span>
<span id="cb749-20"><a href="#cb749-20"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb749-21"><a href="#cb749-21"></a>        thrd_create<span class="op">(&amp;</span>t<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb749-22"><a href="#cb749-22"></a>        thrd_detach<span class="op">(</span>t<span class="op">);</span>               <span class="co">// &lt;-- DETACH!</span></span>
<span id="cb749-23"><a href="#cb749-23"></a>    <span class="op">}</span></span>
<span id="cb749-24"><a href="#cb749-24"></a></span>
<span id="cb749-25"><a href="#cb749-25"></a>    <span class="co">// Duerme un segundo para que todos los hilos terminen</span></span>
<span id="cb749-26"><a href="#cb749-26"></a>    thrd_sleep<span class="op">(&amp;(</span><span class="kw">struct</span> timespec<span class="op">){.</span>tv_sec<span class="op">=</span><span class="dv">1</span><span class="op">},</span> NULL<span class="op">);</span></span>
<span id="cb749-27"><a href="#cb749-27"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Tenga en cuenta que en este código, ponemos el hilo principal a dormir durante 1 segundo con <code>thrd_sleep()</code>—más sobre esto más adelante.</p>
<p>También en la función <code>run()</code>, tengo una línea comentada que imprime el ID del hilo como un <code>unsigned long</code>. Esto es no-portable, porque la especificación no dice qué tipo es un <code>thrd_t</code> bajo el capó—podría ser una <code>struct</code> por lo que sabemos. Pero esa línea funciona en mi sistema.</p>
<p>Algo interesante que vi cuando ejecuté el código anterior e imprimí los IDs de los hilos fue que ¡algunos hilos tenían IDs duplicados! Esto parece que debería ser imposible, pero a C se le permite <em>reutilizar</em> los IDs de los hilos después de que el hilo correspondiente haya salido. Así que lo que estaba viendo era que algunos hilos completaban su ejecución antes de que otros hilos fueran lanzados.</p>
<h2 data-number="39.6" id="datos-locales-del-hilo"><span class="header-section-number">39.6</span> Datos Locales del Hilo</h2>
<p></p>
<p>Los hilos son interesantes porque no tienen memoria propia más allá de las variables locales. Si quieres una variable <code>static</code> o una variable de ámbito de fichero, todos los hilos verán esa misma variable.</p>
<p>Esto puede conducir a condiciones de carrera, donde se obtienen <em>Weird Things</em>™ (<em>Cosas raras</em>) sucediendo.</p>
<p>Mira este ejemplo. Tenemos una variable <code>static</code> <code>foo</code> en el ámbito de bloque en <code>run()</code>. Esta variable será visible para todos los hilos que pasen por la función <code>run()</code>. Y los distintos hilos pueden pisarse unos a otros.</p>
<p>Cada hilo copia <code>foo</code> en una variable local <code>x</code> (que no es compartida entre hilos— todos los hilos tienen sus propias pilas de llamadas). Así que <em>deberían</em> ser iguales, ¿no?</p>
<p>Y la primera vez que los imprimimos, lo son<a href="#fn198" class="footnote-ref" id="fnref198" role="doc-noteref"><sup>198</sup></a>. Pero justo después de eso comprobamos que siguen siendo los mismos.</p>
<p>Y <em>normalmente</em> lo son. Pero no siempre.</p>
<div class="sourceCode" id="cb750"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb750-1"><a href="#cb750-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb750-2"><a href="#cb750-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb750-3"><a href="#cb750-3"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb750-4"><a href="#cb750-4"></a></span>
<span id="cb750-5"><a href="#cb750-5"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb750-6"><a href="#cb750-6"></a><span class="op">{</span></span>
<span id="cb750-7"><a href="#cb750-7"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span>  <span class="co">// Número de hilo para que los humanos lo diferencien</span></span>
<span id="cb750-8"><a href="#cb750-8"></a></span>
<span id="cb750-9"><a href="#cb750-9"></a>    free<span class="op">(</span>arg<span class="op">);</span></span>
<span id="cb750-10"><a href="#cb750-10"></a></span>
<span id="cb750-11"><a href="#cb750-11"></a>    <span class="dt">static</span> <span class="dt">int</span> foo <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// Valor estático compartido entre hilos</span></span>
<span id="cb750-12"><a href="#cb750-12"></a></span>
<span id="cb750-13"><a href="#cb750-13"></a>    <span class="dt">int</span> x <span class="op">=</span> foo<span class="op">;</span>  <span class="co">// Variable local automática--cada hilo tiene la suya propia</span></span>
<span id="cb750-14"><a href="#cb750-14"></a></span>
<span id="cb750-15"><a href="#cb750-15"></a>    <span class="co">// Acabamos de asignar x desde foo, así que más vale que sean iguales aquí.</span></span>
<span id="cb750-16"><a href="#cb750-16"></a>    <span class="co">// (En todas mis pruebas, lo eran, ¡pero ni siquiera esto está garantizado!)</span></span>
<span id="cb750-17"><a href="#cb750-17"></a></span>
<span id="cb750-18"><a href="#cb750-18"></a>    printf<span class="op">(</span><span class="st">&quot;Thread </span><span class="sc">%d</span><span class="st">: x = </span><span class="sc">%d</span><span class="st">, foo = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">,</span> x<span class="op">,</span> foo<span class="op">);</span></span>
<span id="cb750-19"><a href="#cb750-19"></a></span>
<span id="cb750-20"><a href="#cb750-20"></a>    <span class="co">// Y aquí deberían ser iguales, ¡pero no siempre lo son!</span></span>
<span id="cb750-21"><a href="#cb750-21"></a>    <span class="co">// (¡A veces sí, a veces no!)</span></span>
<span id="cb750-22"><a href="#cb750-22"></a></span>
<span id="cb750-23"><a href="#cb750-23"></a>    <span class="co">// Lo que pasa es que otro hilo entra e incrementa foo</span></span>
<span id="cb750-24"><a href="#cb750-24"></a>    <span class="co">// en este momento, ¡pero la x de este thread sigue siendo la que era antes!</span></span>
<span id="cb750-25"><a href="#cb750-25"></a></span>
<span id="cb750-26"><a href="#cb750-26"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">!=</span> foo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb750-27"><a href="#cb750-27"></a>        printf<span class="op">(</span><span class="st">&quot;Thread </span><span class="sc">%d</span><span class="st">: Craziness! x != foo! </span><span class="sc">%d</span><span class="st"> != </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">,</span> x<span class="op">,</span> foo<span class="op">);</span></span>
<span id="cb750-28"><a href="#cb750-28"></a>    <span class="op">}</span></span>
<span id="cb750-29"><a href="#cb750-29"></a></span>
<span id="cb750-30"><a href="#cb750-30"></a>    foo<span class="op">++;</span>  <span class="co">// Incrementar el valor compartido</span></span>
<span id="cb750-31"><a href="#cb750-31"></a></span>
<span id="cb750-32"><a href="#cb750-32"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb750-33"><a href="#cb750-33"></a><span class="op">}</span></span>
<span id="cb750-34"><a href="#cb750-34"></a></span>
<span id="cb750-35"><a href="#cb750-35"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">5</span></span>
<span id="cb750-36"><a href="#cb750-36"></a></span>
<span id="cb750-37"><a href="#cb750-37"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb750-38"><a href="#cb750-38"></a><span class="op">{</span></span>
<span id="cb750-39"><a href="#cb750-39"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb750-40"><a href="#cb750-40"></a></span>
<span id="cb750-41"><a href="#cb750-41"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb750-42"><a href="#cb750-42"></a>        <span class="dt">int</span> <span class="op">*</span>n <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>n<span class="op">);</span>  <span class="co">// Contiene un número de serie del hilo</span></span>
<span id="cb750-43"><a href="#cb750-43"></a>        <span class="op">*</span>n <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb750-44"><a href="#cb750-44"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb750-45"><a href="#cb750-45"></a>    <span class="op">}</span></span>
<span id="cb750-46"><a href="#cb750-46"></a></span>
<span id="cb750-47"><a href="#cb750-47"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb750-48"><a href="#cb750-48"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb750-49"><a href="#cb750-49"></a>    <span class="op">}</span></span>
<span id="cb750-50"><a href="#cb750-50"></a><span class="op">}</span></span></code></pre></div>
<p>He aquí un ejemplo (aunque varía de una ejecución a otra):</p>
<div class="sourceCode" id="cb751"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb751-1"><a href="#cb751-1" aria-hidden="true" tabindex="-1"></a>Thread 0: x = 10, foo = 10</span>
<span id="cb751-2"><a href="#cb751-2" aria-hidden="true" tabindex="-1"></a>Thread 1: x = 10, foo = 10</span>
<span id="cb751-3"><a href="#cb751-3" aria-hidden="true" tabindex="-1"></a>Thread 1: Craziness! x != foo! 10 != 11</span>
<span id="cb751-4"><a href="#cb751-4" aria-hidden="true" tabindex="-1"></a>Thread 2: x = 12, foo = 12</span>
<span id="cb751-5"><a href="#cb751-5" aria-hidden="true" tabindex="-1"></a>Thread 4: x = 13, foo = 13</span>
<span id="cb751-6"><a href="#cb751-6" aria-hidden="true" tabindex="-1"></a>Thread 3: x = 14, foo = 14</span></code></pre></div>
<p>En el hilo 1, entre los dos <code>printf()</code>s, el valor de <code>foo</code> de alguna manera cambió de <code>10</code> a <code>11</code>, ¡aunque claramente no hay incremento entre los <code>printf()</code>s!</p>
<p>¡Fue otro hilo el que entró ahí (probablemente el hilo 0, por lo que parece) e incrementó el valor de <code>foo</code> a espaldas del hilo 1!</p>
<p>Resolvamos este problema de dos maneras diferentes. (Si quieres que todos los hilos compartan la variable <em>y</em> no se pisen unos a otros, tendrás que seguir leyendo la sección <a href="#mutex">mutex</a>).</p>
<h3 data-number="39.6.1" id="thread-local"><span class="header-section-number">39.6.1</span> Clase de almacenamiento <code>_Thread_local</code></h3>
<p></p>
<p>Lo primero es lo primero, veamos la forma más sencilla de evitarlo: la clase de almacenamiento <code>_Thread_local</code>.</p>
<p>Básicamente, vamos a ponerla delante de nuestra variable <code>static</code> de ámbito de bloque, ¡y todo funcionará! Le dice a C que cada hilo debe tener su propia versión de esta variable, para que ninguno de ellos pise a los demás. </p>
<p>El <code>&lt;threads.h&gt;</code> define <code>thread_local</code> como un alias de <code>_Thread_local</code> para que tu código no tenga que verse tan feo.</p>
<p>Tomemos el ejemplo anterior y convirtamos <code>foo</code> en una variable <code>thread_local</code> para no compartir esos datos.</p>
<div class="sourceCode" id="cb752" data-startFrom="5"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 4;"><span id="cb752-5"><a href="#cb752-5"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb752-6"><a href="#cb752-6"></a><span class="op">{</span></span>
<span id="cb752-7"><a href="#cb752-7"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span>  <span class="co">// Número de hilo para que los humanos lo diferencien</span></span>
<span id="cb752-8"><a href="#cb752-8"></a></span>
<span id="cb752-9"><a href="#cb752-9"></a>    free<span class="op">(</span>arg<span class="op">);</span></span>
<span id="cb752-10"><a href="#cb752-10"></a></span>
<span id="cb752-11"><a href="#cb752-11"></a>    <span class="dt">thread_local</span> <span class="dt">static</span> <span class="dt">int</span> foo <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// &lt;-- ¡¡¡Ya no se comparte!!!</span></span></code></pre></div>
<p>Y corriendo llegamos:</p>
<div class="sourceCode" id="cb753"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb753-1"><a href="#cb753-1" aria-hidden="true" tabindex="-1"></a>Thread 0: x = 10, foo = 10</span>
<span id="cb753-2"><a href="#cb753-2" aria-hidden="true" tabindex="-1"></a>Thread 1: x = 10, foo = 10</span>
<span id="cb753-3"><a href="#cb753-3" aria-hidden="true" tabindex="-1"></a>Thread 2: x = 10, foo = 10</span>
<span id="cb753-4"><a href="#cb753-4" aria-hidden="true" tabindex="-1"></a>Thread 4: x = 10, foo = 10</span>
<span id="cb753-5"><a href="#cb753-5" aria-hidden="true" tabindex="-1"></a>Thread 3: x = 10, foo = 10</span></code></pre></div>
<p>Se acabaron los problemas raros.</p>
<p>Una cosa: si una variable <code>thread_local</code> tiene ámbito de bloque, <strong>debe</strong> ser <code>static</code>. Esas son las reglas. (Pero esto está bien porque las variables no <code>static</code> ya son per-thread ya que cada thread tiene sus propias variables no <code>static</code>).</p>
<p>Un poco de mentira: las variables <code>thread_local</code> de ámbito de bloque también pueden ser <code>extern</code>.</p>
<p> </p>
<h3 data-number="39.6.2" id="otra-opción-almacenamiento-específico-de-subprocesos"><span class="header-section-number">39.6.2</span> Otra opción: Almacenamiento específico de subprocesos</h3>
<p></p>
<p>El almacenamiento específico de subprocesos (TSS) es otra forma de obtener datos por subproceso.</p>
<p>Una característica adicional es que estas funciones permiten especificar un destructor que será llamado sobre los datos cuando la variable TSS sea borrada. Comúnmente este destructor es <code>free()</code> para limpiar automáticamente los datos por hilo <code>malloc()</code>d. O <code>NULL</code> si no necesitas destruir nada.</p>
<p>El destructor es de tipo <code>tss_dtor_t</code> que es un puntero a una función que devuelve <code>void</code> y toma un <code>void*</code> como argumento (el <code>void*</code> apunta a los datos almacenados en la variable). En otras palabras, es un <code>void (*)(void*)</code>, si eso lo aclara. Que admito que probablemente no. Mira el ejemplo de abajo.</p>
<p>Generalmente, <code>thread_local</code> es probablemente tu mejor opción, pero si te gusta la idea del destructor, entonces puedes hacer uso de eso.</p>
<p>El uso es un poco raro en el sentido de que necesitamos una variable de tipo <code>tss_t</code> para representar el valor de cada hilo. Luego la inicializamos con <code>tss_create()</code>. Finalmente nos deshacemos de él con <code>tss_delete()</code>. Nótese que llamar a <code>tss_delete()</code> no ejecuta todos los destructores–es <code>thrd_exit()</code> (o volver de la función run) la que lo hace. <code>tss_delete()</code> sólo libera la memoria asignada por <code>tss_create()</code>. </p>
<p>En el medio, los hilos pueden llamar <code>tss_set()</code> y <code>tss_get()</code> para establecer y obtener el valor.</p>
<p>En el siguiente código, establecemos la variable TSS antes de crear los hilos, y luego limpiamos después de los hilos.</p>
<p>En la función <code>run()</code>, los hilos <code>malloc()</code> un poco de espacio para una cadena y almacenan ese puntero en la variable TSS.</p>
<p>Cuando el hilo sale, la función destructora (<code>free()</code> en este caso) es llamada para <em>todos</em> los hilos.</p>
<p> </p>
<div class="sourceCode" id="cb754"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb754-1"><a href="#cb754-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb754-2"><a href="#cb754-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb754-3"><a href="#cb754-3"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb754-4"><a href="#cb754-4"></a></span>
<span id="cb754-5"><a href="#cb754-5"></a>tss_t str<span class="op">;</span></span>
<span id="cb754-6"><a href="#cb754-6"></a></span>
<span id="cb754-7"><a href="#cb754-7"></a><span class="dt">void</span> some_function<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb754-8"><a href="#cb754-8"></a><span class="op">{</span></span>
<span id="cb754-9"><a href="#cb754-9"></a>    <span class="co">// Recuperar el valor por hilo de esta cadena</span></span>
<span id="cb754-10"><a href="#cb754-10"></a>    <span class="dt">char</span> <span class="op">*</span>tss_string <span class="op">=</span> tss_get<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb754-11"><a href="#cb754-11"></a></span>
<span id="cb754-12"><a href="#cb754-12"></a>    <span class="co">// E imprimirlo</span></span>
<span id="cb754-13"><a href="#cb754-13"></a>    printf<span class="op">(</span><span class="st">&quot;TSS string: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> tss_string<span class="op">);</span></span>
<span id="cb754-14"><a href="#cb754-14"></a><span class="op">}</span></span>
<span id="cb754-15"><a href="#cb754-15"></a></span>
<span id="cb754-16"><a href="#cb754-16"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb754-17"><a href="#cb754-17"></a><span class="op">{</span></span>
<span id="cb754-18"><a href="#cb754-18"></a>    <span class="dt">int</span> serial <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span>  <span class="co">// Obtener el número de serie de este hilo</span></span>
<span id="cb754-19"><a href="#cb754-19"></a>    free<span class="op">(</span>arg<span class="op">);</span></span>
<span id="cb754-20"><a href="#cb754-20"></a></span>
<span id="cb754-21"><a href="#cb754-21"></a>    <span class="co">// malloc() espacio para guardar los datos de este hilo</span></span>
<span id="cb754-22"><a href="#cb754-22"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> malloc<span class="op">(</span><span class="dv">64</span><span class="op">);</span></span>
<span id="cb754-23"><a href="#cb754-23"></a>    sprintf<span class="op">(</span>s<span class="op">,</span> <span class="st">&quot;thread </span><span class="sc">%d</span><span class="st">! :)&quot;</span><span class="op">,</span> serial<span class="op">);</span>  <span class="co">// Cadena feliz</span></span>
<span id="cb754-24"><a href="#cb754-24"></a></span>
<span id="cb754-25"><a href="#cb754-25"></a>    <span class="co">// Establece esta variable TSS para que apunte a la cadena</span></span>
<span id="cb754-26"><a href="#cb754-26"></a>    tss_set<span class="op">(</span>str<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb754-27"><a href="#cb754-27"></a></span>
<span id="cb754-28"><a href="#cb754-28"></a>    <span class="co">// Llama a una función que obtendrá la variable</span></span>
<span id="cb754-29"><a href="#cb754-29"></a>    some_function<span class="op">();</span></span>
<span id="cb754-30"><a href="#cb754-30"></a></span>
<span id="cb754-31"><a href="#cb754-31"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// Equivalente a thrd_exit(0)</span></span>
<span id="cb754-32"><a href="#cb754-32"></a><span class="op">}</span></span>
<span id="cb754-33"><a href="#cb754-33"></a></span>
<span id="cb754-34"><a href="#cb754-34"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">15</span></span>
<span id="cb754-35"><a href="#cb754-35"></a></span>
<span id="cb754-36"><a href="#cb754-36"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb754-37"><a href="#cb754-37"></a><span class="op">{</span></span>
<span id="cb754-38"><a href="#cb754-38"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb754-39"><a href="#cb754-39"></a></span>
<span id="cb754-40"><a href="#cb754-40"></a>    <span class="co">// Crea una nueva variable TSS, la función free() es el destructor</span></span>
<span id="cb754-41"><a href="#cb754-41"></a>    tss_create<span class="op">(&amp;</span>str<span class="op">,</span> free<span class="op">);</span></span>
<span id="cb754-42"><a href="#cb754-42"></a></span>
<span id="cb754-43"><a href="#cb754-43"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb754-44"><a href="#cb754-44"></a>        <span class="dt">int</span> <span class="op">*</span>n <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>n<span class="op">);</span>  <span class="co">// Contiene un número de serie del hilo</span></span>
<span id="cb754-45"><a href="#cb754-45"></a>        <span class="op">*</span>n <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb754-46"><a href="#cb754-46"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb754-47"><a href="#cb754-47"></a>    <span class="op">}</span></span>
<span id="cb754-48"><a href="#cb754-48"></a></span>
<span id="cb754-49"><a href="#cb754-49"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb754-50"><a href="#cb754-50"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb754-51"><a href="#cb754-51"></a>    <span class="op">}</span></span>
<span id="cb754-52"><a href="#cb754-52"></a></span>
<span id="cb754-53"><a href="#cb754-53"></a>    <span class="co">// Todos los hilos están hechos, así que hemos terminado con esto</span></span>
<span id="cb754-54"><a href="#cb754-54"></a>    tss_delete<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb754-55"><a href="#cb754-55"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Una vez más, esta es una forma un poco dolorosa de hacer las cosas en comparación con <code>thread_local</code>, así que a menos que realmente necesites esa funcionalidad destructor, yo usaría eso en su lugar.</p>
<p></p>
<h2 data-number="39.7" id="mutex"><span class="header-section-number">39.7</span> Mutexes</h2>
<p></p>
<p>Si sólo quieres permitir que un único hilo entre en una sección crítica de código a la vez, puedes proteger esa sección con un mutex<a href="#fn199" class="footnote-ref" id="fnref199" role="doc-noteref"><sup>199</sup></a>.</p>
<p>Por ejemplo, si tuviéramos una variable <code>static</code> y quisiéramos poder obtenerla y establecerla en dos operaciones sin que otro hilo saltara en medio y la corrompiera, podríamos usar un mutex para eso.</p>
<p>Puedes adquirir un mutex o liberarlo. Si intentas adquirir el mutex y tienes éxito, puedes continuar la ejecución. Si lo intentas y fallas (porque alguien más lo tiene), te <em>bloquearás</em><a href="#fn200" class="footnote-ref" id="fnref200" role="doc-noteref"><sup>200</sup></a> hasta que el mutex sea liberado.</p>
<p>Si varios hilos están bloqueados esperando a que se libere un mutex, uno de ellos será elegido para ejecutarse (al azar, desde nuestra perspectiva), y los demás seguirán durmiendo.</p>
<p>El plan de juego es que primero inicializaremos una variable mutex para que esté lista para usar con <code>mtx_init()</code>.</p>
<p>Entonces los hilos subsiguientes pueden llamar a <code>mtx_lock()</code> y <code>mtx_unlock()</code> para obtener y liberar el mutex.</p>
<p>Cuando hayamos terminado completamente con el mutex, podemos destruirlo con la función <code>mtx_destroy()</code>, el opuesto lógico de <code>mtx_init()</code>.</p>
<p></p>
<p>Primero, veamos algo de código que <em>no</em> usa un mutex, e intenta imprimir un número de serie compartido (<code>static</code>) y luego incrementarlo. Debido a que no estamos usando un mutex sobre la obtención del valor (para imprimirlo) y el ajuste (para incrementarlo), los hilos podrían interponerse en el camino de los demás en esa sección crítica.</p>
<div class="sourceCode" id="cb755"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb755-1"><a href="#cb755-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb755-2"><a href="#cb755-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb755-3"><a href="#cb755-3"></a></span>
<span id="cb755-4"><a href="#cb755-4"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb755-5"><a href="#cb755-5"></a><span class="op">{</span></span>
<span id="cb755-6"><a href="#cb755-6"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb755-7"><a href="#cb755-7"></a></span>
<span id="cb755-8"><a href="#cb755-8"></a>    <span class="dt">static</span> <span class="dt">int</span> serial <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// ¡Variable estática compartida!</span></span>
<span id="cb755-9"><a href="#cb755-9"></a></span>
<span id="cb755-10"><a href="#cb755-10"></a>    printf<span class="op">(</span><span class="st">&quot;Thread running! </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> serial<span class="op">);</span></span>
<span id="cb755-11"><a href="#cb755-11"></a></span>
<span id="cb755-12"><a href="#cb755-12"></a>    serial<span class="op">++;</span></span>
<span id="cb755-13"><a href="#cb755-13"></a></span>
<span id="cb755-14"><a href="#cb755-14"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb755-15"><a href="#cb755-15"></a><span class="op">}</span></span>
<span id="cb755-16"><a href="#cb755-16"></a></span>
<span id="cb755-17"><a href="#cb755-17"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">10</span></span>
<span id="cb755-18"><a href="#cb755-18"></a></span>
<span id="cb755-19"><a href="#cb755-19"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb755-20"><a href="#cb755-20"></a><span class="op">{</span></span>
<span id="cb755-21"><a href="#cb755-21"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb755-22"><a href="#cb755-22"></a></span>
<span id="cb755-23"><a href="#cb755-23"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb755-24"><a href="#cb755-24"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb755-25"><a href="#cb755-25"></a>    <span class="op">}</span></span>
<span id="cb755-26"><a href="#cb755-26"></a></span>
<span id="cb755-27"><a href="#cb755-27"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb755-28"><a href="#cb755-28"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb755-29"><a href="#cb755-29"></a>    <span class="op">}</span></span>
<span id="cb755-30"><a href="#cb755-30"></a><span class="op">}</span></span></code></pre></div>
<p>Cuando ejecuto esto, obtengo algo parecido a esto:</p>
<div class="sourceCode" id="cb756"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb756-1"><a href="#cb756-1" aria-hidden="true" tabindex="-1"></a>Thread running! 0</span>
<span id="cb756-2"><a href="#cb756-2" aria-hidden="true" tabindex="-1"></a>Thread running! 0</span>
<span id="cb756-3"><a href="#cb756-3" aria-hidden="true" tabindex="-1"></a>Thread running! 0</span>
<span id="cb756-4"><a href="#cb756-4" aria-hidden="true" tabindex="-1"></a>Thread running! 3</span>
<span id="cb756-5"><a href="#cb756-5" aria-hidden="true" tabindex="-1"></a>Thread running! 4</span>
<span id="cb756-6"><a href="#cb756-6" aria-hidden="true" tabindex="-1"></a>Thread running! 5</span>
<span id="cb756-7"><a href="#cb756-7" aria-hidden="true" tabindex="-1"></a>Thread running! 6</span>
<span id="cb756-8"><a href="#cb756-8" aria-hidden="true" tabindex="-1"></a>Thread running! 7</span>
<span id="cb756-9"><a href="#cb756-9" aria-hidden="true" tabindex="-1"></a>Thread running! 8</span>
<span id="cb756-10"><a href="#cb756-10" aria-hidden="true" tabindex="-1"></a>Thread running! 9</span></code></pre></div>
<p>Claramente múltiples hilos están entrando y ejecutando el <code>printf()</code> antes de que nadie pueda actualizar la variable <code>serial</code>.</p>
<p></p>
<p>Lo que queremos hacer es envolver la obtención de la variable y su establecimiento en un único tramo de código protegido por mutex.</p>
<p>Añadiremos una nueva variable para representar el mutex de tipo <code>mtx_t</code> en el ámbito del fichero, la inicializaremos, y entonces los hilos podrán bloquearla y desbloquearla en la función <code>run()</code>.</p>
<p> </p>
<div class="sourceCode" id="cb757"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb757-1"><a href="#cb757-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb757-2"><a href="#cb757-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb757-3"><a href="#cb757-3"></a></span>
<span id="cb757-4"><a href="#cb757-4"></a>mtx_t serial_mtx<span class="op">;</span>     <span class="co">// &lt;-- MUTEX VARIABLE</span></span>
<span id="cb757-5"><a href="#cb757-5"></a></span>
<span id="cb757-6"><a href="#cb757-6"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb757-7"><a href="#cb757-7"></a><span class="op">{</span></span>
<span id="cb757-8"><a href="#cb757-8"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb757-9"><a href="#cb757-9"></a></span>
<span id="cb757-10"><a href="#cb757-10"></a>    <span class="dt">static</span> <span class="dt">int</span> serial <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// ¡Variable estática compartida!</span></span>
<span id="cb757-11"><a href="#cb757-11"></a></span>
<span id="cb757-12"><a href="#cb757-12"></a>    <span class="co">// Adquirir el mutex--todos los hilos se bloquearán en esta llamada hasta que</span></span>
<span id="cb757-13"><a href="#cb757-13"></a>    <span class="co">// obtengan el bloqueo:</span></span>
<span id="cb757-14"><a href="#cb757-14"></a></span>
<span id="cb757-15"><a href="#cb757-15"></a>    mtx_lock<span class="op">(&amp;</span>serial_mtx<span class="op">);</span>           <span class="co">// &lt;-- ACQUIRE MUTEX</span></span>
<span id="cb757-16"><a href="#cb757-16"></a></span>
<span id="cb757-17"><a href="#cb757-17"></a>    printf<span class="op">(</span><span class="st">&quot;Thread running! </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> serial<span class="op">);</span></span>
<span id="cb757-18"><a href="#cb757-18"></a></span>
<span id="cb757-19"><a href="#cb757-19"></a>    serial<span class="op">++;</span></span>
<span id="cb757-20"><a href="#cb757-20"></a></span>
<span id="cb757-21"><a href="#cb757-21"></a>    <span class="co">// Terminado de obtener y fijar los datos, libera el bloqueo. Esto</span></span>
<span id="cb757-22"><a href="#cb757-22"></a>    <span class="co">// desbloqueará los hilos en la llamada a mtx_lock():</span></span>
<span id="cb757-23"><a href="#cb757-23"></a></span>
<span id="cb757-24"><a href="#cb757-24"></a>    mtx_unlock<span class="op">(&amp;</span>serial_mtx<span class="op">);</span>         <span class="co">// &lt;-- RELEASE MUTEX</span></span>
<span id="cb757-25"><a href="#cb757-25"></a></span>
<span id="cb757-26"><a href="#cb757-26"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb757-27"><a href="#cb757-27"></a><span class="op">}</span></span>
<span id="cb757-28"><a href="#cb757-28"></a></span>
<span id="cb757-29"><a href="#cb757-29"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">10</span></span>
<span id="cb757-30"><a href="#cb757-30"></a></span>
<span id="cb757-31"><a href="#cb757-31"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb757-32"><a href="#cb757-32"></a><span class="op">{</span></span>
<span id="cb757-33"><a href="#cb757-33"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb757-34"><a href="#cb757-34"></a></span>
<span id="cb757-35"><a href="#cb757-35"></a>    <span class="co">// Inicializar la variable mutex, indicando que esto es un normal</span></span>
<span id="cb757-36"><a href="#cb757-36"></a>    <span class="co">// sin florituras, mutex:</span></span>
<span id="cb757-37"><a href="#cb757-37"></a></span>
<span id="cb757-38"><a href="#cb757-38"></a>    mtx_init<span class="op">(&amp;</span>serial_mtx<span class="op">,</span> mtx_plain<span class="op">);</span>        <span class="co">// &lt;-- CREATE MUTEX</span></span>
<span id="cb757-39"><a href="#cb757-39"></a></span>
<span id="cb757-40"><a href="#cb757-40"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb757-41"><a href="#cb757-41"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb757-42"><a href="#cb757-42"></a>    <span class="op">}</span></span>
<span id="cb757-43"><a href="#cb757-43"></a></span>
<span id="cb757-44"><a href="#cb757-44"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb757-45"><a href="#cb757-45"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb757-46"><a href="#cb757-46"></a>    <span class="op">}</span></span>
<span id="cb757-47"><a href="#cb757-47"></a></span>
<span id="cb757-48"><a href="#cb757-48"></a>    <span class="co">// Done with the mutex, destroy it:</span></span>
<span id="cb757-49"><a href="#cb757-49"></a></span>
<span id="cb757-50"><a href="#cb757-50"></a>    mtx_destroy<span class="op">(&amp;</span>serial_mtx<span class="op">);</span>                <span class="co">// &lt;-- DESTROY MUTEX</span></span>
<span id="cb757-51"><a href="#cb757-51"></a><span class="op">}</span></span></code></pre></div>
<p>Mira cómo en las líneas 38 y 50 de <code>main()</code> inicializamos y destruimos el mutex.</p>
<p> </p>
<p>Pero cada hilo individual adquiere el mutex en la línea 15 y lo libera en la línea 24.</p>
<p>Entre <code>mtx_lock()</code> y <code>mtx_unlock()</code> está la <em>sección crítica</em>, el área de código en la que no queremos que varios hilos se metan al mismo tiempo.</p>
<p> </p>
<p>Y ahora obtenemos una salida adecuada.</p>
<div class="sourceCode" id="cb758"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb758-1"><a href="#cb758-1" aria-hidden="true" tabindex="-1"></a>Thread running! 0</span>
<span id="cb758-2"><a href="#cb758-2" aria-hidden="true" tabindex="-1"></a>Thread running! 1</span>
<span id="cb758-3"><a href="#cb758-3" aria-hidden="true" tabindex="-1"></a>Thread running! 2</span>
<span id="cb758-4"><a href="#cb758-4" aria-hidden="true" tabindex="-1"></a>Thread running! 3</span>
<span id="cb758-5"><a href="#cb758-5" aria-hidden="true" tabindex="-1"></a>Thread running! 4</span>
<span id="cb758-6"><a href="#cb758-6" aria-hidden="true" tabindex="-1"></a>Thread running! 5</span>
<span id="cb758-7"><a href="#cb758-7" aria-hidden="true" tabindex="-1"></a>Thread running! 6</span>
<span id="cb758-8"><a href="#cb758-8" aria-hidden="true" tabindex="-1"></a>Thread running! 7</span>
<span id="cb758-9"><a href="#cb758-9" aria-hidden="true" tabindex="-1"></a>Thread running! 8</span>
<span id="cb758-10"><a href="#cb758-10" aria-hidden="true" tabindex="-1"></a>Thread running! 9</span></code></pre></div>
<p>Si necesitas múltiples mutexes, no hay problema: simplemente ten múltiples variables mutex.</p>
<p>Y recuerda siempre la Regla Número Uno de los Mutexes Múltiples: Desbloquea los mutex en el orden opuesto al que los bloqueaste.</p>
<h3 data-number="39.7.1" id="diferentes-tipos-de-mutex"><span class="header-section-number">39.7.1</span> Diferentes Tipos de Mutex</h3>
<p></p>
<p>Como se ha insinuado antes, tenemos algunos tipos de mutex que puedes crear con <code>mtx_init()</code>. (Algunos de estos tipos son el resultado de una operación bitwise-OR, como se indica en la tabla).</p>
<p></p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Tipo</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mtx_plain</code></td>
<td>Mutex normal y corriente</td>
</tr>
<tr class="even">
<td><code>mtx_timed</code></td>
<td>Mutex que admite tiempos de espera</td>
</tr>
<tr class="odd">
<td><code>mtx_plain|mtx_recursive</code></td>
<td>Mutex recursivo</td>
</tr>
<tr class="even">
<td><code>mtx_timed|mtx_recursive</code></td>
<td>Mutex recursivo que admite tiempos de espera</td>
</tr>
</tbody>
</table>
<p>“Recursivo” significa que el poseedor de un bloqueo puede llamar a <code>mtx_lock()</code> varias veces sobre el mismo bloqueo. (Tienen que desbloquearlo un número igual de veces antes de que alguien más pueda tomar el mutex). Esto puede facilitar la codificación de vez en cuando, especialmente si llamas a una función que necesita bloquear el mutex cuando ya tienes el mutex.</p>
<p>Y el tiempo de espera da a un hilo la oportunidad de <em>intentar</em> obtener el bloqueo durante un tiempo, pero luego abandonarlo si no puede conseguirlo en ese plazo.</p>
<p></p>
<p>Para un mutex con tiempo de espera, asegúrate de crearlo con <code>mtx_timed</code>:</p>
<div class="sourceCode" id="cb759"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb759-1"><a href="#cb759-1" aria-hidden="true" tabindex="-1"></a>mtx_init<span class="op">(&amp;</span>serial_mtx<span class="op">,</span> mtx_timed<span class="op">);</span></span></code></pre></div>
<p></p>
<p>Y luego, cuando lo esperas, tienes que especificar una hora en UTC en la que se desbloqueará<a href="#fn201" class="footnote-ref" id="fnref201" role="doc-noteref"><sup>201</sup></a></p>
<p></p>
<p>La función <code>timespec_get()</code> de <code>&lt;time.h&gt;</code> puede ser de ayuda aquí. Te dará la hora actual en UTC en una <code>struct timespec</code> que es justo lo que necesitamos. De hecho, parece existir sólo para este propósito.</p>
<p>Tiene dos campos: <code>tv_sec</code> tiene el tiempo actual en segundos desde la época, y <code>tv_nsec</code> tiene los nanosegundos (milmillonésimas de segundo) como parte “fraccionaria”.</p>
<p>Así que puedes cargarlo con el tiempo actual, y luego añadirlo para obtener un tiempo de espera específico.</p>
<p></p>
<p>Entonces llame a <code>mtx_timedlock()</code> en lugar de a <code>mtx_lock()</code>. Si devuelve el valor <code>thrd_timedout</code>, se ha agotado el tiempo de espera.</p>
<div class="sourceCode" id="cb760"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb760-1"><a href="#cb760-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> timespec timeout<span class="op">;</span></span>
<span id="cb760-2"><a href="#cb760-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb760-3"><a href="#cb760-3" aria-hidden="true" tabindex="-1"></a>timespec_get<span class="op">(&amp;</span>timeout<span class="op">,</span> TIME_UTC<span class="op">);</span>  <span class="co">// Obtener la hora actual</span></span>
<span id="cb760-4"><a href="#cb760-4" aria-hidden="true" tabindex="-1"></a>timeout<span class="op">.</span>tv_sec <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span>               <span class="co">// Tiempo de espera 1 segundo después de ahora</span></span>
<span id="cb760-5"><a href="#cb760-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb760-6"><a href="#cb760-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result <span class="op">=</span> mtx_timedlock<span class="op">(&amp;</span>serial_mtx<span class="op">,</span> <span class="op">&amp;</span>timeout<span class="op">));</span></span>
<span id="cb760-7"><a href="#cb760-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb760-8"><a href="#cb760-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>result <span class="op">==</span> thrd_timedout<span class="op">)</span> <span class="op">{</span></span>
<span id="cb760-9"><a href="#cb760-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Mutex lock timed out!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb760-10"><a href="#cb760-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Aparte de eso, los bloqueos temporizados son iguales que los bloqueos normales.</p>
<p> </p>
<h2 data-number="39.8" id="variables-de-condición"><span class="header-section-number">39.8</span> Variables de condición</h2>
<p></p>
<p>Las variables de condición son la última pieza del rompecabezas que necesitamos para crear aplicaciones multihilo eficaces y componer estructuras multihilo más complejas.</p>
<p>Una variable de condición proporciona una manera para que los hilos vayan a dormir hasta que ocurra algún evento en otro hilo.</p>
<p>En otras palabras, podemos tener un número de hilos que están listos para empezar, pero tienen que esperar hasta que algún evento se cumpla antes de continuar. Básicamente se les está diciendo “¡esperad!” hasta que se les notifique.</p>
<p>Y esto trabaja mano a mano con mutexes ya que lo que vamos a esperar generalmente depende del valor de algunos datos, y esos datos generalmente necesitan ser protegidos por un mutex.</p>
<p>Es importante tener en cuenta que la variable de condición en sí no es el titular de ningún dato en particular desde nuestra perspectiva. Es simplemente la variable mediante la cual C realiza un seguimiento del estado de espera/no espera de un hilo o grupo de hilos en particular.</p>
<p>Escribamos un programa artificial que lea grupos de 5 números del hilo principal de uno en uno. Entonces, cuando se hayan introducido 5 números, el subproceso hijo se despierta, suma esos 5 números e imprime el resultado.</p>
<p>Los números se almacenarán en una matriz global compartida, al igual que el índice de la matriz del número que se va a introducir.</p>
<p>Como se trata de valores compartidos, al menos tenemos que esconderlos detrás de un mutex tanto para el hilo principal como para el secundario. (El principal escribirá datos en ellos y el hijo los leerá).</p>
<p>Pero eso no es suficiente. El subproceso hijo necesita bloquearse (“dormir”) hasta que se hayan leído 5 números en el array. Y entonces la hebra padre tiene que despertar a la hebra hija para que pueda hacer su trabajo.</p>
<p>Y cuando se despierte, necesita mantener ese mutex. Y lo hará. Cuando un hilo espera en una variable de condición, también adquiere un mutex cuando se despierta.</p>
<p>Todo esto tiene lugar alrededor de una variable adicional de tipo <code>cnd_t</code> que es la <em>variable de condición</em>. Creamos esta variable con la función <code>cnd_init()</code> y la destruimos cuando acabemos con ella con la <code>cnd_destroy()</code>.</p>
<p>Pero, ¿cómo funciona todo esto? Veamos el esquema de lo que hará el hilo hijo:</p>
<p> </p>
<ol type="1">
<li>Bloquea el mutex con <code>mtx_lock()</code>.</li>
<li>Si no hemos introducido todos los números, esperar en la variable condición con <code>cnd_wait()</code>.</li>
<li>Hacer el trabajo que haya que hacer</li>
<li>Desbloquear el mutex con <code>mtx_unlock()</code>.</li>
</ol>
<p>Mientras tanto el hilo principal estará haciendo lo siguiente</p>
<ol type="1">
<li>Bloquear el mutex con <code>mtx_lock()</code>.</li>
<li>Almacenar el número leído recientemente en el array</li>
<li>Si el array está lleno, indica al hijo que se despierte con <code>cnd_signal()</code>.</li>
<li>Desbloquea el mutex con <code>mtx_unlock()</code>.</li>
</ol>
<p> </p>
<p>Si no lo has ojeado demasiado (no pasa nada, no me ofendo), puede que notes algo raro: ¿cómo puede el hilo principal mantener el bloqueo mutex y enviar una señal al hijo, si el hijo tiene que mantener el bloqueo mutex para esperar la señal? No pueden mantener ambos el bloqueo.</p>
<p>Y de hecho no lo hacen. Hay algo de magia entre bastidores con las variables de condición: cuando <code>cnd_wait()</code>, libera el mutex que especifiques y el hilo se va a dormir. Y cuando alguien indica a ese hilo que se despierte, vuelve a adquirir el bloqueo como si nada hubiera pasado.</p>
<p>Es un poco diferente en el lado <code>cnd_signal()</code> de las cosas. Esto no hace nada con el mutex. La hebra señalizadora aún debe liberar manualmente el mutex antes de que las hebras en espera puedan despertarse.</p>
<p></p>
<p>Una cosa más sobre <code>cnd_wait()</code>. Probablemente llame a <code>cnd_wait()</code> si alguna condición<a href="#fn202" class="footnote-ref" id="fnref202" role="doc-noteref"><sup>202</sup></a> aún no se cumple (por ejemplo, en este caso, si aún no se han introducido todos los números). Este es el problema: esta condición debería estar en un bucle <code>while</code>, no en una sentencia <code>if</code>. ¿Por qué?</p>
<p>Por un misterioso fenómeno llamado <em>spurious wakeup</em>. A veces, en algunas implementaciones, un hilo puede ser despertado de una suspensión <code>cnd_wait()</code> aparentemente <em>sin razón</em> <em>[X-Files music]</em>. No digo que sean aliens… pero son aliens. Vale, en realidad es más probable que otro hilo se haya despertado y haya llegado al trabajo primero]. Y así tenemos que comprobar que la condición que necesitamos todavía se cumple cuando nos despertamos. Y si no es así, ¡a dormir! </p>
<p>Así que ¡manos a la obra! Empezando por el hilo principal:</p>
<ul>
<li><p>El hilo principal creará el mutex y la variable condición, y lanzará el hilo hijo.</p></li>
<li><p>Luego, en un bucle infinito, obtendrá números de la consola.</p></li>
<li><p>También adquirirá el mutex para almacenar los números introducidos en un array global.</p></li>
<li><p>Cuando el array tenga 5 números, la hebra principal indicará a la hebra hija que es hora de despertar y hacer su trabajo.</p></li>
<li><p>Entonces el hilo principal desbloqueará el mutex y volverá a leer el siguiente número de la consola.</p></li>
</ul>
<p>Mientras tanto, el subproceso hijo ha estado haciendo sus propias travesuras:</p>
<ul>
<li><p>El hilo hijo toma el mutex</p></li>
<li><p>Mientras no se cumpla la condición (es decir, mientras el array compartido no tenga todavía 5 números), la hebra hija duerme esperando en la variable de condición. Cuando espera, implícitamente desbloquea el mutex.</p></li>
<li><p>Una vez que el hilo principal indica al hilo hijo que se despierte, éste se despierta para hacer el trabajo y recupera el bloqueo mutex.</p></li>
<li><p>El subproceso hijo suma los números y restablece la variable que es el índice en la matriz.</p></li>
<li><p>Entonces libera el mutex y se ejecuta de nuevo en un bucle infinito.</p></li>
</ul>
<p>Y aquí está el código. Estudialo un poco para que puedas ver donde se manejan todas las piezas anteriores:</p>
<p> </p>
<div class="sourceCode" id="cb761"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb761-1"><a href="#cb761-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb761-2"><a href="#cb761-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb761-3"><a href="#cb761-3"></a></span>
<span id="cb761-4"><a href="#cb761-4"></a><span class="pp">#define VALUE_COUNT_MAX </span><span class="dv">5</span></span>
<span id="cb761-5"><a href="#cb761-5"></a></span>
<span id="cb761-6"><a href="#cb761-6"></a><span class="dt">int</span> value<span class="op">[</span>VALUE_COUNT_MAX<span class="op">];</span>  <span class="co">// Global compartido</span></span>
<span id="cb761-7"><a href="#cb761-7"></a><span class="dt">int</span> value_count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// Global compartido, también</span></span>
<span id="cb761-8"><a href="#cb761-8"></a></span>
<span id="cb761-9"><a href="#cb761-9"></a>mtx_t value_mtx<span class="op">;</span>   <span class="co">// Mutex alrededor del valor</span></span>
<span id="cb761-10"><a href="#cb761-10"></a>cnd_t value_cnd<span class="op">;</span>   <span class="co">// Condicionar la variable al valor</span></span>
<span id="cb761-11"><a href="#cb761-11"></a></span>
<span id="cb761-12"><a href="#cb761-12"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb761-13"><a href="#cb761-13"></a><span class="op">{</span></span>
<span id="cb761-14"><a href="#cb761-14"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb761-15"><a href="#cb761-15"></a></span>
<span id="cb761-16"><a href="#cb761-16"></a>    <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb761-17"><a href="#cb761-17"></a>        mtx_lock<span class="op">(&amp;</span>value_mtx<span class="op">);</span>      <span class="co">// &lt;-- GRAB THE MUTEX</span></span>
<span id="cb761-18"><a href="#cb761-18"></a></span>
<span id="cb761-19"><a href="#cb761-19"></a>        <span class="cf">while</span> <span class="op">(</span>value_count <span class="op">&lt;</span> VALUE_COUNT_MAX<span class="op">)</span> <span class="op">{</span></span>
<span id="cb761-20"><a href="#cb761-20"></a>            printf<span class="op">(</span><span class="st">&quot;Thread: is waiting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb761-21"><a href="#cb761-21"></a>            cnd_wait<span class="op">(&amp;</span>value_cnd<span class="op">,</span> <span class="op">&amp;</span>value_mtx<span class="op">);</span>  <span class="co">// &lt;-- CONDITION WAIT</span></span>
<span id="cb761-22"><a href="#cb761-22"></a>        <span class="op">}</span></span>
<span id="cb761-23"><a href="#cb761-23"></a></span>
<span id="cb761-24"><a href="#cb761-24"></a>        printf<span class="op">(</span><span class="st">&quot;Thread: is awake!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb761-25"><a href="#cb761-25"></a></span>
<span id="cb761-26"><a href="#cb761-26"></a>        <span class="dt">int</span> t <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb761-27"><a href="#cb761-27"></a></span>
<span id="cb761-28"><a href="#cb761-28"></a>        <span class="co">// Add everything up</span></span>
<span id="cb761-29"><a href="#cb761-29"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> VALUE_COUNT_MAX<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb761-30"><a href="#cb761-30"></a>            t <span class="op">+=</span> value<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb761-31"><a href="#cb761-31"></a></span>
<span id="cb761-32"><a href="#cb761-32"></a>        printf<span class="op">(</span><span class="st">&quot;Thread: total is </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> t<span class="op">);</span></span>
<span id="cb761-33"><a href="#cb761-33"></a></span>
<span id="cb761-34"><a href="#cb761-34"></a>        <span class="co">// Reset input index for main thread</span></span>
<span id="cb761-35"><a href="#cb761-35"></a>        value_count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb761-36"><a href="#cb761-36"></a></span>
<span id="cb761-37"><a href="#cb761-37"></a>        mtx_unlock<span class="op">(&amp;</span>value_mtx<span class="op">);</span>   <span class="co">// &lt;-- MUTEX UNLOCK</span></span>
<span id="cb761-38"><a href="#cb761-38"></a>    <span class="op">}</span></span>
<span id="cb761-39"><a href="#cb761-39"></a></span>
<span id="cb761-40"><a href="#cb761-40"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb761-41"><a href="#cb761-41"></a><span class="op">}</span></span>
<span id="cb761-42"><a href="#cb761-42"></a></span>
<span id="cb761-43"><a href="#cb761-43"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb761-44"><a href="#cb761-44"></a><span class="op">{</span></span>
<span id="cb761-45"><a href="#cb761-45"></a>    thrd_t t<span class="op">;</span></span>
<span id="cb761-46"><a href="#cb761-46"></a></span>
<span id="cb761-47"><a href="#cb761-47"></a>    <span class="co">// Crear un nuevo tema</span></span>
<span id="cb761-48"><a href="#cb761-48"></a></span>
<span id="cb761-49"><a href="#cb761-49"></a>    thrd_create<span class="op">(&amp;</span>t<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb761-50"><a href="#cb761-50"></a>    thrd_detach<span class="op">(</span>t<span class="op">);</span></span>
<span id="cb761-51"><a href="#cb761-51"></a></span>
<span id="cb761-52"><a href="#cb761-52"></a>    <span class="co">// Configurar el mutex y la variable de condición</span></span>
<span id="cb761-53"><a href="#cb761-53"></a></span>
<span id="cb761-54"><a href="#cb761-54"></a>    mtx_init<span class="op">(&amp;</span>value_mtx<span class="op">,</span> mtx_plain<span class="op">);</span></span>
<span id="cb761-55"><a href="#cb761-55"></a>    cnd_init<span class="op">(&amp;</span>value_cnd<span class="op">);</span></span>
<span id="cb761-56"><a href="#cb761-56"></a></span>
<span id="cb761-57"><a href="#cb761-57"></a>    <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb761-58"><a href="#cb761-58"></a>        <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb761-59"><a href="#cb761-59"></a></span>
<span id="cb761-60"><a href="#cb761-60"></a>        scanf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb761-61"><a href="#cb761-61"></a></span>
<span id="cb761-62"><a href="#cb761-62"></a>        mtx_lock<span class="op">(&amp;</span>value_mtx<span class="op">);</span>    <span class="co">// &lt;-- LOCK MUTEX</span></span>
<span id="cb761-63"><a href="#cb761-63"></a></span>
<span id="cb761-64"><a href="#cb761-64"></a>        value<span class="op">[</span>value_count<span class="op">++]</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb761-65"><a href="#cb761-65"></a></span>
<span id="cb761-66"><a href="#cb761-66"></a>        <span class="cf">if</span> <span class="op">(</span>value_count <span class="op">==</span> VALUE_COUNT_MAX<span class="op">)</span> <span class="op">{</span></span>
<span id="cb761-67"><a href="#cb761-67"></a>            printf<span class="op">(</span><span class="st">&quot;Main: signaling thread</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb761-68"><a href="#cb761-68"></a>            cnd_signal<span class="op">(&amp;</span>value_cnd<span class="op">);</span>  <span class="co">// &lt;-- SIGNAL CONDITION</span></span>
<span id="cb761-69"><a href="#cb761-69"></a>        <span class="op">}</span></span>
<span id="cb761-70"><a href="#cb761-70"></a></span>
<span id="cb761-71"><a href="#cb761-71"></a>        mtx_unlock<span class="op">(&amp;</span>value_mtx<span class="op">);</span>  <span class="co">// &lt;-- UNLOCK MUTEX</span></span>
<span id="cb761-72"><a href="#cb761-72"></a>    <span class="op">}</span></span>
<span id="cb761-73"><a href="#cb761-73"></a></span>
<span id="cb761-74"><a href="#cb761-74"></a>    <span class="co">// Limpiar (Sé que es un bucle infinito aquí arriba, pero yo</span></span>
<span id="cb761-75"><a href="#cb761-75"></a>    <span class="co">// quiero al menos pretender ser correcto):</span></span>
<span id="cb761-76"><a href="#cb761-76"></a></span>
<span id="cb761-77"><a href="#cb761-77"></a>    mtx_destroy<span class="op">(&amp;</span>value_mtx<span class="op">);</span></span>
<span id="cb761-78"><a href="#cb761-78"></a>    cnd_destroy<span class="op">(&amp;</span>value_cnd<span class="op">);</span></span>
<span id="cb761-79"><a href="#cb761-79"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Y aquí hay algunos ejemplos de salida (los números individuales en las líneas son mis entradas):</p>
<div class="sourceCode" id="cb762"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb762-1"><a href="#cb762-1" aria-hidden="true" tabindex="-1"></a>Thread: is waiting</span>
<span id="cb762-2"><a href="#cb762-2" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb762-3"><a href="#cb762-3" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb762-4"><a href="#cb762-4" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb762-5"><a href="#cb762-5" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb762-6"><a href="#cb762-6" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb762-7"><a href="#cb762-7" aria-hidden="true" tabindex="-1"></a>Main: signaling thread</span>
<span id="cb762-8"><a href="#cb762-8" aria-hidden="true" tabindex="-1"></a>Thread: is awake!</span>
<span id="cb762-9"><a href="#cb762-9" aria-hidden="true" tabindex="-1"></a>Thread: total is 5</span>
<span id="cb762-10"><a href="#cb762-10" aria-hidden="true" tabindex="-1"></a>Thread: is waiting</span>
<span id="cb762-11"><a href="#cb762-11" aria-hidden="true" tabindex="-1"></a>2</span>
<span id="cb762-12"><a href="#cb762-12" aria-hidden="true" tabindex="-1"></a>8</span>
<span id="cb762-13"><a href="#cb762-13" aria-hidden="true" tabindex="-1"></a>5</span>
<span id="cb762-14"><a href="#cb762-14" aria-hidden="true" tabindex="-1"></a>9</span>
<span id="cb762-15"><a href="#cb762-15" aria-hidden="true" tabindex="-1"></a>0</span>
<span id="cb762-16"><a href="#cb762-16" aria-hidden="true" tabindex="-1"></a>Main: signaling thread</span>
<span id="cb762-17"><a href="#cb762-17" aria-hidden="true" tabindex="-1"></a>Thread: is awake!</span>
<span id="cb762-18"><a href="#cb762-18" aria-hidden="true" tabindex="-1"></a>Thread: total is 24</span>
<span id="cb762-19"><a href="#cb762-19" aria-hidden="true" tabindex="-1"></a>Thread: is waiting</span></code></pre></div>
<p>Es un uso común de las variables de condición en situaciones productor-consumidor como ésta. Si no tuviéramos una forma de poner el hilo hijo a dormir mientras espera a que se cumpla alguna condición, se vería forzado a sondear, lo cual es un gran desperdicio de CPU.</p>
<h3 data-number="39.8.1" id="timed-condition-wait"><span class="header-section-number">39.8.1</span> Timed Condition Wait</h3>
<p></p>
<p>Hay una variante de <code>cnd_wait()</code> que permite especificar un tiempo de espera para que pueda dejar de esperar.</p>
<p>Dado que el subproceso hijo debe volver a bloquear el mutex, esto no significa necesariamente que vaya a volver a la vida en el instante en que se produce el tiempo de espera; todavía debe esperar a que cualquier otro subproceso libere el mutex.</p>
<p>Pero sí significa que no estarás esperando hasta que ocurra la <code>cnd_signal()</code>.</p>
<p>Para que esto funcione, llame a la función <code>cnd_timedwait()</code> en lugar de <code>cnd_wait()</code>. Si devuelve el valor <code>thrd_timedout</code>, se ha agotado el tiempo de espera.</p>
<p>La marca de tiempo es un tiempo absoluto en UTC, no un tiempo-desde-ahora. Gracias a la función <code>timespec_get()</code> en <code>&lt;time.h&gt;</code> parece hecha a medida exactamente para este caso.</p>
<p> </p>
<div class="sourceCode" id="cb763"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb763-1"><a href="#cb763-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> timespec timeout<span class="op">;</span></span>
<span id="cb763-2"><a href="#cb763-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb763-3"><a href="#cb763-3" aria-hidden="true" tabindex="-1"></a>timespec_get<span class="op">(&amp;</span>timeout<span class="op">,</span> TIME_UTC<span class="op">);</span>  <span class="co">// Obtener la hora actual</span></span>
<span id="cb763-4"><a href="#cb763-4" aria-hidden="true" tabindex="-1"></a>timeout<span class="op">.</span>tv_sec <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span>               <span class="co">// Tiempo de espera 1 segundo después de ahora</span></span>
<span id="cb763-5"><a href="#cb763-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb763-6"><a href="#cb763-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result <span class="op">=</span> cnd_timedwait<span class="op">(&amp;</span>condition<span class="op">,</span> <span class="op">&amp;</span>mutex<span class="op">,</span> <span class="op">&amp;</span>timeout<span class="op">));</span></span>
<span id="cb763-7"><a href="#cb763-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb763-8"><a href="#cb763-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>result <span class="op">==</span> thrd_timedout<span class="op">)</span> <span class="op">{</span></span>
<span id="cb763-9"><a href="#cb763-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Condition variable timed out!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb763-10"><a href="#cb763-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<h3 data-number="39.8.2" id="broadcast-despertar-todos-los-hilos-en-espera"><span class="header-section-number">39.8.2</span> Broadcast: Despertar todos los hilos en espera</h3>
<p></p>
<p><code>cnd_signal()</code> function]] <code>cnd_signal()</code> only wakes up one thread to continue working. Depending on how you have your logic done, it might make sense to wake up more than one thread to continue once the condition is met.</p>
<p>Of course only one of them can grab the mutex, but if you have a situation where:</p>
<ul>
<li><p>The newly-awoken thread is responsible for waking up the next one, and—</p></li>
<li><p>There’s a chance the spurious-wakeup loop condition will prevent it from doing so, then—</p></li>
</ul>
<p>you’ll want to broadcast the wake up so that you’re sure to get at least one of the threads out of that loop to launch the next one.</p>
<p>How, you ask?</p>
<p></p>
<p>Simply use <code>cnd_broadcast()</code> instead of <code>cnd_signal()</code>. Exact same usage, except <code>cnd_broadcast()</code> wakes up <strong>all</strong> the sleeping threads that were waiting on that condition variable.</p>
<p> </p>
<h2 data-number="39.9" id="running-a-function-one-time"><span class="header-section-number">39.9</span> Running a Function One Time</h2>
<p></p>
<p>Let’s say you have a function that <em>could</em> be run by many threads, but you don’t know when, and it’s not work trying to write all that logic.</p>
<p>There’s a way around it: use <code>call_once()</code>. Tons of threads could try to run the function, but only the first one counts<a href="#fn203" class="footnote-ref" id="fnref203" role="doc-noteref"><sup>203</sup></a></p>
<p>To work with this, you need a special flag variable you declare to keep track of whether or not the thing’s been run. And you need a function to run, which takes no parameters and returns no value.</p>
<p> </p>
<div class="sourceCode" id="cb764"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb764-1"><a href="#cb764-1" aria-hidden="true" tabindex="-1"></a>once_flag of <span class="op">=</span> ONCE_FLAG_INIT<span class="op">;</span>  <span class="co">// Initialize it like this</span></span>
<span id="cb764-2"><a href="#cb764-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-3"><a href="#cb764-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> run_once_function<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb764-4"><a href="#cb764-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb764-5"><a href="#cb764-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;ll only run once!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb764-6"><a href="#cb764-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb764-7"><a href="#cb764-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-8"><a href="#cb764-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb764-9"><a href="#cb764-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb764-10"><a href="#cb764-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb764-11"><a href="#cb764-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-12"><a href="#cb764-12" aria-hidden="true" tabindex="-1"></a>    call_once<span class="op">(&amp;</span>of<span class="op">,</span> run_once_function<span class="op">);</span></span>
<span id="cb764-13"><a href="#cb764-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-14"><a href="#cb764-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p> </p>
<p>In this example, no matter how many threads get to the <code>run()</code> function, the <code>run_once_function()</code> will only be called a single time.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="40" id="chapter-atomics"><span class="header-section-number">40</span> Atomics</h1>
<blockquote>
<p>“¿Lo intentaron y fracasaron, todos ellos?”&gt; “Oh, no.” Sacudió la cabeza. “Lo intentaron y murieron.”</p>
<p>—Paul Atreides y la Reverenda Madre Gaius Helen Mohiam, <em>Dune</em></p>
</blockquote>
<p></p>
<p>Este es uno de los aspectos más desafiantes del multithreading con C. Pero intentaremos tomárnoslo con calma.</p>
<p>Básicamente, hablaré de los usos más sencillos de las variables atómicas, qué son, cómo funcionan, etc. Y mencionaré algunos de los caminos más increíblemente complejos que están a tu disposición.</p>
<p>Pero no voy a ir por esos caminos. No sólo apenas estoy cualificado para escribir sobre ellos, sino que me imagino que si sabes que los necesitas, ya sabes más que yo.</p>
<p>Pero hay algunas cosas raras incluso en lo básico. Así que abróchense los cinturones, porque Kansas se va.</p>
<h2 data-number="40.1" id="pruebas-de-compatibilidad-atómica"><span class="header-section-number">40.1</span> Pruebas de compatibilidad atómica</h2>
<p></p>
<p>Los atómicos son opcionales. Hay una macro <code>__STDC_NO_ATOMICS__</code> que es <code>1</code> si <em>no</em> tienes atómicos.</p>
<p>Esa macro podría no existir antes de C11, así que deberíamos comprobar la versión del lenguaje con <code>__STDC_VERSION__</code><a href="#fn204" class="footnote-ref" id="fnref204" role="doc-noteref"><sup>204</sup></a>.</p>
<div class="sourceCode" id="cb765"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb765-1"><a href="#cb765-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if __STDC_VERSION__ &lt; 201112L || __STDC_NO_ATOMICS__ == 1</span></span>
<span id="cb765-2"><a href="#cb765-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define HAS_ATOMICS </span><span class="dv">0</span></span>
<span id="cb765-3"><a href="#cb765-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb765-4"><a href="#cb765-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define HAS_ATOMICS </span><span class="dv">1</span></span>
<span id="cb765-5"><a href="#cb765-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p></p>
<p></p>
<p>Si esas pruebas pasan, entonces puedes incluir con seguridad <code>&lt;stdatomic.h&gt;</code>, la cabecera en la que se basa el resto de este capítulo. Pero si no hay soporte atómico, puede que esa cabecera ni siquiera exista.</p>
<p>En algunos sistemas, puede que necesites añadir <code>-latomic</code> al final de tu línea de comandos de compilación para usar cualquier función del fichero de cabecera.</p>
<p></p>
<h2 data-number="40.2" id="variables-atómicas"><span class="header-section-number">40.2</span> Variables atómicas</h2>
<p>Esto es <em>parte</em> de cómo funcionan las variables atómicas:</p>
<p>Si tienes una variable atómica compartida y escribes en ella desde una hebra, esa escritura será <em>todo o nada</em> en otra hebra.</p>
<p>Es decir, el otro proceso verá la escritura completa de, digamos, un valor de 32 bits. No la mitad. No hay forma de que un subproceso interrumpa a otro que está en medio de una escritura atómica multibyte.</p>
<p>Es casi como si hubiera un pequeño bloqueo en torno a la obtención y el establecimiento de esa variable. (¡Y <em>podría</em> haberlo! Ver <a href="#lock-free-atomic">Variables atómicas libres de bloqueo</a>, más abajo).</p>
<p>Y en esa nota, usted puede conseguir lejos con nunca usando atomics si usted utiliza mutexes para trabar sus secciones críticas. Es sólo que hay una clase de <em>estructuras de datos libres de bloqueo</em> que siempre permiten a otros hilos progresar en lugar de ser bloqueados por un mutex… pero son difíciles de crear correctamente desde cero, y son una de las cosas que están más allá del alcance de la guía, lamentablemente.</p>
<p>Eso es sólo una parte de la historia. Pero es la parte con la que empezaremos.</p>
<p>Antes de continuar, ¿cómo se declara que una variable es atómica?</p>
<p>Primero, incluye <code>&lt;stdatomic.h&gt;</code>.</p>
<p></p>
<p>Esto nos da tipos como <code>atomic_int</code>.</p>
<p>Y entonces podemos simplemente declarar variables para que sean de ese tipo.</p>
<p>Pero hagamos una demostración donde tenemos dos hilos. El primero se ejecuta durante un tiempo y luego establece una variable a un valor específico, luego sale. El otro se ejecuta hasta que ve que el valor se establece, y luego se sale.</p>
<div class="sourceCode" id="cb766"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb766-1"><a href="#cb766-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb766-2"><a href="#cb766-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb766-3"><a href="#cb766-3"></a><span class="pp">#include </span><span class="im">&lt;stdatomic.h&gt;</span></span>
<span id="cb766-4"><a href="#cb766-4"></a></span>
<span id="cb766-5"><a href="#cb766-5"></a>atomic_int x<span class="op">;</span>   <span class="co">// ¡EL PODER DE LA ATOMIC! ¡BWHAHAHA!</span></span>
<span id="cb766-6"><a href="#cb766-6"></a></span>
<span id="cb766-7"><a href="#cb766-7"></a><span class="dt">int</span> thread1<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb766-8"><a href="#cb766-8"></a><span class="op">{</span></span>
<span id="cb766-9"><a href="#cb766-9"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb766-10"><a href="#cb766-10"></a></span>
<span id="cb766-11"><a href="#cb766-11"></a>    printf<span class="op">(</span><span class="st">&quot;Thread 1: Sleeping for 1.5 seconds</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb766-12"><a href="#cb766-12"></a>    thrd_sleep<span class="op">(&amp;(</span><span class="kw">struct</span> timespec<span class="op">){.</span>tv_sec<span class="op">=</span><span class="dv">1</span><span class="op">,</span> <span class="op">.</span>tv_nsec<span class="op">=</span><span class="dv">500000000</span><span class="op">},</span> NULL<span class="op">);</span></span>
<span id="cb766-13"><a href="#cb766-13"></a></span>
<span id="cb766-14"><a href="#cb766-14"></a>    printf<span class="op">(</span><span class="st">&quot;Thread 1: Setting x to 3490</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb766-15"><a href="#cb766-15"></a>    x <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb766-16"><a href="#cb766-16"></a></span>
<span id="cb766-17"><a href="#cb766-17"></a>    printf<span class="op">(</span><span class="st">&quot;Thread 1: Exiting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb766-18"><a href="#cb766-18"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb766-19"><a href="#cb766-19"></a><span class="op">}</span></span>
<span id="cb766-20"><a href="#cb766-20"></a></span>
<span id="cb766-21"><a href="#cb766-21"></a><span class="dt">int</span> thread2<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb766-22"><a href="#cb766-22"></a><span class="op">{</span></span>
<span id="cb766-23"><a href="#cb766-23"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb766-24"><a href="#cb766-24"></a></span>
<span id="cb766-25"><a href="#cb766-25"></a>    printf<span class="op">(</span><span class="st">&quot;Thread 2: Waiting for 3490</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb766-26"><a href="#cb766-26"></a>    <span class="cf">while</span> <span class="op">(</span>x <span class="op">!=</span> <span class="dv">3490</span><span class="op">)</span> <span class="op">{}</span>  <span class="co">// spin here</span></span>
<span id="cb766-27"><a href="#cb766-27"></a></span>
<span id="cb766-28"><a href="#cb766-28"></a>    printf<span class="op">(</span><span class="st">&quot;Thread 2: Got 3490--exiting!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb766-29"><a href="#cb766-29"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb766-30"><a href="#cb766-30"></a><span class="op">}</span></span>
<span id="cb766-31"><a href="#cb766-31"></a></span>
<span id="cb766-32"><a href="#cb766-32"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb766-33"><a href="#cb766-33"></a><span class="op">{</span></span>
<span id="cb766-34"><a href="#cb766-34"></a>    x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb766-35"><a href="#cb766-35"></a></span>
<span id="cb766-36"><a href="#cb766-36"></a>    thrd_t t1<span class="op">,</span> t2<span class="op">;</span></span>
<span id="cb766-37"><a href="#cb766-37"></a></span>
<span id="cb766-38"><a href="#cb766-38"></a>    thrd_create<span class="op">(&amp;</span>t1<span class="op">,</span> thread1<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb766-39"><a href="#cb766-39"></a>    thrd_create<span class="op">(&amp;</span>t2<span class="op">,</span> thread2<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb766-40"><a href="#cb766-40"></a></span>
<span id="cb766-41"><a href="#cb766-41"></a>    thrd_join<span class="op">(</span>t1<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb766-42"><a href="#cb766-42"></a>    thrd_join<span class="op">(</span>t2<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb766-43"><a href="#cb766-43"></a></span>
<span id="cb766-44"><a href="#cb766-44"></a>    printf<span class="op">(</span><span class="st">&quot;Main    : Threads are done, so x better be 3490</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb766-45"><a href="#cb766-45"></a>    printf<span class="op">(</span><span class="st">&quot;Main    : And indeed, x == </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb766-46"><a href="#cb766-46"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>El segundo hilo gira en su lugar, mirando la bandera y esperando a que se establezca en el valor <code>3490</code>. Y el primero lo hace.</p>
<p>Y obtengo esta salida:</p>
<div class="sourceCode" id="cb767"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb767-1"><a href="#cb767-1" aria-hidden="true" tabindex="-1"></a>Thread 1: Sleeping for 1.5 seconds</span>
<span id="cb767-2"><a href="#cb767-2" aria-hidden="true" tabindex="-1"></a>Thread 2: Waiting for 3490</span>
<span id="cb767-3"><a href="#cb767-3" aria-hidden="true" tabindex="-1"></a>Thread 1: Setting x to 3490</span>
<span id="cb767-4"><a href="#cb767-4" aria-hidden="true" tabindex="-1"></a>Thread 1: Exiting</span>
<span id="cb767-5"><a href="#cb767-5" aria-hidden="true" tabindex="-1"></a>Thread 2: Got 3490--exiting!</span>
<span id="cb767-6"><a href="#cb767-6" aria-hidden="true" tabindex="-1"></a>Main    : Threads are done, so x better be 3490</span>
<span id="cb767-7"><a href="#cb767-7" aria-hidden="true" tabindex="-1"></a>Main    : And indeed, x == 3490</span></code></pre></div>
<p>¡Mira, ma! ¡Estamos accediendo a una variable desde diferentes hilos y sin usar un mutex! Y eso funcionará siempre gracias a la naturaleza atómica de las variables atómicas.</p>
<p>Te estarás preguntando qué pasa si en vez de eso es un <code>int</code> normal no atómico. Bueno, en mi sistema sigue funcionando… a menos que haga una compilación optimizada, en cuyo caso se cuelga en el hilo 2 esperando a que se establezca el 3490<a href="#fn205" class="footnote-ref" id="fnref205" role="doc-noteref"><sup>205</sup></a>.</p>
<p>Pero esto es sólo el principio de la historia. La siguiente parte va a requerir más poder mental y tiene que ver con algo llamado <em>sincronización</em>.</p>
<h2 data-number="40.3" id="sincronización"><span class="header-section-number">40.3</span> Sincronización</h2>
<p></p>
<p>La siguiente parte de nuestra historia trata sobre cuándo ciertas escrituras de memoria en un hilo se hacen visibles para las de otro hilo.</p>
<p>Podrías pensar que es inmediatamente, ¿verdad? Pero no es así. Varias cosas pueden ir mal. Raramente mal.</p>
<p>El compilador puede haber reordenado los accesos a memoria de modo que cuando crees que estableces un valor relativo a otro puede no ser cierto. E incluso si el compilador no lo hizo, tu CPU podría haberlo hecho sobre la marcha. O puede que haya algo más en esta arquitectura que haga que las escrituras en una CPU se retrasen antes de ser visibles en otra.</p>
<p>La buena noticia es que podemos condensar todos estos problemas potenciales en uno: los accesos no sincronizados a la memoria pueden aparecer fuera de orden dependiendo del hilo que esté haciendo la observación, como si las propias líneas de código hubieran sido reordenadas.</p>
<p>A modo de ejemplo, ¿qué ocurre primero en el siguiente código, la escritura en <code>x</code> o la escritura en <code>y</code>?</p>
<div class="sourceCode" id="cb768"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb768-1"><a href="#cb768-1"></a><span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span>  <span class="co">// global</span></span>
<span id="cb768-2"><a href="#cb768-2"></a></span>
<span id="cb768-3"><a href="#cb768-3"></a><span class="co">// ...</span></span>
<span id="cb768-4"><a href="#cb768-4"></a></span>
<span id="cb768-5"><a href="#cb768-5"></a>x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb768-6"><a href="#cb768-6"></a>y <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb768-7"><a href="#cb768-7"></a></span>
<span id="cb768-8"><a href="#cb768-8"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span></code></pre></div>
<p>Respuesta: no lo sabemos. El compilador o la CPU podrían invertir silenciosamente las líneas 5 y 6 y no nos daríamos cuenta. El código se ejecutaría con un único hilo <em>como si</em> se ejecutara en el orden del código.</p>
<p>En un escenario multihilo, podríamos tener algo como este pseudocódigo:</p>
<div class="sourceCode" id="cb769"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb769-1"><a href="#cb769-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb769-2"><a href="#cb769-2"></a></span>
<span id="cb769-3"><a href="#cb769-3"></a>thread1<span class="op">()</span> <span class="op">{</span></span>
<span id="cb769-4"><a href="#cb769-4"></a>    x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb769-5"><a href="#cb769-5"></a>    y <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb769-6"><a href="#cb769-6"></a><span class="op">}</span></span>
<span id="cb769-7"><a href="#cb769-7"></a></span>
<span id="cb769-8"><a href="#cb769-8"></a>thread2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb769-9"><a href="#cb769-9"></a>    <span class="cf">while</span> <span class="op">(</span>y <span class="op">!=</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{}</span>  <span class="co">// spin</span></span>
<span id="cb769-10"><a href="#cb769-10"></a>    printf<span class="op">(</span><span class="st">&quot;x is now </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 2? ...or 0?</span></span>
<span id="cb769-11"><a href="#cb769-11"></a><span class="op">}</span></span></code></pre></div>
<p>¿Cuál es la salida del hilo 2?</p>
<p>Bueno, si a <code>x</code> se le asigna <code>2</code> <em>antes</em> de que a <code>y</code> se le asigne <code>3</code>, entonces esperaría que la salida fuera la muy sensata:</p>
<div class="sourceCode" id="cb770"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb770-1"><a href="#cb770-1" aria-hidden="true" tabindex="-1"></a>x is now 2 </span></code></pre></div>
<p>Pero algo astuto podría reordenar las líneas 4 y 5 haciendo que veamos el valor de <code>0</code> para <code>x</code> cuando lo imprimamos.</p>
<p>En otras palabras, todo está perdido a menos que podamos decir de alguna manera: “A partir de este punto, espero que todas las escrituras anteriores en otro hilo sean visibles en este hilo”.</p>
<p>Dos hilos <em>sincronizan</em> cuando coinciden en el estado de la memoria compartida. Como hemos visto, no siempre están de acuerdo con el código. Entonces, ¿cómo se ponen de acuerdo?</p>
<p>El uso de variables atómicas puede forzar el acuerdo<a href="#fn206" class="footnote-ref" id="fnref206" role="doc-noteref"><sup>206</sup></a>. Si un hilo escribe en una variable atómica, está diciendo “cualquiera que lea esta variable atómica en el futuro también verá todos los cambios que hice en la memoria (atómica o no) hasta la variable atómica inclusive”.</p>
<p>O, en términos más humanos, sentémonos a la mesa de conferencias y asegurémonos de que estamos de acuerdo en qué partes de la memoria compartida contienen qué valores. Estás de acuerdo en que los cambios de memoria que has hecho hasta e incluyendo el almacenamiento atómico serán visibles para mí después de que haga una carga de la misma variable atómica.</p>
<p>Así que podemos arreglar fácilmente nuestro ejemplo:</p>
<div class="sourceCode" id="cb771"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb771-1"><a href="#cb771-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb771-2"><a href="#cb771-2"></a>atomic <span class="dt">int</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Make y atomic</span></span>
<span id="cb771-3"><a href="#cb771-3"></a></span>
<span id="cb771-4"><a href="#cb771-4"></a>thread1<span class="op">()</span> <span class="op">{</span></span>
<span id="cb771-5"><a href="#cb771-5"></a>    x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb771-6"><a href="#cb771-6"></a>    y <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>             <span class="co">// Sincronizar al escribir</span></span>
<span id="cb771-7"><a href="#cb771-7"></a><span class="op">}</span></span>
<span id="cb771-8"><a href="#cb771-8"></a></span>
<span id="cb771-9"><a href="#cb771-9"></a>thread2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb771-10"><a href="#cb771-10"></a>    <span class="cf">while</span> <span class="op">(</span>y <span class="op">!=</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{}</span>  <span class="co">// Sincronizar en lectura</span></span>
<span id="cb771-11"><a href="#cb771-11"></a>    printf<span class="op">(</span><span class="st">&quot;x is now </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 2, period.</span></span>
<span id="cb771-12"><a href="#cb771-12"></a><span class="op">}</span></span></code></pre></div>
<p>Como los hilos se sincronizan a través de <code>y</code>, todas las escrituras en el hilo 1 que ocurrieron <em>antes</em> de la escritura en <code>y</code> son visibles en el hilo 2 <em>después</em> de la lectura de <code>y</code> (en el bucle <code>while</code>).</p>
<p>Es importante tener en cuenta un par de cosas aquí:</p>
<ol type="1">
<li><p>Nada duerme. La sincronización no es una operación de bloqueo. Ambos hilos están funcionando a toda máquina hasta que salen. Incluso el que está atascado en el bucle no está bloqueando la ejecución de ningún otro.</p></li>
<li><p>La sincronización ocurre cuando un hilo lee una variable atómica que otro hilo escribió. Así que cuando el hilo 2 lee <code>y</code>, todas las escrituras de memoria anteriores en el hilo 1 (es decir, la configuración de <code>x</code>) serán visibles en el hilo 2.</p></li>
<li><p>Observa que <code>x</code> no es atómica. Eso está bien porque no estamos sincronizando sobre <code>x</code>, y la sincronización sobre <code>y</code> cuando la escribimos en el hilo 1 significa que todas las escrituras previas -incluyendo <code>x</code> - en el hilo 1 serán visibles para otros hilos… si esos otros hilos leen <code>y</code> para sincronizarse.</p></li>
</ol>
<p>Forzar esta sincronización es ineficiente y puede ser mucho más lento que usar una variable normal. Esta es la razón por la que no usamos atomics a menos que sea necesario para una aplicación en particular.</p>
<p>Esto es lo básico. Profundicemos un poco más.</p>
<p></p>
<h2 data-number="40.4" id="adquirir-y-liberar"><span class="header-section-number">40.4</span> Adquirir y Liberar</h2>
<p> </p>
<p>Más terminología. Vale la pena aprender esto ahora.</p>
<p>Cuando un hilo lee una variable atómica, se dice que es una operación de <em>adquisición</em>.</p>
<p>Cuando un hilo escribe una variable atómica, se dice que es una operación de <em>liberación</em>.</p>
<p>¿Qué es esto? Vamos a alinearlas con los términos que ya conoces cuando se trata de variables atómicas:</p>
<p><strong>Leer = Cargar = Adquirir</strong>. Como cuando comparas una variable atómica o la lees para copiarla a otro valor.</p>
<p><strong>Escribir = Almacenar = Liberar</strong>. Como cuando asignas un valor a una variable atómica.</p>
<p>Cuando se usan variables atómicas con esta semántica de adquisición/liberación, C especifica qué puede ocurrir cuándo.</p>
<p>La adquisición/liberación es la base de la sincronización de la que acabamos de hablar.</p>
<p>Cuando un hilo adquiere una variable atómica, puede ver los valores establecidos en otro hilo que liberó esa misma variable.</p>
<p>En otras palabras:</p>
<p>Cuando un hilo lee una variable atómica, puede ver los valores establecidos en otro hilo que escribió en esa misma variable.</p>
<p>La sincronización se produce a través del par acquire/release.</p>
<p>Más detalles:</p>
<p>Con lectura/carga/adquisición de una variable atómica particular:</p>
<ul>
<li><p>Todas las escrituras (atómicas o no atómicas) en otro hilo que ocurrieron antes de que ese otro hilo escribiera/almacenara/liberara esta variable atómica son ahora visibles en este hilo.</p></li>
<li><p>El nuevo valor de la variable atómica establecida por el otro hilo también es visible en este hilo.</p></li>
<li><p>Ninguna lectura o escritura de cualquier variable/memoria en el hilo actual puede ser reordenada para ocurrir antes de esta adquisición.</p></li>
<li><p>La adquisición actúa como una barrera unidireccional cuando se trata de reordenar código; las lecturas y escrituras en el hilo actual pueden moverse de <em>antes</em> de la adquisición a <em>después</em> de ella. Pero, más importante para la sincronización, nada puede moverse hacia arriba desde <em>después</em> de la adquisición a <em>antes</em> de ella.</p></li>
</ul>
<p>Con escritura/almacenamiento/liberación de una variable atómica particular:</p>
<ul>
<li><p>Todas las escrituras (atómicas o no atómicas) en el subproceso actual que se produjeron antes de esta liberación se vuelven visibles para otros subprocesos que han leído/cargado/adquirido la misma variable atómica.</p></li>
<li><p>El valor escrito en esta variable atómica por este hilo también es visible para otros hilos.</p></li>
<li><p>Ninguna lectura o escritura de cualquier variable/memoria en el hilo actual puede ser reordenada para que ocurra después de esta liberación.</p></li>
<li><p>La liberación actúa como una barrera unidireccional cuando se trata de reordenar código: las lecturas y escrituras en el hilo actual pueden moverse de <em>después</em> de la liberación a <em>antes</em> de ella. Pero, lo que es más importante para la sincronización, nada puede moverse hacia abajo desde <em>antes</em> de la liberación a <em>después</em> de ella.</p></li>
</ul>
<p>De nuevo, el resultado es la sincronización de la memoria de un subproceso a otro. El segundo hilo puede estar seguro de que las variables y la memoria se escriben en el orden previsto por el programador.</p>
<pre><code>int x, y, z = 0;
atomic_int a = 0;

thread1() {
    x = 10;
    y = 20;
    a = 999;  // Liberación
    z = 30;
}

thread2()
{
    while (a != 999) { } // Adquirir

    assert(x == 10);  // nunca se afirma, x es siempre 10
    assert(y == 20);  // nunca se afirma, y es siempre 20

    assert(z == 0);  // ¡¡podría afirmarlo!!
}</code></pre>
<p>En el ejemplo anterior, <code>thread2</code> puede estar seguro de los valores de <code>x</code> y <code>y</code> después de adquirir <code>a</code> porque fueron establecidos antes de que <code>thread1</code> liberara el atómico <code>a</code>.</p>
<p>Pero <code>thread2</code> no puede estar seguro del valor de <code>z</code> porque ocurrió después de la liberación. Quizás la asignación a <code>z</code> se movió antes que la asignación a <code>a</code>.</p>
<p>Una nota importante: liberar una variable atómica no tiene efecto sobre las adquisiciones de diferentes variables atómicas. Cada variable está aislada de las demás.</p>
<p> </p>
<h2 data-number="40.5" id="consistencia-secuencial"><span class="header-section-number">40.5</span> Consistencia secuencial</h2>
<p> ¿Estás aguantando? Estamos a través de la carne de la utilización más simple de atómica. Y como ni siquiera vamos a hablar aquí de los usos más complejos, puedes relajarte un poco.</p>
<p>La consistencia secuencial es lo que se llama un ordenamiento de memoria. Hay muchos ordenamientos de memoria, pero la consistencia secuencial es la más sana<a href="#fn207" class="footnote-ref" id="fnref207" role="doc-noteref"><sup>207</sup></a> que C tiene para ofrecer. También es la predeterminada. Tienes que salir de tu camino para usar otros ordenamientos de memoria.</p>
<p>Todo lo que hemos estado hablando hasta ahora ha sucedido dentro del ámbito de la consistencia secuencial.</p>
<p>Hemos hablado de cómo el compilador o la CPU pueden reordenar las lecturas y escrituras de memoria en un único hilo siempre que siga la regla <em>as-if</em>.</p>
<p>Y hemos visto cómo podemos frenar este comportamiento sincronizando sobre variables atómicas.</p>
<p>Formalicemos un poco más.</p>
<p>Si las operaciones son <em>secuencialmente consistentes</em>, significa que al final del día, cuando todo está dicho y hecho, todos los hilos pueden levantar sus pies, abrir su bebida de elección, y todos están de acuerdo en el orden en que los cambios de memoria se produjeron durante la ejecución. Y ese orden es el especificado por el código.</p>
<p>Uno no dirá: “¿Pero <em>B</em> no sucedió antes que <em>A</em>?” si el resto dice: “<em>A</em> definitivamente sucedió antes que <em>B</em>”. Aquí todos son amigos.</p>
<p>En particular, dentro de un hilo, ninguna de las adquisiciones y liberaciones puede reordenarse entre sí. Esto se suma a las reglas sobre qué otros accesos a memoria pueden reordenarse a su alrededor.</p>
<p>Esta regla da un nivel adicional de cordura a la progresión de cargas/adquisiciones y almacenamientos/liberación atómicos.</p>
<p>Cualquier otro orden de memoria en C implica una relajación de las reglas de reordenación, ya sea para adquisiciones/liberaciones u otros accesos a memoria, atómicos o no. Lo harías si <em>realmente</em> supieras lo que estás haciendo y necesitaras el aumento de velocidad. Aquí hay ejércitos de dragones…</p>
<p>Hablaremos de ello más adelante, pero por ahora vamos a ceñirnos a lo seguro y práctico.</p>
<p></p>
<h2 data-number="40.6" id="asignaciones-y-operadores-atómicos"><span class="header-section-number">40.6</span> Asignaciones y operadores atómicos</h2>
<p></p>
<p>Algunos operadores sobre variables atómicas son atómicos. Y otros no lo son.</p>
<p>Empecemos con un contraejemplo:</p>
<div class="sourceCode" id="cb773"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb773-1"><a href="#cb773-1" aria-hidden="true" tabindex="-1"></a>atomic_int x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb773-2"><a href="#cb773-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb773-3"><a href="#cb773-3" aria-hidden="true" tabindex="-1"></a>thread1<span class="op">()</span> <span class="op">{</span></span>
<span id="cb773-4"><a href="#cb773-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">+</span> <span class="dv">3</span><span class="op">;</span>  <span class="co">// NOT atomic!</span></span>
<span id="cb773-5"><a href="#cb773-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Dado que hay una lectura de <code>x</code> a la derecha de la asignación y una escritura efectiva a la izquierda, se trata de dos operaciones. Otro hilo podría colarse en medio y hacerte infeliz.</p>
<p>Pero <em>puedes</em> usar la abreviatura <code>+=</code> para obtener una operación atómica:</p>
<div class="sourceCode" id="cb774"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb774-1"><a href="#cb774-1" aria-hidden="true" tabindex="-1"></a>atomic_int x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb774-2"><a href="#cb774-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb774-3"><a href="#cb774-3" aria-hidden="true" tabindex="-1"></a>thread1<span class="op">()</span> <span class="op">{</span></span>
<span id="cb774-4"><a href="#cb774-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">+=</span> <span class="dv">3</span><span class="op">;</span>   <span class="co">// ATOMIC!</span></span>
<span id="cb774-5"><a href="#cb774-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>En ese caso, <code>x</code> se incrementará atómicamente en <code>3</code>–ningún otro hilo puede saltar en medio.</p>
<p>En particular, los siguientes operadores son operaciones atómicas de lectura-modificación-escritura con consistencia secuencial, así que úsalos con alegre abandono. (En el ejemplo, <code>a</code> es atómico).</p>
<div class="sourceCode" id="cb775"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb775-1"><a href="#cb775-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">++</span>       a<span class="op">--</span>       <span class="op">--</span>a       <span class="op">++</span>a</span>
<span id="cb775-2"><a href="#cb775-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">+=</span> b    a <span class="op">-=</span> b    a <span class="op">*=</span> b    a <span class="op">/=</span> b    a <span class="op">%=</span> b</span>
<span id="cb775-3"><a href="#cb775-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">&amp;=</span> b    a <span class="op">|=</span> b    a <span class="op">^=</span> b    a <span class="op">&gt;&gt;=</span> b   a <span class="op">&lt;&lt;=</span> b</span></code></pre></div>
<p></p>
<h2 data-number="40.7" id="funciones-de-biblioteca-que-se-sincronizan-automáticamente"><span class="header-section-number">40.7</span> Funciones de biblioteca que se sincronizan automáticamente</h2>
<p></p>
<p>Hasta ahora hemos hablado de cómo se puede sincronizar con variables atómicas, pero resulta que hay algunas funciones de biblioteca que hacen algunas limitadas detrás de las escenas de sincronización, ellos mismos.</p>
<div class="sourceCode" id="cb776"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb776-1"><a href="#cb776-1" aria-hidden="true" tabindex="-1"></a>call_once<span class="op">()</span>      thrd_create<span class="op">()</span>       thrd_join<span class="op">()</span></span>
<span id="cb776-2"><a href="#cb776-2" aria-hidden="true" tabindex="-1"></a>mtx_lock<span class="op">()</span>       mtx_timedlock<span class="op">()</span>     mtx_trylock<span class="op">()</span></span>
<span id="cb776-3"><a href="#cb776-3" aria-hidden="true" tabindex="-1"></a>malloc<span class="op">()</span>         calloc<span class="op">()</span>            realloc<span class="op">()</span></span>
<span id="cb776-4"><a href="#cb776-4" aria-hidden="true" tabindex="-1"></a>aligned_alloc<span class="op">()</span></span></code></pre></div>
<p><strong><code>call_once()</code></strong>—Sincroniza con todas las llamadas posteriores a <code>call_once()</code> para una bandera en particular. De esta forma, las llamadas posteriores pueden estar seguras de que si otro hilo establece la bandera, la verán.</p>
<p><strong><code>thrd_create()</code></strong>—Sincroniza con el inicio del nuevo hilo, que puede estar seguro de que verá todas las escrituras en memoria compartida del hilo padre desde antes de la llamada a <code>thrd_create()</code>.</p>
<p><strong><code>thrd_join()</code></strong>Cuando un hilo muere, se sincroniza con esta función. La hebra que ha llamado a <code>thrd_join()</code> puede estar segura de que puede ver todas las escrituras compartidas de la hebra fallecida.</p>
<p><strong><code>mtx_lock()</code></strong>—Las llamadas anteriores a <code>mtx_unlock()</code> en el mismo mutex se sincronizan en esta llamada. Este es el caso que más refleja el proceso de adquisición/liberación del que ya hemos hablado. <code>mtx_unlock()</code> realiza una liberación en la variable mutex, asegurando que cualquier hilo posterior que haga una adquisición con <code>mtx_lock()</code> pueda ver todos los cambios de memoria compartida en la sección crítica.</p>
<p><strong><code>mtx_timedlock()</code></strong> y <strong><code>mtx_trylock()</code></strong>—Similar a la situación con <code>mtx_lock()</code>, si esta llamada tiene éxito, las llamadas anteriores a <code>mtx_unlock()</code> se sincronizan con ésta.</p>
<p><strong>Funciones de memoria dinámica</strong>: si asignas memoria, se sincroniza con la anterior liberación de esa misma memoria. Y las asignaciones y desasignaciones de esa región de memoria en particular ocurren en un único orden total que todos los hilos pueden acordar. Creo que la idea aquí es que la desasignación puede limpiar la región si lo desea, y queremos estar seguros de que una asignación posterior no vea los datos no limpiados. Que alguien me diga si hay algo más.</p>
<p></p>
<h2 data-number="40.8" id="especificador-de-tipo-atómico-calificador"><span class="header-section-number">40.8</span> Especificador de Tipo Atómico, Calificador</h2>
<p>Bajemos un poco el nivel y veamos qué tipos tenemos disponibles, y cómo podemos incluso crear nuevos tipos atómicos.</p>
<p></p>
<p>Lo primero es lo primero, echemos un vistazo a los tipos atómicos incorporados y a lo que son <code>typedef</code>. (Spoiler: <code>_Atomic</code> es un calificador de tipo)</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Atomic type</th>
<th>Longhand equivalent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>atomic_bool</code></td>
<td><code>_Atomic _Bool</code></td>
</tr>
<tr class="even">
<td><code>atomic_char</code></td>
<td><code>_Atomic char</code></td>
</tr>
<tr class="odd">
<td><code>atomic_schar</code></td>
<td><code>_Atomic signed char</code></td>
</tr>
<tr class="even">
<td><code>atomic_uchar</code></td>
<td><code>_Atomic unsigned char</code></td>
</tr>
<tr class="odd">
<td><code>atomic_short</code></td>
<td><code>_Atomic short</code></td>
</tr>
<tr class="even">
<td><code>atomic_ushort</code></td>
<td><code>_Atomic unsigned short</code></td>
</tr>
<tr class="odd">
<td><code>atomic_int</code></td>
<td><code>_Atomic int</code></td>
</tr>
<tr class="even">
<td><code>atomic_uint</code></td>
<td><code>_Atomic unsigned int</code></td>
</tr>
<tr class="odd">
<td><code>atomic_long</code></td>
<td><code>_Atomic long</code></td>
</tr>
<tr class="even">
<td><code>atomic_ulong</code></td>
<td><code>_Atomic unsigned long</code></td>
</tr>
<tr class="odd">
<td><code>atomic_llong</code></td>
<td><code>_Atomic long long</code></td>
</tr>
<tr class="even">
<td><code>atomic_ullong</code></td>
<td><code>_Atomic unsigned long long</code></td>
</tr>
<tr class="odd">
<td><code>atomic_char16_t</code></td>
<td><code>_Atomic char16_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_char32_t</code></td>
<td><code>_Atomic char32_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_wchar_t</code></td>
<td><code>_Atomic wchar_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_int_least8_t</code></td>
<td><code>_Atomic int_least8_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uint_least8_t</code></td>
<td><code>_Atomic uint_least8_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_int_least16_t</code></td>
<td><code>_Atomic int_least16_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uint_least16_t</code></td>
<td><code>_Atomic uint_least16_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_int_least32_t</code></td>
<td><code>_Atomic int_least32_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uint_least32_t</code></td>
<td><code>_Atomic uint_least32_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_int_least64_t</code></td>
<td><code>_Atomic int_least64_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uint_least64_t</code></td>
<td><code>_Atomic uint_least64_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_int_fast8_t</code></td>
<td><code>_Atomic int_fast8_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uint_fast8_t</code></td>
<td><code>_Atomic uint_fast8_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_int_fast16_t</code></td>
<td><code>_Atomic int_fast16_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uint_fast16_t</code></td>
<td><code>_Atomic uint_fast16_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_int_fast32_t</code></td>
<td><code>_Atomic int_fast32_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uint_fast32_t</code></td>
<td><code>_Atomic uint_fast32_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_int_fast64_t</code></td>
<td><code>_Atomic int_fast64_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uint_fast64_t</code></td>
<td><code>_Atomic uint_fast64_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_intptr_t</code></td>
<td><code>_Atomic intptr_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uintptr_t</code></td>
<td><code>_Atomic uintptr_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_size_t</code></td>
<td><code>_Atomic size_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_ptrdiff_t</code></td>
<td><code>_Atomic ptrdiff_t</code></td>
</tr>
<tr class="even">
<td><code>atomic_intmax_t</code></td>
<td><code>_Atomic intmax_t</code></td>
</tr>
<tr class="odd">
<td><code>atomic_uintmax_t</code></td>
<td><code>_Atomic uintmax_t</code></td>
</tr>
</tbody>
</table>
<p></p>
<p>Utilízalos cuando quieras. Son consistentes con los alias atómicos que se encuentran en C++, si eso ayuda.</p>
<p>Pero, ¿y si quieres más?</p>
<p>Puedes hacerlo con un calificador de tipo o un especificador de tipo.</p>
<p></p>
<p>En primer lugar, el especificador. Es la palabra clave <code>_Atomic</code> con un tipo en paréntesis después<a href="#fn208" class="footnote-ref" id="fnref208" role="doc-noteref"><sup>208</sup></a>—apto para usarse con <code>typedef</code>:</p>
<div class="sourceCode" id="cb777"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb777-1"><a href="#cb777-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">_Atomic</span><span class="op">(</span><span class="dt">double</span><span class="op">)</span> atomic_double<span class="op">;</span></span>
<span id="cb777-2"><a href="#cb777-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb777-3"><a href="#cb777-3" aria-hidden="true" tabindex="-1"></a>atomic_double f<span class="op">;</span></span></code></pre></div>
<p>Restricciones en el especificador: el tipo que está haciendo atómico no puede ser de tipo array o función, ni puede ser atómico o calificado de otra manera.</p>
<p> </p>
<p>Siguiente, ¡calificador! Es la palabra clave <code>_Atomic</code> <em>sin</em> un tipo entre paréntesis.</p>
<p>Así que hacen cosas similares<a href="#fn209" class="footnote-ref" id="fnref209" role="doc-noteref"><sup>209</sup></a>:</p>
<div class="sourceCode" id="cb778"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb778-1"><a href="#cb778-1" aria-hidden="true" tabindex="-1"></a><span class="kw">_Atomic</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> i<span class="op">;</span>   <span class="co">// especificador de tipo</span></span>
<span id="cb778-2"><a href="#cb778-2" aria-hidden="true" tabindex="-1"></a><span class="kw">_Atomic</span> <span class="dt">int</span>  j<span class="op">;</span>   <span class="co">// especificador de tipo</span></span></code></pre></div>
<p>Lo que ocurre es que puedes incluir otros calificadores de tipo con este último:</p>
<div class="sourceCode" id="cb779"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb779-1"><a href="#cb779-1" aria-hidden="true" tabindex="-1"></a><span class="kw">_Atomic</span> <span class="dt">volatile</span> <span class="dt">int</span> k<span class="op">;</span>   <span class="co">// variable atómica cualificada</span></span></code></pre></div>
<p>Restricciones en el calificador: el tipo que estás haciendo atómico no puede ser de tipo array o función.</p>
<p></p>
<h2 data-number="40.9" id="lock-free-atomic"><span class="header-section-number">40.9</span> Variables atómicas sin bloqueo</h2>
<p></p>
<p>Las arquitecturas de hardware están limitadas en la cantidad de datos que pueden leer y escribir atómicamente. Depende de cómo esté cableado. Y varía.</p>
<p>Si usas un tipo atómico, puedes estar seguro de que los accesos a ese tipo serán atómicos… pero hay una trampa: si el hardware no puede hacerlo, se hace con un bloqueo, en su lugar.</p>
<p>Así que el acceso atómico se convierte en bloqueo-acceso-desbloqueo, lo que es bastante más lento y tiene algunas implicaciones para los manejadores de señales.</p>
<p><a href="#atomic-flags">Banderas atómicas</a>, más abajo, es el único tipo atómico que está garantizado que esté libre de bloqueos en todas las implementaciones conformes. En el mundo típico de los ordenadores de sobremesa/portátiles, es probable que otros tipos más grandes no tengan bloqueos.</p>
<p>Afortunadamente, tenemos un par de maneras de determinar si un tipo en particular es atómico libre de bloqueo o no.</p>
<p>En primer lugar, algunas macros—puedes usarlas en tiempo de compilación con <code>#if</code>. Se aplican tanto a tipos con signo como sin signo.</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Atomic Type</th>
<th>Lock Free Macro</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>atomic_bool</code></td>
<td><code>ATOMIC_BOOL_LOCK_FREE</code></td>
</tr>
<tr class="even">
<td><code>atomic_char</code></td>
<td><code>ATOMIC_CHAR_LOCK_FREE</code></td>
</tr>
<tr class="odd">
<td><code>atomic_char16_t</code></td>
<td><code>ATOMIC_CHAR16_T_LOCK_FREE</code></td>
</tr>
<tr class="even">
<td><code>atomic_char32_t</code></td>
<td><code>ATOMIC_CHAR32_T_LOCK_FREE</code></td>
</tr>
<tr class="odd">
<td><code>atomic_wchar_t</code></td>
<td><code>ATOMIC_WCHAR_T_LOCK_FREE</code></td>
</tr>
<tr class="even">
<td><code>atomic_short</code></td>
<td><code>ATOMIC_SHORT_LOCK_FREE</code></td>
</tr>
<tr class="odd">
<td><code>atomic_int</code></td>
<td><code>ATOMIC_INT_LOCK_FREE</code></td>
</tr>
<tr class="even">
<td><code>atomic_long</code></td>
<td><code>ATOMIC_LONG_LOCK_FREE</code></td>
</tr>
<tr class="odd">
<td><code>atomic_llong</code></td>
<td><code>ATOMIC_LLONG_LOCK_FREE</code></td>
</tr>
<tr class="even">
<td><code>atomic_intptr_t</code></td>
<td><code>ATOMIC_POINTER_LOCK_FREE</code></td>
</tr>
</tbody>
</table>
<p>Estas macros pueden tener <em>tres</em> valores diferentes:</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0</code></td>
<td>Never lock-free.</td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td><em>Sometimes</em> lock-free.</td>
</tr>
<tr class="odd">
<td><code>2</code></td>
<td>Always lock-free.</td>
</tr>
</tbody>
</table>
<p>Espera… ¿cómo puede algo estar <em>a veces</em> libre de bloqueos? Esto sólo significa que la respuesta no se conoce en tiempo de compilación, pero podría conocerse en tiempo de ejecución. Tal vez la respuesta varía dependiendo de si se está ejecutando este código en Intel o AMD Genuine, o algo así<a href="#fn210" class="footnote-ref" id="fnref210" role="doc-noteref"><sup>210</sup></a></p>
<p>Pero siempre se puede probar en tiempo de ejecución con la <code>atomic_is_lock_free()</code>. Esta función devuelve verdadero o falso si el tipo en particular es atómico en este momento.</p>
<p>¿Por qué nos importa?</p>
<p>Lock-free es más rápido, así que tal vez hay un problema de velocidad que usted codificaría de otra manera. O quizás necesites usar una variable atómica en un manejador de señales.</p>
<p></p>
<h3 data-number="40.9.1" id="manejadores-de-señales-y-atómicos-sin-bloqueo"><span class="header-section-number">40.9.1</span> Manejadores de señales y atómicos sin bloqueo</h3>
<p> </p>
<p>Si lees o escribes una variable compartida (duración de almacenamiento estático o <code>_Thread_Local</code>) en un manejador de señales, es un comportamiento indefinido [¡jajaja!]… A menos que hagas una de las siguientes cosas</p>
<ol type="1">
<li><p>Escribir en una variable de tipo <code>volatile sig_atomic_t</code>.</p></li>
<li><p>Leer o escribir en una variable atómica sin bloqueo.</p></li>
</ol>
<p>Hasta donde yo sé, las variables atómicas sin bloqueo son una de las pocas formas de obtener información de un manejador de señales de forma portable.</p>
<p>La especificación es un poco vaga, en mi lectura, sobre el orden de memoria cuando se trata de adquirir o liberar variables atómicas en el manejador de señales. C++ dice, y tiene sentido, que tales accesos no tienen secuencia con respecto al resto del programa<a href="#fn211" class="footnote-ref" id="fnref211" role="doc-noteref"><sup>211</sup></a>. La señal puede ser levantada, después de todo, en cualquier momento. Así que asumo que el comportamiento de C es similar.</p>
<p> </p>
<h2 data-number="40.10" id="atomic-flags"><span class="header-section-number">40.10</span> Banderas atómicas</h2>
<p> </p>
<p>Sólo hay un tipo que el estándar garantiza que será un atómico sin bloqueo: <code>atomic_flag</code>. Es un tipo opaco para operaciones <a href="https://en.wikipedia.org/wiki/Test-and-set">test-and-set</a><a href="#fn212" class="footnote-ref" id="fnref212" role="doc-noteref"><sup>212</sup></a>.</p>
<p>Puede ser <em>set</em> o <em>clear</em>. Puedes inicializarlo a clear con:</p>
<p></p>
<div class="sourceCode" id="cb780"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb780-1"><a href="#cb780-1" aria-hidden="true" tabindex="-1"></a>atomic_flag f <span class="op">=</span> ATOMIC_FLAG_INIT<span class="op">;</span></span></code></pre></div>
<p></p>
<p></p>
<p>Puede establecer la bandera atómicamente con <code>atomic_flag_test_and_set()</code>, que establecerá la bandera y devolverá su estado anterior como <code>_Bool</code> (true para set).</p>
<p></p>
<p>Puede borrar la bandera atómicamente con <code>atomic_flag_clear()</code>.</p>
<p>Este es un ejemplo en el que initamos la bandera a limpiar, la establecemos dos veces y la volvemos a limpiar.</p>
<div class="sourceCode" id="cb781"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb781-1"><a href="#cb781-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb781-2"><a href="#cb781-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb781-3"><a href="#cb781-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdatomic.h&gt;</span></span>
<span id="cb781-4"><a href="#cb781-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-5"><a href="#cb781-5" aria-hidden="true" tabindex="-1"></a>atomic_flag f <span class="op">=</span> ATOMIC_FLAG_INIT<span class="op">;</span></span>
<span id="cb781-6"><a href="#cb781-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-7"><a href="#cb781-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb781-8"><a href="#cb781-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb781-9"><a href="#cb781-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> r <span class="op">=</span> atomic_flag_test_and_set<span class="op">(&amp;</span>f<span class="op">);</span></span>
<span id="cb781-10"><a href="#cb781-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Value was: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> r<span class="op">);</span>           <span class="co">// 0</span></span>
<span id="cb781-11"><a href="#cb781-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-12"><a href="#cb781-12" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> atomic_flag_test_and_set<span class="op">(&amp;</span>f<span class="op">);</span></span>
<span id="cb781-13"><a href="#cb781-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Value was: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> r<span class="op">);</span>           <span class="co">// 1</span></span>
<span id="cb781-14"><a href="#cb781-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-15"><a href="#cb781-15" aria-hidden="true" tabindex="-1"></a>    atomic_flag_clear<span class="op">(&amp;</span>f<span class="op">);</span></span>
<span id="cb781-16"><a href="#cb781-16" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> atomic_flag_test_and_set<span class="op">(&amp;</span>f<span class="op">);</span></span>
<span id="cb781-17"><a href="#cb781-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Value was: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> r<span class="op">);</span>           <span class="co">// 0</span></span>
<span id="cb781-18"><a href="#cb781-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<h2 data-number="40.11" id="estructuras-y-uniones-atómicasatomic-structs-and-unions"><span class="header-section-number">40.11</span> Estructuras y uniones atómicas(Atomic <code>struct</code>s and <code>union</code>s)</h2>
<p></p>
<p>Usando el cualificador o especificador <code>_Atomic</code>, ¡puedes hacer <code>struct</code>s o <code>union</code>s atómicas! Bastante asombroso.</p>
<p>Si no hay muchos datos (por ejemplo, un puñado de bytes), el tipo atómico resultante puede estar libre de bloqueos. Compruébalo con <code>atomic_is_lock_free()</code>.</p>
<div class="sourceCode" id="cb782"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb782-1"><a href="#cb782-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb782-2"><a href="#cb782-2"></a><span class="pp">#include </span><span class="im">&lt;stdatomic.h&gt;</span></span>
<span id="cb782-3"><a href="#cb782-3"></a></span>
<span id="cb782-4"><a href="#cb782-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb782-5"><a href="#cb782-5"></a><span class="op">{</span></span>
<span id="cb782-6"><a href="#cb782-6"></a>    <span class="kw">struct</span> point <span class="op">{</span></span>
<span id="cb782-7"><a href="#cb782-7"></a>        <span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb782-8"><a href="#cb782-8"></a>    <span class="op">};</span></span>
<span id="cb782-9"><a href="#cb782-9"></a></span>
<span id="cb782-10"><a href="#cb782-10"></a>    <span class="kw">_Atomic</span><span class="op">(</span><span class="kw">struct</span> point<span class="op">)</span> p<span class="op">;</span></span>
<span id="cb782-11"><a href="#cb782-11"></a></span>
<span id="cb782-12"><a href="#cb782-12"></a>    printf<span class="op">(</span><span class="st">&quot;Is lock free: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> atomic_is_lock_free<span class="op">(&amp;</span>p<span class="op">));</span></span>
<span id="cb782-13"><a href="#cb782-13"></a><span class="op">}</span></span></code></pre></div>
<p>Aquí está el truco: no puedes acceder a los campos de una <code>struct</code> o <code>union</code> atómica… ¿entonces qué sentido tiene? Bueno, puedes <em>copiar</em> atómicamente toda la <code>struct</code> en una variable no atómica y luego usarla. También puedes copiar atómicamente a la inversa.</p>
<div class="sourceCode" id="cb783"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb783-1"><a href="#cb783-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb783-2"><a href="#cb783-2"></a><span class="pp">#include </span><span class="im">&lt;stdatomic.h&gt;</span></span>
<span id="cb783-3"><a href="#cb783-3"></a></span>
<span id="cb783-4"><a href="#cb783-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb783-5"><a href="#cb783-5"></a><span class="op">{</span></span>
<span id="cb783-6"><a href="#cb783-6"></a>    <span class="kw">struct</span> point <span class="op">{</span></span>
<span id="cb783-7"><a href="#cb783-7"></a>        <span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb783-8"><a href="#cb783-8"></a>    <span class="op">};</span></span>
<span id="cb783-9"><a href="#cb783-9"></a></span>
<span id="cb783-10"><a href="#cb783-10"></a>    <span class="kw">_Atomic</span><span class="op">(</span><span class="kw">struct</span> point<span class="op">)</span> p<span class="op">;</span></span>
<span id="cb783-11"><a href="#cb783-11"></a>    <span class="kw">struct</span> point t<span class="op">;</span></span>
<span id="cb783-12"><a href="#cb783-12"></a></span>
<span id="cb783-13"><a href="#cb783-13"></a>    p <span class="op">=</span> <span class="op">(</span><span class="kw">struct</span> point<span class="op">){</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span>  <span class="co">// Atomic copy</span></span>
<span id="cb783-14"><a href="#cb783-14"></a></span>
<span id="cb783-15"><a href="#cb783-15"></a>    <span class="co">//printf(&quot;%f\n&quot;, p.x);  // Error</span></span>
<span id="cb783-16"><a href="#cb783-16"></a></span>
<span id="cb783-17"><a href="#cb783-17"></a>    t <span class="op">=</span> p<span class="op">;</span>   <span class="co">// Atomic copy</span></span>
<span id="cb783-18"><a href="#cb783-18"></a></span>
<span id="cb783-19"><a href="#cb783-19"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> t<span class="op">.</span>x<span class="op">);</span>  <span class="co">// OK!</span></span>
<span id="cb783-20"><a href="#cb783-20"></a><span class="op">}</span></span></code></pre></div>
<p>También puede declarar una <code>estructura</code> en la que los campos individuales sean atómicos. La implementación define si los tipos atómicos están permitidos en los campos de bits.</p>
<p></p>
<h2 data-number="40.12" id="punteros-atómicos"><span class="header-section-number">40.12</span> Punteros Atómicos</h2>
<p></p>
<p>Sólo una nota sobre la colocación de <code>_Atomic</code> cuando se trata de punteros.</p>
<p>En primer lugar, los punteros a atómicos (es decir, el valor del puntero no es atómico, pero la cosa a la que apunta sí lo es):</p>
<div class="sourceCode" id="cb784"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb784-1"><a href="#cb784-1" aria-hidden="true" tabindex="-1"></a><span class="kw">_Atomic</span> <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb784-2"><a href="#cb784-2" aria-hidden="true" tabindex="-1"></a><span class="kw">_Atomic</span> <span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span>  <span class="co">// p es un puntero a un int atómico</span></span>
<span id="cb784-3"><a href="#cb784-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb784-4"><a href="#cb784-4" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span>  <span class="co">// OK!</span></span></code></pre></div>
<p>En segundo lugar, los punteros atómicos a valores no atómicos (es decir, el valor del puntero en sí es atómico, pero la cosa a la que apunta no lo es):</p>
<div class="sourceCode" id="cb785"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb785-1"><a href="#cb785-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb785-2"><a href="#cb785-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span> <span class="kw">_Atomic</span> p<span class="op">;</span>  <span class="co">// p es un puntero atómico a un int</span></span>
<span id="cb785-3"><a href="#cb785-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb785-4"><a href="#cb785-4" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span>  <span class="co">// OK!</span></span></code></pre></div>
<p>Por último, punteros atómicos a valores atómicos (es decir, el puntero y la cosa a la que apunta son ambos atómicos):</p>
<div class="sourceCode" id="cb786"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb786-1"><a href="#cb786-1" aria-hidden="true" tabindex="-1"></a><span class="kw">_Atomic</span> <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb786-2"><a href="#cb786-2" aria-hidden="true" tabindex="-1"></a><span class="kw">_Atomic</span> <span class="dt">int</span> <span class="op">*</span> <span class="kw">_Atomic</span> p<span class="op">;</span>  <span class="co">// p es un puntero atómico a un int atómico</span></span>
<span id="cb786-3"><a href="#cb786-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb786-4"><a href="#cb786-4" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span>  <span class="co">// OK!</span></span></code></pre></div>
<p></p>
<h2 data-number="40.13" id="orden-de-memoria"><span class="header-section-number">40.13</span> Orden de Memoria</h2>
<p> </p>
<p>Ya hemos hablado de la coherencia secuencial, que es la más sensata de todas. Pero hay muchas otras:</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th><code>memory_order</code></th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>memory_order_seq_cst</code></td>
<td>Sequential Consistency</td>
</tr>
<tr class="even">
<td><code>memory_order_acq_rel</code></td>
<td>Acquire/Release</td>
</tr>
<tr class="odd">
<td><code>memory_order_release</code></td>
<td>Release</td>
</tr>
<tr class="even">
<td><code>memory_order_acquire</code></td>
<td>Acquire</td>
</tr>
<tr class="odd">
<td><code>memory_order_consume</code></td>
<td>Consume</td>
</tr>
<tr class="even">
<td><code>memory_order_relaxed</code></td>
<td>Relaxed</td>
</tr>
</tbody>
</table>
<p>Puede especificar otras con determinadas funciones de biblioteca. Por ejemplo, puedes añadir un valor a una variable atómica así:</p>
<div class="sourceCode" id="cb787"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb787-1"><a href="#cb787-1" aria-hidden="true" tabindex="-1"></a>atomic_int x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb787-2"><a href="#cb787-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb787-3"><a href="#cb787-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">+=</span> <span class="dv">5</span><span class="op">;</span>  <span class="co">// Consistencia secuencial, por defecto</span></span></code></pre></div>
<p>O puede hacer lo mismo con esta función de biblioteca:</p>
<p></p>
<div class="sourceCode" id="cb788"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb788-1"><a href="#cb788-1" aria-hidden="true" tabindex="-1"></a>atomic_int x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb788-2"><a href="#cb788-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb788-3"><a href="#cb788-3" aria-hidden="true" tabindex="-1"></a>atomic_fetch_add<span class="op">(&amp;</span>x<span class="op">,</span> <span class="dv">5</span><span class="op">);</span>  <span class="co">// Consistencia secuencial, por defecto</span></span></code></pre></div>
<p></p>
<p>O puedes hacer lo mismo con una ordenación explícita de la memoria:</p>
<p></p>
<div class="sourceCode" id="cb789"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb789-1"><a href="#cb789-1" aria-hidden="true" tabindex="-1"></a>atomic_int x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb789-2"><a href="#cb789-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb789-3"><a href="#cb789-3" aria-hidden="true" tabindex="-1"></a>atomic_fetch_add_explicit<span class="op">(&amp;</span>x<span class="op">,</span> <span class="dv">5</span><span class="op">,</span> memory_order_seq_cst<span class="op">);</span></span></code></pre></div>
<p>Pero, ¿y si no quisiéramos coherencia secuencial? Y quisieras adquirir / liberar en su lugar por cualquier razón? Sólo dilo:</p>
<div class="sourceCode" id="cb790"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb790-1"><a href="#cb790-1" aria-hidden="true" tabindex="-1"></a>atomic_int x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb790-2"><a href="#cb790-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb790-3"><a href="#cb790-3" aria-hidden="true" tabindex="-1"></a>atomic_fetch_add_explicit<span class="op">(&amp;</span>x<span class="op">,</span> <span class="dv">5</span><span class="op">,</span> memory_order_acq_rel<span class="op">);</span></span></code></pre></div>
<p></p>
<p>A continuación haremos un desglose de los diferentes órdenes de memoria. No te metas con nada que no sea consistencia secuencial a menos que sepas lo que estás haciendo. Es realmente fácil cometer errores que causarán fallos raros y difíciles de reproducir.</p>
<h3 data-number="40.13.1" id="consistencia-secuencial-1"><span class="header-section-number">40.13.1</span> Consistencia Secuencial</h3>
<p> </p>
<ul>
<li>Adquisición de operaciones de carga (véase más adelante).</li>
<li>Las operaciones de almacenamiento se liberan (véase más abajo).</li>
<li>Las operaciones de lectura-modificación-escritura adquieren y luego liberan.</li>
</ul>
<p>Además, para mantener el orden total de las adquisiciones y liberaciones, ninguna adquisición o liberación se reordenará entre sí. (Las reglas de adquisición/liberación no prohíben reordenar una liberación seguida de una adquisición. Pero las reglas de coherencia secuencial sí lo hacen).</p>
<p> </p>
<h3 data-number="40.13.2" id="acquire"><span class="header-section-number">40.13.2</span> Acquire</h3>
<p> </p>
<p>Esto es lo que ocurre en una operación de carga/lectura de una variable atómica.</p>
<ul>
<li><p>Si otro hilo liberó esta variable atómica, todas las escrituras que ese hilo hizo son ahora visibles en este hilo.</p></li>
<li><p>Los accesos a memoria en este thread que ocurran después de esta carga no pueden ser reordenados antes.</p></li>
</ul>
<p> </p>
<h3 data-number="40.13.3" id="release"><span class="header-section-number">40.13.3</span> Release</h3>
<p> </p>
<p>Esto es lo que ocurre al almacenar/escribir una variable atómica.</p>
<ul>
<li><p>Si otro hilo adquiere más tarde esta variable atómica, toda la memoria en este hilo antes de su escritura atómica se vuelven visibles para ese otra hebra.</p></li>
<li><p>Los accesos a memoria en este hilo que ocurran antes de la liberación no pueden reordenarse después.</p></li>
</ul>
<p> </p>
<h3 data-number="40.13.4" id="consume"><span class="header-section-number">40.13.4</span> Consume</h3>
<p> </p>
<p>Esta es una extraña, similar a una versión menos estricta de adquirir. Afecta a los accesos a memoria que son <em>data dependent</em> de la variable atómica.</p>
<p>Ser “dependiente de datos” significa vagamente que la variable atómica se utiliza en un cálculo.</p>
<p>Es decir, si un hilo consume una variable atómica entonces todas las operaciones en ese hilo que utilicen esa variable atómica podrán ver las escrituras de memoria en el hilo que la libera.</p>
<p>Compárese con adquirir donde las escrituras en memoria en el subproceso que libera serán visibles para <em>todas</em> las operaciones en el subproceso actual, no sólo las que dependen de los datos. las dependientes de datos.</p>
<p>También como en acquire, hay una restricción sobre qué operaciones pueden ser reordenadas <em>antes</em> de consumir. Con acquire, no se podía reordenar nada antes. Con consume, no puedes reordenar nada que dependa del valor atómico cargado antes de él.</p>
<p> </p>
<h3 data-number="40.13.5" id="acquirerelease"><span class="header-section-number">40.13.5</span> Acquire/Release</h3>
<p> </p>
<p>Esto sólo se aplica a las operaciones de lectura-modificación-escritura. Es una adquisición y liberación en uno.</p>
<ul>
<li>Una adquisición ocurre para la lectura.</li>
<li>Una liberación ocurre para la escritura.</li>
</ul>
<p> </p>
<h3 data-number="40.13.6" id="relaxed"><span class="header-section-number">40.13.6</span> Relaxed</h3>
<p> </p>
<p>Sin reglas; ¡es la anarquía! Perros y gatos viviendo juntos… ¡histeria colectiva!</p>
<p>En realidad, hay una regla. Las lecturas y escrituras atómicas siguen siendo “todo o nada”. Pero las operaciones pueden reordenarse caprichosamente y hay cero sincronización entre hilos.</p>
<p>Hay algunos casos de uso para este orden de memoria, que puedes encontrar con un poco de búsqueda, por ejemplo, contadores simples.</p>
<p>Y puedes usar una valla para forzar la sincronización después de un montón de escrituras relajadas.</p>
<p> </p>
<h2 data-number="40.14" id="fences"><span class="header-section-number">40.14</span> Fences</h2>
<p></p>
<p>¿Sabes que las liberaciones y adquisiciones de variables atómicas se producen al leerlas y escribirlas?</p>
<p>Bueno, es posible hacer una liberación o adquisición <em>sin</em> una variable atómica, también.</p>
<p>Esto se llama un <em>fence</em>. Así que si quieres que todas las escrituras en un hilo sean visibles en otro lugar, puedes poner una valla de liberación en un hilo y una valla de adquisición en otro, igual que con el funcionamiento de las variables atómicas.</p>
<p>Como una operación consume no tiene sentido en un vallado<a href="#fn213" class="footnote-ref" id="fnref213" role="doc-noteref"><sup>213</sup></a>, <code>memory_order_consume</code> se trata como una adquisición.</p>
<p>Usted puede poner una cerca con cualquier orden especificado:</p>
<p></p>
<div class="sourceCode" id="cb791"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb791-1"><a href="#cb791-1" aria-hidden="true" tabindex="-1"></a>atomic_thread_fence<span class="op">(</span>memory_order_release<span class="op">);</span></span></code></pre></div>
<p> </p>
<p>También hay una versión ligera de una valla para usar con manejadores de señales, llamada <code>atomic_signal_fence()</code>.</p>
<p>Funciona de la misma manera que <code>atomic_thread_fence()</code>, excepto que:</p>
<ul>
<li><p>Sólo se ocupa de la visibilidad de valores dentro del mismo hilo; no hay sincronización con otros hilos.</p></li>
<li><p>No se emiten instrucciones hardware fence.</p></li>
</ul>
<p>Si quieres estar seguro de que los efectos secundarios de las operaciones no atómicas (y de las operaciones atómicas relajadas) son visibles en el manejador de señales, puedes usar esta valla.</p>
<p>La idea es que el manejador de señales se está ejecutando en <em>este</em> hilo, no en otro, por lo que esta es una forma más ligera de asegurarse de que los cambios fuera del manejador de señales son visibles dentro de él (es decir, que no han sido reordenados).</p>
<p> </p>
<h2 data-number="40.15" id="references"><span class="header-section-number">40.15</span> References</h2>
<p>Si quieres aprender más sobre este tema, aquí tienes algunas de las cosas que me ayudaron a superarlo:</p>
<ul>
<li><p>Herb Sutter’s <em><code>atomic&lt;&gt;</code> Weapons</em> talk:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=A8eCGOqgvH4">Part 1</a><a href="#fn214" class="footnote-ref" id="fnref214" role="doc-noteref"><sup>214</sup></a></li>
<li><a href="https://www.youtube.com/watch?v=KeLBd2EJLOU">part 2</a><a href="#fn215" class="footnote-ref" id="fnref215" role="doc-noteref"><sup>215</sup></a></li>
</ul></li>
<li><p><a href="https://preshing.com/archives/">Jeff Preshing’s materials</a><a href="#fn216" class="footnote-ref" id="fnref216" role="doc-noteref"><sup>216</sup></a>, in particular:</p>
<ul>
<li><a href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/">An Introduction to Lock-Free Programming</a><a href="#fn217" class="footnote-ref" id="fnref217" role="doc-noteref"><sup>217</sup></a></li>
<li><a href="https://preshing.com/20120913/acquire-and-release-semantics/">Acquire and Release Semantics</a><a href="#fn218" class="footnote-ref" id="fnref218" role="doc-noteref"><sup>218</sup></a></li>
<li><a href="https://preshing.com/20130702/the-happens-before-relation/">The <em>Happens-Before</em> Relation</a><a href="#fn219" class="footnote-ref" id="fnref219" role="doc-noteref"><sup>219</sup></a></li>
<li><a href="https://preshing.com/20130823/the-synchronizes-with-relation/">The <em>Synchronizes-With</em> Relation</a><a href="#fn220" class="footnote-ref" id="fnref220" role="doc-noteref"><sup>220</sup></a></li>
<li><a href="https://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/">The Purpose of <code>memory_order_consume</code> in C++11</a><a href="#fn221" class="footnote-ref" id="fnref221" role="doc-noteref"><sup>221</sup></a></li>
<li><a href="https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/">You Can Do Any Kind of Atomic Read-Modify-Write Operation</a><a href="#fn222" class="footnote-ref" id="fnref222" role="doc-noteref"><sup>222</sup></a></li>
</ul></li>
<li><p>CPPReference:</p>
<ul>
<li><a href="https://en.cppreference.com/w/c/atomic/memory_order">Memory Order</a><a href="#fn223" class="footnote-ref" id="fnref223" role="doc-noteref"><sup>223</sup></a></li>
<li><a href="https://en.cppreference.com/w/c/language/atomic">Atomic Types</a><a href="#fn224" class="footnote-ref" id="fnref224" role="doc-noteref"><sup>224</sup></a></li>
</ul></li>
<li><p>Bruce Dawson’s <a href="https://docs.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming">Lockless Programming Considerations</a><a href="#fn225" class="footnote-ref" id="fnref225" role="doc-noteref"><sup>225</sup></a></p></li>
<li><p>The helpful and knowledgeable folks on <a href="https://www.reddit.com/r/C_Programming/">r/C_Programming</a><a href="#fn226" class="footnote-ref" id="fnref226" role="doc-noteref"><sup>226</sup></a></p></li>
</ul>
<p></p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<h1 data-number="41" id="especificadores-de-función-especificadoresoperadores-de-alineación"><span class="header-section-number">41</span> Especificadores de Función, Especificadores/Operadores de Alineación</h1>
<p>En mi experiencia, estos no se utilizan mucho, pero los cubriremos aquí en aras de la exhaustividad.</p>
<h2 data-number="41.1" id="especificadores-de-función"><span class="header-section-number">41.1</span> Especificadores de función</h2>
<p></p>
<p>Cuando declaras una función, puedes dar al compilador un par de consejos sobre cómo podrían o serán utilizadas las funciones. Esto permite o anima al compilador a realizar ciertas optimizaciones.</p>
<h3 data-number="41.1.1" id="inline-para-la-velocidadtal-vez"><span class="header-section-number">41.1.1</span> <code>inline</code> para la Velocidad—tal vez</h3>
<p></p>
<p>Puede declarar una función para que sea inline de la siguiente manera:</p>
<div class="sourceCode" id="cb792"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb792-1"><a href="#cb792-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb792-2"><a href="#cb792-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb792-3"><a href="#cb792-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Esto pretende animar al compilador a hacer esta llamada a la función lo más rápido posible. Y, históricamente, una forma de hacerlo era <em>inlining</em>, lo que significa que el cuerpo de la función se incrustaba en su totalidad donde se realizaba la llamada. Esto evitaría toda la sobrecarga de establecer la llamada a la función y desmontarla a expensas de un mayor tamaño del código, ya que la función se copiaba por todas partes en lugar de reutilizarse.</p>
<p>Las cosas rápidas y sucias que hay que recordar son:</p>
<ol type="1">
<li><p>Probablemente no necesites usar <code>inline</code> por velocidad. Los compiladores modernos saben qué es lo mejor.</p></li>
<li><p>Si lo usas por velocidad, úsalo con ámbito de archivo, es decir, <code>static inline</code>. Esto evita las desordenadas reglas de vinculación externa y funciones inline.</p></li>
</ol>
<p>Deja de leer esta sección ahora.</p>
<p>Glotón para el castigo, ¿eh?</p>
<p>Vamos a tratar de dejar el <code>static</code> off.</p>
<div class="sourceCode" id="cb793"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb793-1"><a href="#cb793-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb793-2"><a href="#cb793-2"></a></span>
<span id="cb793-3"><a href="#cb793-3"></a><span class="kw">inline</span> <span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb793-4"><a href="#cb793-4"></a><span class="op">{</span></span>
<span id="cb793-5"><a href="#cb793-5"></a>    <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb793-6"><a href="#cb793-6"></a><span class="op">}</span></span>
<span id="cb793-7"><a href="#cb793-7"></a></span>
<span id="cb793-8"><a href="#cb793-8"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb793-9"><a href="#cb793-9"></a><span class="op">{</span></span>
<span id="cb793-10"><a href="#cb793-10"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> add<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb793-11"><a href="#cb793-11"></a><span class="op">}</span></span></code></pre></div>
<p><code>gcc</code> da un error de enlazador en <code>add()</code><a href="#fn227" class="footnote-ref" id="fnref227" role="doc-noteref"><sup>227</sup></a>. La especificación requiere que si tienes una función en línea no <code>externa</code> también debes proporcionar una versión con enlace externo.</p>
<p>Así que tendrías que tener una versión <code>externa</code> en algún otro lugar para que esto funcione. Si el compilador tiene tanto una función <code>inline</code> en el fichero actual como una versión externa de la misma función en otro lugar, puede elegir a cuál llamar. Así que recomiendo encarecidamente que sean la misma.</p>
<p>Otra cosa que puedes hacer es declarar la función como <code>extern inline</code>. Esto intentará inline en el mismo archivo (por velocidad), pero también creará una versión con enlace externo.</p>
<p></p>
<h3 data-number="41.1.2" id="noreturn"><span class="header-section-number">41.1.2</span> <code>noreturn</code> y <code>_Noreturn</code></h3>
<p> </p>
<p>Esto indica al compilador que una función concreta no volverá nunca a su invocador, es decir, que el programa saldrá por algún mecanismo antes de que la función retorne.</p>
<p>Esto permite al compilador realizar algunas optimizaciones en torno a la llamada a la función.</p>
<p>También le permite indicar a otros desarrolladores que cierta lógica del programa depende de que una función <em>no</em> regrese.</p>
<p>Es probable que nunca necesite usar esto, pero lo verá en algunas llamadas a bibliotecas como <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-exit"><code>exit()</code></a><a href="#fn228" class="footnote-ref" id="fnref228" role="doc-noteref"><sup>228</sup></a> y <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-abort"><code>abort()</code></a><a href="#fn229" class="footnote-ref" id="fnref229" role="doc-noteref"><sup>229</sup></a>.</p>
<p>La palabra clave incorporada es <code>_Noreturn</code>, pero si no rompe su código existente, todo el mundo recomendaría incluir <code>&lt;stdnoreturn.h&gt;</code> y usar la más fácil de leer <code>noreturn</code> en su lugar.</p>
<p>Es un comportamiento indefinido si una función especificada como <code>noreturn</code> realmente retorna. Es computacionalmente deshonesto.</p>
<p>Aquí hay un ejemplo de uso correcto de <code>noreturn</code>:</p>
<div class="sourceCode" id="cb794"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb794-1"><a href="#cb794-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb794-2"><a href="#cb794-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb794-3"><a href="#cb794-3"></a><span class="pp">#include </span><span class="im">&lt;stdnoreturn.h&gt;</span></span>
<span id="cb794-4"><a href="#cb794-4"></a></span>
<span id="cb794-5"><a href="#cb794-5"></a>noreturn <span class="dt">void</span> foo<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="co">// ¡Esta función nunca debe retornar!</span></span>
<span id="cb794-6"><a href="#cb794-6"></a><span class="op">{</span></span>
<span id="cb794-7"><a href="#cb794-7"></a>    printf<span class="op">(</span><span class="st">&quot;Happy days</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb794-8"><a href="#cb794-8"></a></span>
<span id="cb794-9"><a href="#cb794-9"></a>    exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span>            <span class="co">// Y no vuelve... ¡Sale por aquí!</span></span>
<span id="cb794-10"><a href="#cb794-10"></a><span class="op">}</span></span>
<span id="cb794-11"><a href="#cb794-11"></a></span>
<span id="cb794-12"><a href="#cb794-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb794-13"><a href="#cb794-13"></a><span class="op">{</span></span>
<span id="cb794-14"><a href="#cb794-14"></a>    foo<span class="op">();</span></span>
<span id="cb794-15"><a href="#cb794-15"></a><span class="op">}</span></span></code></pre></div>
<p>Si el compilador detecta que una función <code>noreturn</code> podría retornar, podría advertirte, de forma útil.</p>
<p>Sustituyendo la función <code>foo()</code> por esto:</p>
<div class="sourceCode" id="cb795"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb795-1"><a href="#cb795-1" aria-hidden="true" tabindex="-1"></a>noreturn <span class="dt">void</span> foo<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb795-2"><a href="#cb795-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb795-3"><a href="#cb795-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Breakin&#39; the law</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb795-4"><a href="#cb795-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>me da una advertencia:</p>
<div class="sourceCode" id="cb796"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb796-1"><a href="#cb796-1" aria-hidden="true" tabindex="-1"></a>foo.c:7:1: warning: function declared &#39;noreturn&#39; should not return</span></code></pre></div>
<p> </p>
<h2 data-number="41.2" id="especificadores-y-operadores-de-alineación"><span class="header-section-number">41.2</span> Especificadores y operadores de alineación</h2>
<p></p>
<p><a href="https://en.wikipedia.org/wiki/Data_structure_alignment"><em>Alignment</em></a><a href="#fn230" class="footnote-ref" id="fnref230" role="doc-noteref"><sup>230</sup></a> se refiere a los múltiplos de direcciones en los que se pueden almacenar objetos. ¿Se puede almacenar en cualquier dirección? ¿O debe ser una dirección inicial divisible por 2? ¿O por 8? ¿O 16?</p>
<p>Si estás programando algo de bajo nivel, como un asignador de memoria que interactúa con tu sistema operativo, puede que tengas que tener esto en cuenta. La mayoría de los desarrolladores pasan sus carreras sin utilizar esta funcionalidad en C.</p>
<h3 data-number="41.2.1" id="alignas-y-_alignas"><span class="header-section-number">41.2.1</span> <code>alignas</code> y <code>_Alignas</code></h3>
<p> </p>
<p>No es una función. Más bien, es un <em>especificador de alineación</em> que puedes usar con una declaración de variable.</p>
<p>El especificador incorporado es <code>_Alignas</code>, pero la cabecera <code>&lt;stdalign.h&gt;</code> lo define como <code>alignas</code> para que se vea mejor.</p>
<p>Si necesitas que tu <code>char</code> esté alineado como un <code>int</code>, puedes forzarlo así cuando lo declares:</p>
<div class="sourceCode" id="cb797"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb797-1"><a href="#cb797-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="kw">alignas</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> c<span class="op">;</span></span></code></pre></div>
<p>También puede pasar un valor constante o una expresión para la alineación. Esto tiene que ser algo soportado por el sistema, pero la especificación no llega a dictar qué valores se pueden poner ahí. Las potencias pequeñas de 2 (1, 2, 4, 8 y 16) suelen ser apuestas seguras.</p>
<div class="sourceCode" id="cb798"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb798-1"><a href="#cb798-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="kw">alignas</span><span class="op">(</span><span class="dv">8</span><span class="op">)</span> c<span class="op">;</span>   <span class="co">// alinear en límites de 8 bytes</span></span></code></pre></div>
<p>Si quiere alinear al máximo alineamiento usado por su sistema, incluya <code>&lt;stddef.h&gt;</code> y use el tipo <code>max_align_t</code>, así:</p>
<div class="sourceCode" id="cb799"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb799-1"><a href="#cb799-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="kw">alignas</span><span class="op">(</span><span class="dt">max_align_t</span><span class="op">)</span> c<span class="op">;</span></span></code></pre></div>
<p>Usted podría potencialmente <em>sobre-alinear</em> especificando una alineación mayor que la de <code>max_align_t</code>, pero si tales cosas están o no permitidas depende del sistema.</p>
<p> </p>
<h3 data-number="41.2.2" id="alignof-y-_alignof"><span class="header-section-number">41.2.2</span> <code>alignof</code> y <code>_Alignof</code></h3>
<p> </p>
<p>Este operador devolverá el múltiplo de dirección que un tipo particular utiliza para la alineación en este sistema. Por ejemplo, puede que <code>char</code>s se alinee cada 1 dirección, y <code>int</code>s se alinee cada 4 direcciones.</p>
<p>El operador incorporado es <code>_Alignof</code>, pero la cabecera <code>&lt;stdalign.h&gt;</code> lo define como <code>alignof</code> si quieres parecer más guay.</p>
<p>Aquí hay un programa que imprimirá las alineaciones de una variedad de tipos diferentes. De nuevo, estos variarán de un sistema a otro. Tenga en cuenta que el tipo <code>max_align_t</code> le dará la alineación máxima utilizada por el sistema.</p>
<div class="sourceCode" id="cb800"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb800-1"><a href="#cb800-1"></a><span class="pp">#include </span><span class="im">&lt;stdalign.h&gt;</span></span>
<span id="cb800-2"><a href="#cb800-2"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp">     </span><span class="co">// for printf()</span></span>
<span id="cb800-3"><a href="#cb800-3"></a><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span><span class="pp">    </span><span class="co">// for max_align_t</span></span>
<span id="cb800-4"><a href="#cb800-4"></a></span>
<span id="cb800-5"><a href="#cb800-5"></a><span class="kw">struct</span> t <span class="op">{</span></span>
<span id="cb800-6"><a href="#cb800-6"></a>    <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb800-7"><a href="#cb800-7"></a>    <span class="dt">char</span> b<span class="op">;</span></span>
<span id="cb800-8"><a href="#cb800-8"></a>    <span class="dt">float</span> c<span class="op">;</span></span>
<span id="cb800-9"><a href="#cb800-9"></a><span class="op">};</span></span>
<span id="cb800-10"><a href="#cb800-10"></a></span>
<span id="cb800-11"><a href="#cb800-11"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb800-12"><a href="#cb800-12"></a><span class="op">{</span></span>
<span id="cb800-13"><a href="#cb800-13"></a>    printf<span class="op">(</span><span class="st">&quot;char       : </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="dt">char</span><span class="op">));</span></span>
<span id="cb800-14"><a href="#cb800-14"></a>    printf<span class="op">(</span><span class="st">&quot;short      : </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="dt">short</span><span class="op">));</span></span>
<span id="cb800-15"><a href="#cb800-15"></a>    printf<span class="op">(</span><span class="st">&quot;int        : </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb800-16"><a href="#cb800-16"></a>    printf<span class="op">(</span><span class="st">&quot;long       : </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="dt">long</span><span class="op">));</span></span>
<span id="cb800-17"><a href="#cb800-17"></a>    printf<span class="op">(</span><span class="st">&quot;long long  : </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="dt">long</span> <span class="dt">long</span><span class="op">));</span></span>
<span id="cb800-18"><a href="#cb800-18"></a>    printf<span class="op">(</span><span class="st">&quot;double     : </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb800-19"><a href="#cb800-19"></a>    printf<span class="op">(</span><span class="st">&quot;long double: </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="dt">long</span> <span class="dt">double</span><span class="op">));</span></span>
<span id="cb800-20"><a href="#cb800-20"></a>    printf<span class="op">(</span><span class="st">&quot;struct t   : </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="kw">struct</span> t<span class="op">));</span></span>
<span id="cb800-21"><a href="#cb800-21"></a>    printf<span class="op">(</span><span class="st">&quot;max_align_t: </span><span class="sc">%zu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="dt">max_align_t</span><span class="op">));</span></span>
<span id="cb800-22"><a href="#cb800-22"></a><span class="op">}</span></span></code></pre></div>
<p>Salida en mi sistema:</p>
<div class="sourceCode" id="cb801"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb801-1"><a href="#cb801-1" aria-hidden="true" tabindex="-1"></a>char       : 1</span>
<span id="cb801-2"><a href="#cb801-2" aria-hidden="true" tabindex="-1"></a>short      : 2</span>
<span id="cb801-3"><a href="#cb801-3" aria-hidden="true" tabindex="-1"></a>int        : 4</span>
<span id="cb801-4"><a href="#cb801-4" aria-hidden="true" tabindex="-1"></a>long       : 8</span>
<span id="cb801-5"><a href="#cb801-5" aria-hidden="true" tabindex="-1"></a>long long  : 8</span>
<span id="cb801-6"><a href="#cb801-6" aria-hidden="true" tabindex="-1"></a>double     : 8</span>
<span id="cb801-7"><a href="#cb801-7" aria-hidden="true" tabindex="-1"></a>long double: 16</span>
<span id="cb801-8"><a href="#cb801-8" aria-hidden="true" tabindex="-1"></a>struct t   : 16</span>
<span id="cb801-9"><a href="#cb801-9" aria-hidden="true" tabindex="-1"></a>max_align_t: 16</span></code></pre></div>
<p> </p>
<h2 data-number="41.3" id="función-memalignment"><span class="header-section-number">41.3</span> Función <code>memalignment()</code></h2>
<p></p>
<p>¡Nuevo en C23!</p>
<p>(Advertencia: ninguno de mis compiladores soporta esta función todavía, así que el código está en gran parte sin probar).</p>
<p><code>alignof</code> es genial si conoces el tipo de tus datos. ¿Pero qué pasa si <em>desconoce</em> el tipo y sólo tiene un puntero a los datos?</p>
<p>¿Cómo podría ocurrir eso?</p>
<p>Bueno, con nuestro buen amigo el <code>void*</code>, por supuesto. No podemos pasarlo a <code>alignof</code>, pero ¿y si necesitamos saber la alineación de lo que apunta?</p>
<p>Podríamos querer saber esto si estamos a punto de usar la memoria para algo que tiene necesidades significativas de alineación. Por ejemplo, los tipos atómicos y flotantes a menudo se comportan mal si están mal alineados.</p>
<p>Así que con esta función podemos comprobar la alineación de algunos datos siempre que tengamos un puntero a esos datos, incluso si es un <code>void*</code>.</p>
<p>Hagamos una prueba rápida para ver si un puntero void está bien alineado para usarlo como tipo atómico, y, si es así, hagamos que una variable lo use como ese tipo:</p>
<div class="sourceCode" id="cb802"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb802-1"><a href="#cb802-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>p<span class="op">)</span></span>
<span id="cb802-2"><a href="#cb802-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb802-3"><a href="#cb802-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memalignment<span class="op">(</span>p<span class="op">)</span> <span class="op">&gt;=</span> <span class="kw">alignof</span><span class="op">(</span>atomic <span class="dt">int</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb802-4"><a href="#cb802-4" aria-hidden="true" tabindex="-1"></a>        atomic <span class="dt">int</span> <span class="op">*</span>i <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb802-5"><a href="#cb802-5" aria-hidden="true" tabindex="-1"></a>        do_things<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb802-6"><a href="#cb802-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span></span>
<span id="cb802-7"><a href="#cb802-7" aria-hidden="true" tabindex="-1"></a>        puts<span class="op">(</span><span class="st">&quot;This pointer is no good as an atomic int</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb802-8"><a href="#cb802-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb802-9"><a href="#cb802-9" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Sospecho que rara vez (hasta el punto de nunca, probablemente) necesitará utilizar esta función a menos que esté haciendo algunas cosas de bajo nivel.</p>
<p></p>
<p>Y ahí lo tienen. ¡Alineación!</p>
<p></p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>https://www.ioccc.org/<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>https://en.wikipedia.org/wiki/Python_(programming_language)<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>https://en.wikipedia.org/wiki/JavaScript<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>https://en.wikipedia.org/wiki/Java_(programming_language)<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>https://en.wikipedia.org/wiki/Rust_(programming_language)<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>https://en.wikipedia.org/wiki/Go_(programming_language)<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>https://en.wikipedia.org/wiki/Swift_(programming_language)<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>https://en.wikipedia.org/wiki/Objective-C<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>https://beej.us/guide/bgclr/<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>https://en.wikipedia.org/wiki/ANSI_C<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>https://en.wikipedia.org/wiki/POSIX<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>https://visualstudio.microsoft.com/vs/community/<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>https://docs.microsoft.com/en-us/windows/wsl/install-win10<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>https://developer.apple.com/xcode/<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>https://beej.us/guide/bgc/<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>https://en.cppreference.com/<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>https://groups.google.com/g/comp.lang.c<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>https://www.reddit. com/r/C_Programming/<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>https://en.wikipedia.org/wiki/Assembly_language<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p>https://en.wikipedia.org/wiki/Bare_machine<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21"><p>https://en.wikipedia.org/wiki/Operating_system<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22"><p>https://en.wikipedia.org/wiki/Embedded_system<a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23"><p>https://en.wikipedia.org/wiki/Rust_(programming_language)<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24"><p>Sé que alguien me discutirá esto, pero debe estar al menos entre los tres primeros, ¿verdad?<a href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25"><p>Bueno, técnicamente hay más de dos, pero bueno, finjamos que hay dos, ¿verdad?<a href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26"><p>https://en.wikipedia.org/wiki/Assembly_language<a href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn27"><p>https://en.wikipedia.org/wiki/Machine_code<a href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn28"><p>Técnicamente, contiene directivas de preprocesador y prototipos de funciones (más sobre eso adelante) para necesidades comunes de entrada y salida.<a href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29"><p>https://en.wikipedia.org/wiki/Unix<a href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30"><p>Si no le proporcionas un nombre de archivo de salida, por defecto se exportará a un archivo llamado <code>a.out</code>—este nombre de archivo tiene sus raíces en la historia profunda de Unix.<a href="#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn31"><p>https://formulae.brew.sh/formula/gcc<a href="#fnref31" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn32"><p>Un “byte” es típicamente un número binario de 8 bits. Piensa en ello como un entero que solo puede contener valores del 0 al 255, inclusive. Técnicamente, C permite que los bytes sean de cualquier número de bits y si quieres referirte inequívocamente a un número de 8 bits, deberías usar el término <em>octeto</em>. Pero los programadores asumirán que te refieres a 8 bits cuando dices “byte” a menos que especifiques lo contrario.<a href="#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn33"><p>Estoy simplificando mucho cómo funciona la memoria moderna aquí. Pero el modelo mental funciona, así que por favor perdóname.<a href="#fnref33" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn34"><p>Estoy siendo un poco impreciso aquí. Técnicamente, <code>3.14159</code> es del tipo <code>double</code>, pero aún no hemos llegado allí y quiero que asocies <code>float</code> con “Punto Flotante”, y C convertirá ese tipo felizmente en un <code>float</code>. En resumen, no te preocupes por ello hasta más adelante.<a href="#fnref34" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn35"><p>Lee esto como “puntero a un char” o “char pointer”. “Char” por carácter. Aunque no puedo encontrar un estudio, parece anecdóticamente que la mayoría de las personas pronuncian esto como “char”, una minoría dice “car”, y algunos pocos dicen “care”. Hablaremos más sobre los punteros más adelante.<a href="#fnref35" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn36"><p>Coloquialmente, decimos que tienen valores “aleatorios”, pero no son realmente—ni siquiera pseudo-realmente—números aleatorios.<a href="#fnref36" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn37"><p>Esto no es estrictamente 100% cierto. Cuando aprendamos sobre la duración de almacenamiento estática, descubrirás que algunas variables se inicializan automáticamente a cero. Pero lo seguro es siempre inicializarlas.<a href="#fnref37" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn38"><p>El <code>_t</code> es abreviatura de <code>type</code> (Tipo).<a href="#fnref38" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn39"><p>Excepto con arreglos de longitud variable—pero eso es una historia para otro momento.<a href="#fnref39" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn40"><p>https://beej.us/guide/bgclr/html/split/stdlib.html#man-srand<a href="#fnref40" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn41"><p>Esto se consideró tal peligro que los diseñadores del Lenguaje de Programación Go hicieron <code>break</code> por defecto; tienes que usar explícitamente la sentencia <code>fallthrough  (fallar la salida)</code> de Go si quieres pasar al siguiente caso<a href="#fnref41" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn42"><p>Nunca digas “nunca”.<a href="#fnref42" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn43"><p>Típicamente. Estoy seguro de que hay excepciones en los oscuros pasillos de la historia de la informática<a href="#fnref43" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn44"><p>Un byte es un número formado por no más de 8 dígitos binarios, o <em>bits</em> para abreviar. Esto significa que en dígitos decimales como los que usaba la abuela, puede contener un número sin signo entre 0 y 255, ambos inclusive<a href="#fnref44" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn45"><p>El orden en que vienen los bytes se denomina <em>endianidad</em> del número. Los sospechosos habituales son <em>big-endian</em> (con el byte más significativo primero) y <em>little-endian</em> (con el byte más significativo al final), o, ahora poco común, <em>mixed-endian</em> (con los bytes más significativos en otro lugar)<a href="#fnref45" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn46"><p>Es decir, base 16 con dígitos 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, y F.<a href="#fnref46" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn47"><p>https://en.wikipedia.org/wiki/Virtual_memory<a href="#fnref47" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn48"><p>¡Eso no es todo! Se usa en <code>/*comentarios*/</code> y en multiplicaciones, ¡y en prototipos de funciones con matrices de longitud variable! Es el mismo <code>*</code>, pero el contexto le da un significado diferente<a href="#fnref48" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn49"><p>https://en.wikipedia.org/wiki/Null_pointer#Historia<a href="#fnref49" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn50"><p>https://en.wikipedia.org/wiki/Sentinel value<a href="#fnref50" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn51"><p>Las variables de tipo puntero son <code>a</code>, <code>d</code>, <code>f</code> e <code>i</code>, porque son las que tienen <code>*</code> delante<a href="#fnref51" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn52"><p>Hoy en día, por lo menos<a href="#fnref52" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn53"><p>De nuevo, en realidad no, pero las matrices de longitud variable -de las que no soy muy fan- son una historia para otro momento<a href="#fnref53" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn54"><p>Dado que los arrays son sólo punteros al primer elemento del array bajo el capó, no hay información adicional que registre la longitud<a href="#fnref54" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn55"><p>Porque cuando pasas un array a una función, en realidad sólo estás pasando un puntero al primer elemento de ese array, no el array “entero”<a href="#fnref55" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn56"><p>En los viejos tiempos de MS-DOS, antes de que existiera la protección de memoria, yo escribía un código C particularmente abusivo que deliberadamente tenía todo tipo de comportamientos indefinidos. Pero sabía lo que hacía, y las cosas funcionaban bastante bien. Hasta que cometí un error que causó un bloqueo y, como descubrí al reiniciar, borró todas mis configuraciones de BIOS. Fue divertido. (Un saludo a <span class="citation" data-cites="man">@man</span> por esos momentos de diversión)<a href="#fnref56" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn57"><p>Hay un montón de cosas que causan un comportamiento indefinido, no sólo los accesos a arrays fuera de los límites. Esto es lo que hace al lenguaje C tan <em>excitante</em><a href="#fnref57" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn58"><p>https://en.wikipedia.org/wiki/Row-_and_column-major_order<a href="#fnref58" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn59"><p>Esto es técnicamente incorrecto, ya que un puntero a un array y un puntero al primer elemento de un array tienen tipos diferentes. Pero podemos quemar ese puente cuando lleguemos a él<a href="#fnref59" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn60"><p>C11 §6.7.6.2¶1 requiere que sea mayor que cero. Pero puede que veas código por ahí con arrays declarados de longitud cero al final de <code>struct</code>s y GCC es particularmente indulgente al respecto a menos que compiles con <code>-pedantic</code>. Este array de longitud cero era un mecanismo para hacer estructuras de longitud variable. Desafortunadamente, es técnicamente un comportamiento indefinido acceder a un array de este tipo aunque básicamente funcionaba en todas partes. C99 codificó un reemplazo bien definido llamado <em>flexible array members</em>, del que hablaremos más adelante<a href="#fnref60" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn61"><p>Esto también es equivalente: <code>void print_2D_array(int (*a)[3])</code>, pero eso es más de lo que quiero entrar ahora<a href="#fnref61" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn62"><p>Aunque es cierto que C no rastrea la longitud de las cadenas<a href="#fnref62" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn63"><p>Si estás usando el juego de caracteres básico o un juego de caracteres de 8 bits, estás acostumbrado a que un carácter sea un byte. Sin embargo, esto no es cierto en todas las codificaciones de caracteres<a href="#fnref63" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn64"><p>Esto es diferente del puntero <code>NULL</code>, y lo abreviaré <code>NUL</code> cuando hable del carácter frente a <code>NULL</code> para el puntero<a href="#fnref64" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn65"><p>Más adelante aprenderemos una forma más ordenada de hacerlo con aritmética de punteros<a href="#fnref65" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn66"><p>Hay una función más segura llamada <code>strncpy()</code> que probablemente deberías usar en su lugar, pero llegaremos a eso más tarde<a href="#fnref66" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn67"><p>Aunque en C los elementos individuales en memoria como <code>int</code>s se denominan «objetos», no son objetos en el sentido de la programación orientada a objetos<a href="#fnref67" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn68"><p>El Saturn fue una popular marca de coches económicos en los Estados Unidos hasta que fue sacada del negocio por el crack de 2008, tristemente para nosotros los fans.<a href="#fnref68" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn69"><p>Un puntero es probablemente de 8 bytes en un sistema de 64 bits<a href="#fnref69" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn70"><p>Una <em>copia profunda</em> sigue a los punteros en la <code>struct</code> y copia también los datos a los que apuntan. Una <em>copia superficial</em> sólo copia los punteros, pero no las cosas a las que apuntan. C no viene con ninguna funcionalidad de copia profunda incorporada<a href="#fnref70" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn71"><p>https://beej.us/guide/bgclr/html/split/stringref.html#man-strcmp<a href="#fnref71" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn72"><p>https://beej.us/guide/bgclr/html/split/stringref.html#man-memset<a href="#fnref72" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn73"><p>https://stackoverflow.com/questions/141720/how-do-you-compare-structs-for-equality-in-c<a href="#fnref73" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn74"><p>Solíamos tener tres nuevas líneas diferentes en amplio efecto: Retorno de carro (CR, usado en los viejos Macs), Salto de línea (LF, usado en sistemas Unix), y Retorno de carro/Salto de línea (CRLF, usado en sistemas Windows). Afortunadamente, la introducción de OS X, al estar basado en Unix, redujo este número a dos<a href="#fnref74" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn75"><p>Si el buffer no es lo suficientemente grande como para leer una línea entera, se detendrá la lectura a mitad de línea, y la siguiente llamada a <code>fgets()</code> continuará leyendo el resto de la línea<a href="#fnref75" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn76"><p>Normalmente el segundo programa leería todos los bytes a la vez, y <em>entonces</em> los imprimiría en un bucle. Eso sería más eficiente. Pero vamos para el valor de demostración, aquí<a href="#fnref76" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn77"><p>https://en.wikipedia.org/wiki/Hex_dump<a href="#fnref77" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn78"><p>https://en.wikipedia.org/wiki/Endianess<a href="#fnref78" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn79"><p>Y esta es la razón por la que usé bytes individuales en mis ejemplos <code>fwrite()</code> y <code>fread()</code>, arriba, astutamente<a href="#fnref79" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn80"><p>https://en.wikipedia.org/wiki/Protocol_buffers<a href="#fnref80" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn81"><p>Hablaremos más de ellas más adelante<a href="#fnref81" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn82"><p>Recuerda que el operador <code>sizeof</code> te dice el tamaño en bytes de un objeto en memoria<a href="#fnref82" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn83"><p>O cadena, que en realidad es un array de <code>char</code>s. Curiosamente, también puedes tener un puntero que haga referencia a <em>uno pasado</em> el final del array sin problema y seguir haciendo cálculos con él<a href="#fnref83" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn84"><p>https://beej.us/guide/bgclr/html/split/stdlib.html#man-qsort<a href="#fnref84" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn85"><p>https://beej.us/guide/bgclr/html/split/stdlib.html#man-bsearch<a href="#fnref85" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn86"><p>Porque recuerda que la notación de array es sólo una una desreferencia y algo de matemática de punteros, y no puedes desreferenciar un <code>void*</code><a href="#fnref86" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn87"><p>También puedes <em>castear</em> el <code>void*</code> a otro tipo, pero aún no hemos llegado a los castts<a href="#fnref87" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn88"><p>O hasta que el programa salga, en cuyo caso se liberará toda la memoria asignada por él. Asterisco: algunos sistemas te permiten asignar memoria que persiste después de que un programa salga, pero esto depende del sistema, está fuera del alcance de esta guía, y seguramente nunca lo harás por accidente<a href="#fnref88" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn89"><p>http://www.open-std.org/jtc1/sc22/wg14/www/docs/summary.htm#dr_460<a href="#fnref89" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn90"><p>https://en.wikipedia.org/wiki/Bit_ bucket<a href="#fnref90" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn91"><p>«Bit» es la abreviatura de <em>dígito binario</em>. El binario es otra forma de representar números. En lugar de los dígitos 0-9 a los que estamos acostumbrados, son los dígitos 0-1<a href="#fnref91" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn92"><p>https://en.wikipedia.org/wiki/Two%27s_complement<a href="#fnref92" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn93"><p>El término industrial para una secuencia de exactamente, indiscutiblemente 8 bits es un <em>octeto</em><a href="#fnref93" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn94"><p>En general, f usted tiene un <span class="math inline">\(n\)</span> bit número de complemento a dos, el rango con signo es <span class="math inline">\(-2^{n-1}\)</span> a <span class="math inline">\(2^{n-1}-1\)</span>. Y el rango sin signo es de <span class="math inline">\(0\)</span> a <span class="math inline">\(2^n-1\)</span><a href="#fnref94" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn95"><p>https://en.wikipedia.org/wiki/ASCII<a href="#fnref95" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn96"><p>https://en.wikipedia.org/wiki/ List_of information_system_character_sets<a href="#fnref96" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn97"><p>https://en.wikipedia.org/wiki/Unicode<a href="#fnref97" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn98"><p>Depende de si el valor por defecto de <code>char</code> es <code>signed char</code> o <code>unsigned char</code><a href="#fnref98" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn99"><p>https://en.wikipedia.org/wiki/Signed_number_representations#Signed_magnitude_representation<a href="#fnref99" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn100"><p>Mi <code>char</code> está con signo.<a href="#fnref100" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn101"><p>https://en.wikipedia.org/wiki/IEEE_754<a href="#fnref101" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn102"><p>Este programa se ejecuta como indican sus comentarios en un sistema con <code>FLT_DIG</code> de <code>6</code> que utiliza números en coma flotante IEEE-754 base-2. De lo contrario podrías obtener una salida diferente<a href="#fnref102" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn103"><p>Realmente me sorprende que C no tenga esto en la especificación todavía. En el documento C99 Rationale, escriben: «Una propuesta para añadir constantes binarias fue rechazada por falta de precedentes y utilidad insuficiente». Lo que parece una tontería a la luz de algunas de las otras características que han incluido. Apuesto a que una de las próximas versiones lo tiene.<a href="#fnref103" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn104"><p>https://en.wikipedia.org/wiki/ Scientific_notation<a href="#fnref104" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn105"><p>Son lo mismo, salvo que <code>snprintf()</code> permite especificar un número máximo de bytes de salida, evitando que se sobrepase el final de la cadena. Así que es más seguro<a href="#fnref105" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn106"><p>https://en.wikipedia.org/wiki/ASCII<a href="#fnref106" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn107"><p>Tenemos que pasar un puntero a <code>badchar</code> a <code>strtoul()</code> o no será capaz de modificarlo de ninguna manera que podamos ver, de forma análoga a por qué tienes que pasar un puntero a un <code>int</code> a una función si quieres que esa función sea capaz de cambiar el valor de ese <code>int</code><a href="#fnref107" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn108"><p>Cada carácter tiene un valor asociado para cualquier esquema de codificación de caracteres<a href="#fnref108" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn109"><p>En la práctica, lo que probablemente está ocurriendo en tu implementación es que los bits de orden alto simplemente se eliminan del resultado, de modo que un número de 16 bits <code>0x1234</code> que se convierte a un número de 8 bits termina como <code>0x0034</code>, o simplemente <code>0x34</code><a href="#fnref109" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn110"><p>De nuevo, en la práctica, lo que probablemente ocurrirá en tu sistema es que el patrón de bits para el original se truncará y luego sólo se usará para representar el número con signo, complemento a dos. Por ejemplo, mi sistema toma un <code>unsigned char</code> de <code>192</code> y lo convierte a <code>signed char</code> <code>-64</code>. En complemento a dos, el patrón de bits para ambos números es binario <code>11000000</code>.<a href="#fnref110" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn111"><p>En realidad no—simplemente se descarta con regularidad<a href="#fnref111" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn112"><p>Funciones con un número variable de argumentos.<a href="#fnref112" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn113"><p>Esto se hace raramente porque el compilador se quejará y tener un prototipo es lo <em>Correcto</em> de hacer. Creo que esto todavía funciona por razones históricas, antes de que los prototipos fueran una cosa<a href="#fnref113" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn114"><p>https://beej.us/guide/bgclr/html/split/ctype.html<a href="#fnref114" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn115"><p>https://gustedt.wordpress.com/2010/08/17/a-common-misconsception-the-register-keyword/<a href="#fnref115" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn116"><p>https://en.wikipedia.org/wiki/Processor_register<a href="#fnref116" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn117"><p>https://en.wikipedia.org/wiki/Boids<a href="#fnref117" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn118"><p>Históricamente, los programas de MS-DOS y Windows hacían esto de forma diferente a Unix. En Unix, el intérprete de comandos <em>expandía</em> el comodín en todos los archivos coincidentes antes de que el programa lo viera, mientras que las variantes de Microsoft pasaban la expresión del comodín al programa para que éste se ocupara de ella. En cualquier caso, hay argumentos que se pasan al programa<a href="#fnref118" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn119"><p>Como son nombres de parámetros normales, no tienes que llamarlos <code>argc</code> y <code>argv</code>. Pero es tan idiomático usar esos nombres, que si te pones creativo, otros programadores de C te mirarán con ojos sospechosos<a href="#fnref119" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn120"><p><code>ps</code>, Process Status, es un comando de Unix para ver qué procesos se están ejecutando en ese momento<a href="#fnref120" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn121"><p>https://en.wikipedia.org/wiki/Inception<a href="#fnref121" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn122"><p>https://en.wikipedia.org/wiki/Shell_(computing)<a href="#fnref122" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn123"><p>En Windows <code>cmd.exe</code>, escribe <code>echo %errorlevel%</code>. En PowerShell, escribe <code>$LastExitCode</code><a href="#fnref123" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn124"><p>Si necesitas un valor numérico, convierte la cadena con algo como <code>atoi()</code> o <code>strtol()</code><a href="#fnref124" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn125"><p>En Windows CMD.EXE, usa <code>set FROTZ=value</code>. En PowerShell, utilice <code>$Env:FROTZ=value</code><a href="#fnref125" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn126"><p>https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html<a href="#fnref126" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn127"><p>No siempre se puede envolver el código con comentarios <code>/*</code> <code>*/</code> porque no se anidan<a href="#fnref127" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn128"><p>Esto no es realmente una macro—es técnicamente un identificador. Pero es el único identificador predefinido y se parece mucho a una macro, así que lo incluyo aquí. Como un rebelde<a href="#fnref128" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn129"><p>Una implementación hospedada significa básicamente que estás ejecutando el estándar C completo, probablemente en un sistema operativo de algún tipo. Lo cual es probable. Si se está ejecutando en un sistema embebido, probablemente se trate de una implementación <em>standalone</em><a href="#fnref129" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn130"><p>OK, sé que era una respuesta evasiva. Básicamente hay una extensión opcional que los compiladores pueden implementar en la que se comprometen a limitar ciertos tipos de comportamiento indefinido para que el código C sea más susceptible de análisis estático. Es poco probable que necesites usar esto<a href="#fnref130" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn131"><p><em>Quebrantando la ley… quebrantando la ley…</em><a href="#fnref131" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn132"><p>https://www.openmp.org/<a href="#fnref132" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn133"><p>Técnicamente decimos que tiene un <em>tipo incompleto</em><a href="#fnref133" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn134"><p>Aunque algunos compiladores tienen opciones para forzar que esto ocurra—busca <code>__attribute__((packed))</code> para ver cómo hacer esto con GCC<a href="#fnref134" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn135"><p><code>super</code> no es una palabra clave, por cierto. Sólo estoy robando terminología de programación orientada a objetos<a href="#fnref135" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn136"><p>Suponiendo <code>charts</code> de 8 bits, es decir <code>CHAR_BIT == 8</code>.<a href="#fnref136" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn137"><p>https://en.wikipedia.org/wiki/Type_punning<a href="#fnref137" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn138"><p>me acabo de inventar esa cifra, pero probablemente no esté muy lejos<a href="#fnref138" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn139"><p>Hay un poco de diablo en los detalles con los valores que se almacenan sólo en los registros, pero podemos ignorar con seguridad que para nuestros propósitos aquí. Además, la especificación C no se pronuncia sobre estos “registros” más allá de la palabra clave <code>register</code>, cuya descripción no menciona los registros<a href="#fnref139" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn140"><p>Es muy probable que obtengas números diferentes en el tuyo<a href="#fnref140" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn141"><p>No hay absolutamente nada en la especificación que diga que esto funcionará siempre así, pero resulta que funciona así en mi sistema<a href="#fnref141" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn142"><p>Incluso si <code>E</code> es <code>NULL</code>, resulta, extrañamente<a href="#fnref142" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn143"><p>https://beej.us guide/bgclr/html/split/stringref.html#man-memcpy<a href="#fnref143" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn144"><p>Tu compilador de C no está obligado a añadir bytes de relleno, y los valores de cualquier byte de relleno que se añada son indeterminados<a href="#fnref144" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn145"><p>Esto variará dependiendo de la arquitectura, pero mi sistema es <em>little endian</em>, lo que significa que el byte menos significativo del número se almacena primero. Los sistemas <em>Big endian</em> tendrán el <code>12</code> primero y el <code>78</code> al final. Pero la especificación no dicta nada sobre esta representación<a href="#fnref145" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn146"><p>Es una característica opcional, así que podría no estar ahí—pero probablemente sí<a href="#fnref146" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn147"><p>Estoy imprimiendo los valores de 16 bits invertidos porque estoy en una máquina little-endian y así es más fácil de leer<a href="#fnref147" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn148"><p>Suponiendo que apunten al mismo objeto array.<a href="#fnref148" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn149"><p>El Lenguaje de Programación Go inspiró su sintaxis de declaración de tipos en lo contrario de lo que hace C.<a href="#fnref149" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn150"><p>No es que otros lenguajes no lo hagan… lo hacen. Es interesante ver cómo muchos lenguajes modernos utilizan los mismos operadores para bitwise que C<a href="#fnref150" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn151"><p>https://en.wikipedia.org/wiki/Bitwise_operation<a href="#fnref151" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn152"><p>Es decir, se supone que nosotros, los desarrolladores de pacotilla, no sabemos lo que hay ahí ni lo que significa. La especificación no dicta qué es en detalle<a href="#fnref152" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn153"><p>Sinceramente, sería posible eliminar esa limitación del lenguaje, pero la idea es que las macros <code>va_start()</code>, <code>va_arg()</code>, y <code>va_end()</code> se puedan escribir en C. Y para que eso ocurra, necesitamos alguna forma de inicializar un puntero a la ubicación del primer parámetro. Y para ello, necesitamos el <em>nombre</em> del primer parámetro. Se necesitaría una extensión del lenguaje para hacer esto posible, y hasta ahora el comité no ha encontrado una razón para hacerlo<a href="#fnref153" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn154"><p>“Este planeta tiene -o más bien tenía- un problema: la mayoría de las personas que viven en él son infelices durante casi todo el tiempo. Se sugirieron muchas soluciones para este problema, pero la mayoría de ellas tenían que ver con el movimiento de pequeños trozos de papel verde, lo cual era extraño porque, en general, no eran los pequeños trozos de papel verde los que eran infelices.” —La Guía del Autoestopista Galáctico, Douglas Adams<a href="#fnref154" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn155"><p>Recuerda que <code>char</code> es sólo un entero del tamaño de un byte<a href="#fnref155" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn156"><p>Excepto <code>isdigit()</code> e <code>isxdigit()</code>.<a href="#fnref156" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn157"><p>Por ejemplo, podríamos almacenar el punto de código en un entero big-endian de 32 bits. ¡Sencillo! Acabamos de inventar una codificación. En realidad no; eso es lo que es la codificación UTF-32BE. Oh, bueno… ¡volvamos a la rutina!<a href="#fnref157" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn158"><p>Ish. Técnicamente, es de anchura variable—hay una manera de representar puntos de código superiores a <span class="math inline">\(2^{16}\)</span> juntando dos caracteres UTF 16.<a href="#fnref158" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn159"><p>Hay un carácter especial llamado <em>Byte Order Mark</em> (BOM), punto de código 0xFEFF, que puede preceder opcionalmente al flujo de datos e indicar el endianess. Sin embargo, no es obligatorio<a href="#fnref159" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn160"><p>De nuevo, esto sólo es cierto en UTF-16 para caracteres que caben en dos bytes<a href="#fnref160" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn161"><p>https://en.wikipedia.org/wiki/UTF-8<a href="#fnref161" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn162"><p>https://www.youtube.com/watchv=MijmeoH9LT4<a href="#fnref162" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn163"><p>Presumiblemente el compilador hace el mejor esfuerzo para traducir el punto de código a cualquiera que sea la codificación de salida, pero no puedo encontrar ninguna garantía en la especificación<a href="#fnref163" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn164"><p>Con un especificador de formato como <code>"%.12s"</code>, por ejemplo.<a href="#fnref164" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn165"><p><code>wcscoll()</code> es lo mismo que <code>wcsxfrm()</code> seguido de <code>wcscmp()</code>.<a href="#fnref165" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn166"><p>Ish—things get funky with multi-<code>char16_t</code> UTF-16 encodings.<a href="#fnref166" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn167"><p>https://en.wikipedia.org/wiki/Iconv<a href="#fnref167" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn168"><p>http://site.icu-project.org/<a href="#fnref168" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn169"><p>https://en.wikipedia.org/wiki/Core_dump<a href="#fnref169" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn170"><p>Confusamente, <code>sig_atomic_t</code> es anterior a los atómicos sin bloqueo y no es lo mismo<a href="#fnref170" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn171"><p>Si <code>sig_action_t</code> es con signo, el rango será como mínimo de <code>-127</code> a <code>127</code>. Si es sin signo, al menos de <code>0</code> a <code>255</code><a href="#fnref171" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn172"><p>Esto se debe a que las VLAs se asignan típicamente en la pila, mientras que las variables <code>static</code> están en el montón. Y la idea con las VLAs es que serán automáticamente desasignadas cuando el marco de la pila sea vaciado al final de la función<a href="#fnref172" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn173"><p>https://en.wikipedia.org/wiki/Goto#Criticism<a href="#fnref173" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn174"><p>Me gustaría señalar que usar <code>goto</code> en todos estos casos es evitable. Puedes usar variables y bucles en su lugar. Es sólo que algunas personas piensan que <code>goto</code> produce el <em>mejor</em> código en esas circunstancias<a href="#fnref174" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn175"><p>https://en.wikipedia.org/wiki/Tail_call<a href="#fnref175" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn176"><p>Que no es exactamente lo mismo, ya que es una matriz, no un puntero a un <code>int</code><a href="#fnref176" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn177"><p>Una variable utilizada aquí <em>es</em> una expresión.<a href="#fnref177" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn178"><p>Tanto el “puntero de pila” como el “contador de programa” están relacionados con la arquitectura subyacente y la implementación de C, y no forman parte de la especificación<a href="#fnref178" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn179"><p>La razón aquí es que el programa puede almacenar un valor temporalmente en un <em>registro de la CPU</em> mientras está trabajando en él. En ese intervalo de tiempo, el registro contiene el valor correcto, y el valor en la pila podría estar desfasado. Entonces más tarde los valores del registro se sobrescribirían y los cambios en la variable se perderían<a href="#fnref179" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn180"><p>Es decir, permanecer asignada hasta que el programa termine sin que haya forma de liberarla<a href="#fnref180" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn181"><p>Esto funciona porque en C, los punteros tienen el mismo tamaño independientemente del tipo de datos al que apunten. Así que el compilador no necesita saber el tamaño del nodo <code>struct</code> en este punto; sólo necesita saber el tamaño de un puntero<a href="#fnref181" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn182"><p>https://en.wikipedia.org/wiki/Complex_number<a href="#fnref182" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn183"><p>Esto ha sido más difícil de investigar, y aceptaré cualquier información adicional que alguien pueda darme. que <code>I</code> podría definirse como <code>_Complex_I</code> o <code>_Imaginary_I</code>, si este último existe. <code>_Imaginary_I</code> manejará ceros con signo, pero <code>_Complex_I</code> <em>puede</em> que no. Esto tiene implicaciones con los cortes de rama y otras cosas de números complejos. Tal vez. ¿Te das cuenta de que me estoy saliendo de mi elemento? En cualquier caso, las macros <code>CMPLX()</code> se comportan como si <code>I</code> estuviera definido como <code>_Imaginary_I</code>, con ceros con signo, aunque <code>_Imaginary_I</code> no exista en el sistema<a href="#fnref183" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn184"><p>La simplicidad de esta afirmación no hace justicia a la increíble cantidad de trabajo que supone simplemente entender cómo funciona realmente la coma flotante. https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/<a href="#fnref184" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn185"><p>Este es el único que no comienza con una “c” extra, extrañamente.<a href="#fnref185" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn186"><p>Algunas arquitecturas tienen datos de distinto tamaño con los que la CPU y la RAM pueden operar a mayor velocidad que con otros. En esos casos, si necesitas el número de 8 bits más rápido, puede que te de un tipo de 16 o 32 bits en su lugar porque simplemente es más rápido. Así que con esto, no sabrás lo grande que es el tipo, pero será al menos tan grande como tú digas.<a href="#fnref186" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn187"><p>Es decir, que el sistema tenga enteros de 8, 16, 32 o 64 bits sin relleno que utilicen la representación del complemento a dos, en cuyo caso la variante <code>intN_t</code> para ese número concreto de bits <em>debe</em> estar definida<a href="#fnref187" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn188"><p>En la Tierra, al menos. A saber qué locos sistemas usan <em>allá</em>…<a href="#fnref188" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn189"><p>¡Vale, no me mates! GMT es técnicamente una zona horaria, mientras que UTC es un sistema horario mundial. Además, algunos países pueden ajustar GMT para el horario de verano, mientras que UTC nunca se ajusta para el horario de verano<a href="#fnref189" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn190"><p>Hay que admitir que hay más de dos.<a href="#fnref190" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn191"><p>https://en.wikipedia.org/wiki/Unix_time<a href="#fnref191" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn192"><p>Lo harás en POSIX, donde <code>time_t</code> es definitivamente un entero. Desafortunadamente el mundo entero no es POSIX, así que ahí estamos<a href="#fnref192" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn193"><p>https://en.wikipedia.org/wiki/POSIX_Threads<a href="#fnref193" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn194"><p>Yo soy más un fan de compartir-nada, y mis habilidades con las construcciones de multihilo clásico están oxidadas, por decir algo<a href="#fnref194" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn195"><p>Sí, <code>pthreads</code> con “<code>p</code>”. Es la abreviatura de POSIX threads, una librería de la que C11 tomó prestado libremente para su implementación de hilos<a href="#fnref195" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn196"><p>Según §7.1.4¶5.<a href="#fnref196" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn197"><p>A menos que <code>thrd_detach()</code>. Más sobre esto más adelante<a href="#fnref197" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn198"><p>Aunque no creo que tengan que serlo. Es sólo que los hilos no parecen ser reprogramados hasta que alguna llamada al sistema como podría ocurrir con un <code>printf()</code>… que es por lo que tengo el <code>printf()</code> ahí<a href="#fnref198" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn199"><p>Abreviatura de “exclusión mutua”, alias un “bloqueo” en una sección de código que sólo un hilo puede ejecutar<a href="#fnref199" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn200"><p>Es decir, tu proceso entrará en reposo<a href="#fnref200" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn201"><p>Puede que esperaras que fuera “hora a partir de ahora”, pero te gustaría pensar eso, ¿verdad?<a href="#fnref201" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn202"><p>¡Y por eso se llaman <em>variables de condición</em>!<a href="#fnref202" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn203"><p>Survival of the fittest! Right? I admit it’s actually nothing like that.<a href="#fnref203" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn204"><p>La macro <code>__STDC_VERSION__</code> no existía a principios de C89, así que si estás preocupado por eso, compruébalo con <code>#ifdef</code><a href="#fnref204" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn205"><p>La razón de esto es que cuando está optimizado, mi compilador ha puesto el valor de <code>x</code> en un registro para hacer que el bucle <code>while</code> sea rápido. Pero el registro no tiene forma de saber que la variable fue actualizada en otro hilo, así que nunca ve el <code>3490</code>. Esto no está realmente relacionado con la parte <em>todo o nada</em> de la atomicidad, sino que está más relacionado con los aspectos de sincronización de la siguiente sección<a href="#fnref205" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn206"><p>Hasta que diga lo contrario, estoy hablando en general de operaciones <em>secuencialmente consistentes</em>. Más sobre lo que eso significa pronto<a href="#fnref206" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn207"><p>Más sana desde la perspectiva del programador.<a href="#fnref207" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn208"><p>Aparentemente C++23 está añadiendo esto como una macro.<a href="#fnref208" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn209"><p>La especificación señala que pueden diferir en tamaño, representación y alineación<a href="#fnref209" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn210"><p>Acabo de sacar ese ejemplo de la nada. Quizás no importe en Intel/AMD, pero podría importar en algún sitio, ¡maldita sea!<a href="#fnref210" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn211"><p>C++ elabora que si la señal es el resultado de una llamada a <code>raise()</code>, se secuencia <em>después</em> de la función <code>raise()</code><a href="#fnref211" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn212"><p>https://en.wikipedia.org/wiki/Test-and-set<a href="#fnref212" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn213"><p>Porque consume se refiere a las operaciones que dependen del valor de la variable atómica adquirida, y no hay variable atómica en un vallado<a href="#fnref213" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn214"><p>https://www.youtube.com/watch?v=A8eCGOqgvH4<a href="#fnref214" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn215"><p>https://www.youtube.com/watch?v=KeLBd2EJLOU<a href="#fnref215" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn216"><p>https://preshing.com/archives/<a href="#fnref216" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn217"><p>https://preshing.com/20120612/an-introduction-to-lock-free-programming/<a href="#fnref217" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn218"><p>https://preshing.com/20120913/acquire-and-release-semantics/<a href="#fnref218" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn219"><p>https://preshing.com/20130702/the-happens-before-relation/<a href="#fnref219" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn220"><p>https://preshing.com/20130823/the-synchronizes-with-relation/<a href="#fnref220" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn221"><p>https://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/<a href="#fnref221" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn222"><p>https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/<a href="#fnref222" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn223"><p>https://en.cppreference.com/w/c/atomic/memory_order<a href="#fnref223" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn224"><p>https://en.cppreference.com/w/c/language/atomic<a href="#fnref224" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn225"><p>https://docs.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming<a href="#fnref225" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn226"><p>https://www.reddit.com/r/C_Programming/<a href="#fnref226" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn227"><p>¡A menos que compiles con las optimizaciones activadas (probablemente)! Pero creo que cuando hace esto, no se está comportando según la especificación<a href="#fnref227" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn228"><p>https://beej.us/guide/bgclr/html/split/stdlib.html#man-exit<a href="#fnref228" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn229"><p>https://beej.us/guide/bgclr/html/split/stdlib.html#man-abort<a href="#fnref229" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn230"><p>https://en.wikipedia.org/wiki/Data_structure_alignment<a href="#fnref230" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
</body>
</html>
